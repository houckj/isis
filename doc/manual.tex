%
%  $Id: manual.tex,v 1.356 2004/09/09 11:31:48 houck Exp $
%
% ISIS Technical Manual
%
% Author:  John C. Houck <houck@space.mit.edu>
%
% Last Revised:  $Date: 2004/09/09 11:31:48 $
%

\documentclass{book}
\usepackage{guide}
\usepackage{amsmath}
\usepackage{makeidx}
\usepackage{verbatim}
\usepackage{tocbibind}
\usepackage{ifpdf}
%\usepackage{html}

\sloppy

%begin{latexonly}
\newif\ifpdf
\ifx\pdfoutput\undefined
   \pdffalse               % we are not running pdflatex
\else
   \pdfoutput=1            % we are running pdflatex
   \pdftrue
\fi
%end{latexonly}

%begin{latexonly}
\ifpdf
  \usepackage{thumbpdf}
  \usepackage{graphicx}
  \usepackage[pdftex=true,bookmarks=true,hyperindex=true,plainpages=false]{hyperref}
  %\newcommand{\putfig}[1]{\pdfximage{#1.pdf}}
  \newcommand{\putfig}[1]{\includegraphics{#1.pdf}}
  \pdfstringdefDisableCommands{\let\textsubscript\relax}
   % >>> hyperref should be last included package
\else
   \usepackage{epsf}
   \usepackage{epsfig}
   \newcommand{\putfig}[1]{\psfig{file=#1.ps}}
\fi
%end{latexonly}

% Set margins and separation spaces

\oddsidemargin=0.50in
\evensidemargin=0.00in
\baselineskip=12pt
\textwidth=5.75in

%begin{latexonly}
\ifpdf
   \topmargin=-0.25in
\else
   \topmargin=0.5in
\fi
%end{latexonly}

\textheight=8.75in
\topsep=2pt
\setlength{\parindent}{0 cm}
\setlength{\parskip}{\baselineskip}
\renewcommand{\baselinestretch}{0.95}

% Add special commands

\newcommand{\putdraft}{\special{!userdict begin /bop-hook{gsave 200 30
translate 65 rotate /Times-Roman findfont 216 scalefont setfont 0 0
moveto 0.9 setgray (DRAFT) show grestore}def end}}
\newcommand{\gtrsim}{\ ^{\displaystyle >}_{\displaystyle \sim}\ }
\newcommand{\lesssim}{\ ^{\displaystyle <}_{\displaystyle \sim}\ }
\newcommand{\st}{\rule[-2mm]{0mm}{6mm}}
\newcommand{\stt}{\rule[-3mm]{0mm}{8mm}}

\newcommand{\D}{{\rm d}}

\newcommand{\isisweb}{{\tt http://space.mit.edu/cxc/isis/}}

\newcommand{\HRMA}{{\sc HRMA}}
\newcommand{\isisx}{{\sc ISIS~}}
\newcommand{\isis}{{\sc ISIS}}
\newcommand{\isisversion}{1.0}
\newcommand{\cfitsio}{{\sc CFITSIO}}
\newcommand{\pgplot}{{\sc PGPLOT}}
\newcommand{\slang}{{\sc S-Lang}}
\newcommand{\xspec}{{\sc XSPEC}}

% Environment for ISIS function descriptions

%begin{latexonly}
\newenvironment{isisfunction}[4]%
{\index{{#1}@{\tt #1}}%
  \ifpdf
     % no pdf contents line
  \else
     \addcontentsline{toc}{subsection}{{#1} -- {#2}}
  \fi
  \vbox{
          \vspace*{\baselineskip}
          {\LARGE\tt #1}\vspace*{\baselineskip}\\
          {{\it Purpose:}~~{#2}}\\
          {{\it Usage:}~~{\tt #3}}\\
          {{\it See Also:}~~{\tt #4}}
       }
}%
{ }
%end{latexonly}

% \begin{htmlonly}
% \newenvironment{isisfunction}[4]{{#1}\\{#2}\\{#3}\\{#4}\\}{ }%
% \end{htmlonly}

% Create an index
\makeindex

% Set title page information
\author{John C. Houck\\
        {\normalsize WWW: \isisweb} \\
        {\normalsize Mailing List: isis-users@space.mit.edu} \\ \\ \\ \\}

\officename{Chandra X-Ray Observatory Center / MIT Center for Space Research}

\shorttitle{ISIS \isisversion\ Technical Manual ~~$\cdot$~~ Revision 1.0}

\title{\huge \isisx \isisversion \\ Technical Manual}

\versionnumber{Revision 1.0}

\date{\today}

\printingnumber{}

\printingdate{}

\publisher{ {\large {\bf Chandra X-Ray Observatory Center}} \\
            MIT Center for Space Research \\
            One Hampshire St. \\
            Building NE80 \\
            Cambridge, MA 02139--4307 \\
            USA}

% Add a background DRAFT to document if desired
%\putdraft

\begin{document}

%begin{latexonly}
\ifpdf
\DeclareGraphicsExtensions{.pdf}
\fi
%end{latexonly}

\maketitle
\begin{titlepage}
\vspace*{7.6cm}
\vfill
\end{titlepage}

\setcounter{page}{0}
\pagenumbering{roman}

\newpage
\null\vspace*{3cm}
\begin{quote}
This document is part of ISIS, the Interactive Spectral Interpretation System \\
Copyright (C) 1998-2012 Massachusetts Institute of Technology

This software was developed by the MIT Center for Space Research under
contract SV1-61010 from the Smithsonian Institution.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
\end{quote}

% Top Level Overview

%\newpage
%\cleardoublepage
\setcounter{page}{0}
\pagenumbering{roman}

\chapter*{Overview\markboth{}{Overview}}
\addcontentsline{toc}{chapter}{\numberline{}Overview}
\label{list:overview}
%begin{latexonly}
\ifpdf
  \pdfbookmark[-1]{Overview}{list:overview}
\fi
%end{latexonly}

{\Large

{\bf Part~\ref{part:intro}: Introduction to ISIS \dotfill \pageref{part:intro}}

\begin{quotation}
\normalsize
{\bf Section~\ref{chap:intro}: ISIS in Context \dotfill \pageref{chap:intro}}

{\bf Section~\ref{chap:quick}: Quick Start \dotfill \pageref{chap:quick}}

{\bf Section~\ref{chap:prog}: Programming ISIS \dotfill \pageref{chap:prog}}

{\bf Section~\ref{chap:common-tasks}: Common ISIS Tasks \dotfill \pageref{chap:common-tasks}}

\end{quotation}

{\bf Part~\ref{part:refman}: ISIS Reference Manual \dotfill \pageref{part:refman}}

\begin{quotation}
\normalsize
{\bf Section~\ref{chap:specdb}: The Spectroscopy Database \dotfill \pageref{chap:specdb}}

{\bf Section~\ref{chap:interactive}: Interactive Mode Features \dotfill \pageref{chap:interactive}}

{\bf Section~\ref{chap:funcref}: ISIS Function Reference \dotfill \pageref{chap:funcref}}

{\bf Section~\ref{chap:xspec-module}: The XSPEC Module \dotfill \pageref{chap:xspec-module}}

{\bf Section~\ref{chap:custom}: Customizing ISIS Configuration \dotfill \pageref{chap:custom}}

\end{quotation}

{\bf Index \dotfill \pageref{chap:index}}

}

%
% Set up table of contents
%
\newpage
\tableofcontents

%
% Create a list of figures
%
\newpage
\listoffigures

%
% Create a list of tables
%
\newpage
\listoftables

%
% Preface
%
\newpage
\cleardoublepage
\chapter*{Preface\markboth{}{Preface}}
\addcontentsline{toc}{chapter}{\numberline{}Preface}

%\begin{flushleft}

This manual describes \isis, the MIT/CXC {\bf I}nteractive {\bf
S}pectral {\bf I}nterpretation {\bf S}ystem which is designed to
facilitate interpretation and analysis of high resolution X-ray
spectra.  It is being developed as programmable, interactive tool
for studying the physics of X-ray spectrum formation, supporting
measurement and identification of spectral features, and
interaction with a database of atomic structure parameters and
plasma emission models.

\isisx is written entirely in ANSI-C (with a few POSIX extensions)
and is intended to be portable across most Unix operating systems.
It has been used successfully on a variety of 32-bit and 64-bit
processors and under a variety of Unix operating systems including
Linux, FreeBSD, Solaris, SunOS, IBM/AIX, DEC/OSF1 and DEC/Ultrix systems.
\isisx requires subroutine libraries from \cfitsio, \pgplot\ and
\slang, all of which are widely available as free software.

This manual is designed to serve as an introduction, user's guide,
and definitive reference manual to the \isisx package. Please
address any comments or suggestions to the \isisx user's mailing
list {\tt isis-users@space.mit.edu}.

%\end{flushleft}

\vspace{20mm}

\hfill {\it- John Houck, \today} \hfill

\vspace{20mm}

{\it We are continuing to develop \isisx -- more current
information can be found at:}
\begin{center}
\isisweb
\end{center}

\newpage
\cleardoublepage
\pagenumbering{arabic}

\part{Introduction to ISIS \label{part:intro}}

\chapter{Introduction}
\label{chap:intro}

\section{ISIS in Context}

High resolution X-ray spectra can contain a vast amount of information on
the physical conditions in an emitting plasma.  The richness of these data
often lead the observer to examine plasma emission models and their
fundamental atomic data in some detail.  Until recently, the voluminous
atomic data used to generate plasma emission models was often poorly
documented and nearly inaccessible to most X-ray observers. Recent efforts
by Smith, Brickhouse, Liedahl \& Raymond (2001) are helping to improve this
situation by making plasma emission models and atomic data available in a
form which is more portable and accessible to observers.

\isisx is intended to support the analysis of high resolution
X-ray spectra by combining in one package tools to query a
database of atomic data and plasma emission models (e.g. that of
Smith et al. 2001) with tools to manipulate and measure high
resolution spectral data. These tools (called functions in the
rest of this document) simplify low level operations such as file
input, data plotting and database search and retrieval, allowing
users to concentrate on higher level analysis issues. \isisx is
also programmable and extensible, meaning that users can write
scripts to simplify repetitive analysis tasks and can extend the
\isisx command language by adding those scripts (or even
user-supplied C programs) as new commands.  \slang, the
interpreted language which provides these features, also provides
IDL-like array-based mathematical functions which greatly simplify
common analysis operations.\footnote{\slang was created by John E.
Davis and has not been developed or maintained by contract
funding; it is free software, available under the GNU Public
License.}

The primary purpose of \isisx is support of high resolution X-ray
spectroscopy, but an important secondary goal in the design was to
maximize the usefulness of the software by maximizing its
portability.  For this reason, \isisx is written in ANSI C and
uses only widely available, free-software components.  \cfitsio\
and \pgplot\ have been widely used by the astronomy community for
a number of years and are thoroughly tested and known to run on a
wide range of computer systems.  \slang\ is currently less well
known but is fast, portable and provides an easy-to-use C-like
syntax which we believe has a number of clear advantages over
other scripting languages such as Perl, Python and Tcl.

\vfill

\section{The Guilty Parties}

The \isisx development team currently consists of the following individuals:

\begin{center}
\begin{tabular}{lll}
John C. Houck  \hspace{2.5cm}  & MIT/CXC \hspace{2.0cm} & Lead Scientist and Software Engineer\\
John E. Davis          & MIT/CXC & Software Engineering Support \\
David Huenemoerder     & MIT/CXC & Science Support \\
Dan Dewey              & MIT/HETG & Science Support \\
Mike Nowak             & MIT/CXC & Science Support \\
David S. Davis         & MIT/CXC & Science Support \\
\end{tabular}
\end{center}

\section{Acknowledgements}

We gratefully acknowledge the aid and support of various members of the
Chandra X-ray Observatory project including the Mission Support Team, the
Calibration group, and the Data Systems group.

\chapter{Quick Start}
\label{chap:quick}

\section{Obtaining ISIS Source Code, Documentation and Help}

\isisx source code and documentation may be obtained from the \isisx web
page at
\begin{verbatim}
     http://space.mit.edu/cxc/isis/
\end{verbatim}

Please send comments, questions and bug reports to the mailing list
{\tt isis-users@space.mit.edu}.

\section{Installing ISIS}

Once source code is obtained from the web, detailed instructions
on how to install the software may be found in the {\tt INSTALL}
file included with the distribution.  Section \ref{chap:specdb} of
this manual describes how to set up the spectroscopy database.

Note that only a single \isisx installation is required at a given site;
there is no need to install it for each individual user.  This also
simplifies upgrades and minimizes use of disk space.

\subsection{Spectroscopy Database Configuration}

To access the spectroscopy database, \isisx must obtain the full
path to the database directory and the names of all relevant
database files (see \S \ref{chap:specdb}). The person who installs
\isisx should also ensure that a spectroscopy database is
installed and that at least one configuration script is edited to
accurately describe the database location and contents. See
\S\ref{chap:specdb} for a detailed discussion.

\vfill

\section{Running ISIS}
\label{sec:running}

Assuming the \isisx executable exists somewhere on your the
command search path, you can run \isisx by simply typing {\bf isis}
at the Unix prompt.  The interactive help system provides
documentation on \isisx intrinsic functions.  Use {\tt apropos} to
find function names containing a certain substring:
\begin{verbatim}
    isis> apropos("data");
\end{verbatim}
and use {\tt help} to obtain more detailed documentation on
function usage:
\begin{verbatim}
    isis> help("load_data");
\end{verbatim}
Because these commands are used quite often, shortcuts are
available (see \S\ref{sec:shortcuts}).

\index{line-separator!see {{\tt Isis\_Append\_Semicolon}}}
\index{semicolon!see {{\tt Isis\_Append\_Semicolon}}}
\index{{\tt Isis\_Append\_Semicolon}}
\label{about-semicolons}

{\it About the semicolon (;) line-separator:}~~The \slang\
scripting language requires lines to end with a semicolon (;).
However, for interactive use, some people find it annoying to
have to type a semicolon at the end of every line. Using the
intrinsic variable \verb|Isis_Append_Semicolon|, one can
indicate whether or not \isis\ should automatically supply this
semicolon in interactive mode. By default
\verb|Isis_Append_Semicolon=0|, meaning that, in interactive
mode, the user must end each line with a semicolon.  To have
isis automatically append the semicolon to each command line in
interactive mode, set \verb|Isis_Append_Semicolon=1|. The best
way to make sure this value is automatically set every time you
start \isis\ is to set it in your \verb|~/.isisrc| file:
\begin{verbatim}
   Isis_Append_Semicolon = 1;
\end{verbatim}
Although some users find it convenient to have isis
automatically append the semicolon in interactive mode, this
has the important drawback that one cannot reliably cut and
paste into the interactive command line scripts which have
multi-line S-Lang constructs such as loops or function
definitions.

\subsection{A Simple Example: Measuring the Flux in an Emission Line}
\label{subsec:simpleexample}

For this example, we will use the sample data available from the
\isisx source code distribution (see the \verb|isis/test/data|
subdirectory).

First, load the spectra:
\begin{verbatim}
isis> load_data ("acisf01318N003_pha2.fits.gz");
Reading: ............
Integer_Type[12]
isis> list_data;
Current Spectrum List:
 id    instrument part/m  src    use/nbins   A   R     totcts   exp(ksec)  target
  1     HETG-ACIS  heg-3   1    8192/ 8192   -   -  2.1000e+01    26.701  CAPELLA
  2     HETG-ACIS  heg-2   1    8192/ 8192   -   -  2.7000e+02    26.701  CAPELLA
  3     HETG-ACIS  heg-1   1    8192/ 8192   -   -  5.8410e+03    26.701  CAPELLA
  4     HETG-ACIS  heg+1   1    8192/ 8192   -   -  5.0670e+03    26.701  CAPELLA
  5     HETG-ACIS  heg+2   1    8192/ 8192   -   -  1.0300e+02    26.701  CAPELLA
  6     HETG-ACIS  heg+3   1    8192/ 8192   -   -  8.0000e+00    26.701  CAPELLA
  7     HETG-ACIS  meg-3   1    8192/ 8192   -   -  9.0000e+02    26.701  CAPELLA
  8     HETG-ACIS  meg-2   1    8192/ 8192   -   -  8.6200e+02    26.701  CAPELLA
  9     HETG-ACIS  meg-1   1    8192/ 8192   -   -  2.5683e+04    26.701  CAPELLA
 10     HETG-ACIS  meg+1   1    8192/ 8192   -   -  2.0369e+04    26.701  CAPELLA
 11     HETG-ACIS  meg+2   1    8192/ 8192   -   -  6.3900e+02    26.701  CAPELLA
 12     HETG-ACIS  meg+3   1    8192/ 8192   -   -  5.7000e+02    26.701  CAPELLA

isis>
\end{verbatim}
\isisx prints a dot (.) as each spectrum is read from the data
file.  By default, \isisx loads all the data in the specified
file.  By specifying the row index, it is also possible to load
a single spectrum from a Type II PHA file.  Once the data is
loaded, \verb|list_data| shows a list of data sets.  Each data
set is identified by an index ({\bf id}); as we will see below,
this index is used to refer to an individual data set.  The
columns labeled {\bf part/m}, and {\bf src} indicate the
spectrum "part" (e.g. the HEG is \verb|tg_part=1| and
the MEG is \verb|tg_part=2|), the dispersion order ({\bf m}), and
the source index ({\bf src}).  The next two columns show the
number of bins in the data set ({\bf nbins}) and the number
currently noticed for fitting ({\bf nbins}). The columns
labeled {\bf A} and {\bf R} indicate the index of the assigned
ARF and RMF respectively; a dash (-) indicates that no response
function has been assigned. The last four columns give the
total number of counts in the spectrum ({\bf totcts}), the
exposure time ({\bf exp}), a plot color index ({\bf clr}) and
the target name.

For brevity, the above example listing was generated with the
global variable \verb|Isis_List_Filenames=0|.  By default, this
variable is non-zero, causing the names of associated spectrum
and background files to be printed along with the other
information for each dataset.

The line \verb|Integer_Type[12]| indicates that the {\bf
load\_data} function returned a 12 element integer array
(containing the indices of the data sets loaded).  Because this
array was not stored in a variable and was not explicitly ignored,
\isisx handled the return value automatically.  This is an
important and useful feature of \slang\ which will be discussed in
more detail later on.

To plot the counts histogram from the minus first-order MEG
spectrum, use {\bf plot\_data\_counts}:
\begin{verbatim}
isis> plot_data_counts (9);
 Graphics device/type (? to see list, default /NULL): /xw
isis>
\end{verbatim}
\pgplot\ prompts the user for a plot device, defaulting to
the {\tt /NULL} device if no default has been specified
using {\tt PGPLOT\_DEV} environment
variable variable.  Here, we selected {\bf /xw} to plot to the
screen using the X-windows.

Because the plot command {\tt plot\_data\_counts} is somewhat
cumbersome to type, you may wish to define a shorter alias:
\begin{verbatim}
isis> alias ("plot_data_counts", "pdc");
\end{verbatim}
Now clear the plot and re-draw it using this new command alias:
\begin{verbatim}
isis> clear;
isis> pdc (9);
\end{verbatim}

Next we load the ARF and assign it to the appropriate data set:
\begin{verbatim}
isis> () = load_arf ("acisf01318_000N001MEG_-1_garf.fits.gz");
isis> list_arf;
Current ARF List:
 id grating detector part/m  src   nbins  exp(ksec)  target
  1    HETG     ACIS meg-1    0     8192    28.12  CAPELLA
file:  acisf01318_000N001MEG_-1_garf.fits.gz
isis> assign_arf(1,9);
isis>
\end{verbatim}
Note that here we have explicitly ignored the return value from the
{\bf load\_arf} function and that the {\bf assign\_arf} function did
not return anything;  function return values are normally used
either to return requested information or to provide a way of testing
whether or not the function call succeeded.  The latter values are
especially useful in scripts but may often be ignored in interactive mode.
Once the ARF is loaded into the internal list, the updated list of ARFs
is displayed showing information similar to that in the list of
data sets.

Now load the RMF and assign it to the same data set:
\begin{verbatim}
isis> () = load_rmf ("acismeg1D1999-07-22rmfN0002.fits.gz");
isis> list_rmf;

Current RMF List:
 id grating detector  type   file
  1     MEG   ACIS-S  file:  ... acismeg1D1999-07-22rmfN0002.fits.gz

isis> assign_rmf(1,9);
isis>
\end{verbatim}

Now, let's focus on a single emission line and measure the flux in
the line. First, change the X-axis range to display the 12-13 \AA
region and re-draw the plot:
\begin{verbatim}
isis> xrange(12.0,13.0);
isis> pdc (9);
\end{verbatim}
When fitting models to data, \isisx fits all the currently loaded data sets
simultaneously.  Because we want to fit only a single Gaussian to a single
spectrum, we must first ignore all the other data sets and notice only the
wavelength range we want to fit:
\begin{verbatim}
isis> ignore ([ [1:8], [10:12] ]);
isis> xnotice (9, 12.05, 12.2);
\end{verbatim}
The {\bf ignore} function takes an array of data-set indices to
ignore. This function can also take an optional wavelength range
which applies to all the indicated data sets; if no wavelength range is
specified, the entire data set is ignored.  The {\bf xnotice}
function e{\bf x}clusively-{\bf notice}s the specified range
of dataset 9.

To fit a single Gaussian, define the fit-function as
\begin{verbatim}
isis> fit_fun ("gauss(1)");
\end{verbatim}
The integer index indicates which instance of the Gaussian is
used; one could fit three Gaussians using
\verb|fit_fun("gauss(1)+gauss(2)+gauss(3)");|. To list the fit
parameters, use {\bf list\_par}
\begin{verbatim}
isis> list_par;
gauss(1)
 idx  param        tie-to  freeze     value      min      max
  1  gauss(1).area     0     0             0        0        0
  2  gauss(1).center   0     0             0        0        0
  3  gauss(1).sigma    0     0             0        0        0
isis>
\end{verbatim}
This listing shows the function definition on the first line and
then lists the fit parameters, indicating which parameters are
linked or frozen, the parameter values and the allowed parameter
ranges.  Setting the {\tt min} and {\tt max} values to zero
indicates that the corresponding parameter value is unconstrained.

To set the parameter values from the command line, one could use
either {\bf set\_par} or {\bf edit\_par}.  Although it is a matter
of personal preference, the {\bf set\_par} is generally more
useful in scripts and {\bf edit\_par} is often more useful in
interactive mode.  The {\bf edit\_par} function loads the
parameter list into the editor specified by your {\tt EDITOR}
environment variable (or {\tt vi} by default). After using the
editor to enter the necessary information, save the file and exit
the editor. Here, so that we can show the screen interaction
explicitly, we use {\bf set\_par} to provide initial parameter
values:
\begin{verbatim}
isis> set_par(1,100);
isis> set_par(2,12.15);
isis> set_par(3,0.03);
\end{verbatim}
Several different versions of the syntax are supported; which
is most useful depends on the circumstance.

For example, we could have used
\begin{verbatim}
isis> set_par ("gauss(1)", [100, 12.15, 0.03]);
\end{verbatim}
This form is useful because it takes only one line and doesn't
require knowing the parameter indices, but it requires you to
remember the order in which the parameters are defined.
Alternatively, we could have used this syntax:
\begin{verbatim}
isis> set_par ("gauss(1).area", 100);
isis> set_par ("gauss(1).center", 12.15);
isis> set_par ("gauss(1).sigma", 0.03);
\end{verbatim}
This doesn't require knowledge of the parameter indices, but it
requires more typing and requires correct spelling of the
parameter names.

Once the parameters have been set, list the current values
using \verb|list_par|:
\begin{verbatim}
isis> list_par;
gauss(1)
 idx  param        tie-to  freeze         value          min          max
  1  gauss(1).area     0     0               100            0            0
  2  gauss(1).center   0     0             12.15            0            0
  3  gauss(1).sigma    0     0              0.03            0            0
\end{verbatim}
In interactive mode, one can do this in yet a different way
by using the function {\bf ifit\_fun} which reads
the plot cursor to initialize the fit parameters
(see \S\ref{chap:funcref}).

Because the specified normalization is probably not even close to
the correct value, we'll use {\bf renorm\_counts} to obtain a better
initial value before doing the fit:
\begin{verbatim}
isis> renorm_counts;
 Parameters[Variable] = 3[3]
            Data bins = 30
           Chi-square = 1215
   Reduced chi-square = 45
isis>
\end{verbatim}
The screen output shows how many parameters are being fit, how
many are variable, the number of data bins being fit and gives the
resulting $\chi^2$ fit-statistic. Now find the best fit, allowing
all the parameters to vary:
\begin{verbatim}
isis> fit_counts;
 Parameters[Variable] = 3[3]
            Data bins = 30
  Best fit chi-square = 28.86
   Reduced chi-square = 1.069
isis>
\end{verbatim}
To overlay the best-fit model, use the {\bf oplot\_model\_counts} function.
As before, we can define an alias to save typing:
\begin{verbatim}
isis> alias ("oplot_model_counts", "opmc");
isis> opmc (9);
\end{verbatim}

To save the fit-results in a file one can either use the default
\isisx parameter file format or one can make use of the low-level
\slang\ functions to save the values of interest in a different,
user-defined format.  To save using the default parameter file
format:
\begin{verbatim}
isis> save_par("gfit.p");
\end{verbatim}
The default format is exactly the same as the screen listing
generated by {\tt list\_par}.  The main advantage to saving the
fit-function and its parameters in this format, is that the values
can be restored using {\bf load\_par}.

To show how to save the fit-results using a user-defined format,
suppose we want to save the best-fit flux along with 90\%
confidence limits and that we want the wavelengths listed in the
first column and the line width in the second column.  Here's how
to do that:

First, compute the necessary confidence limits using {\bf vconf}:
\begin{verbatim}
isis> (amin, amax) = vconf(1);
Finding best fit
Best fit par=  1.04961248e-03: chisqr= 2.88578026e+01
Allowed parameter range is currently unrestricted.
Please specify finite min/max values for parameter confidence limit search.
\end{verbatim}
Oops -- we forgot to specify the range of parameter values for the
confidence limit search. Use the optional arguments of {\bf
set\_par} for that:
\begin{verbatim}
isis> a = get_par(1);
isis> set_par(1, a, 0, 0.9*a, 1.1*a);
\end{verbatim}
Here, we used the {\bf get\_par} function to get the exact parameter value rather
than typing it again from the screen or from the saved parameter file.  We then
chose parameter value ranges of $\pm$10\%.  Now compute the
confidence limits, saving the values in variables {\tt amin} and {\tt amax}:
\begin{verbatim}
isis> (amin, amax) = vconf(1);
Finding best fit
Best fit par=  1.04961248e-03: chisqr= 2.88578026e+01
Minimizing for par=  9.97151856e-04
par=  9.97151856e-04  chisqr=  3.0389e+01  dchisqr=  1.5316e+00
Minimizing for par=  9.70921544e-04
par=  9.70921544e-04  chisqr=  3.2304e+01  dchisqr=  3.4462e+00
Minimizing for par=  9.87731365e-04
par=  9.87731365e-04  chisqr=  3.0989e+01  dchisqr=  2.1311e+00
Minimizing for par=  9.80331268e-04
par=  9.80331268e-04  chisqr=  3.1529e+01  dchisqr=  2.6711e+00
Minimizing for par=  9.79859377e-04
par=  9.79859377e-04  chisqr=  3.1565e+01  dchisqr=  2.7076e+00
limit found:  9.79859377e-04  dchisqr=  2.7076e+00
Minimizing for par=  1.39913896e-03
par=  1.39913896e-03  chisqr=  9.6803e+01  dchisqr=  6.7945e+01
Minimizing for par=  1.11941726e-03
par=  1.11941726e-03  chisqr=  3.1568e+01  dchisqr=  2.7104e+00
limit found:  1.11941726e-03  dchisqr=  2.7104e+00
isis>
\end{verbatim}
Note that the screen output from {\bf vconf} is verbose;
use {\bf conf} to do a ``quieter'' confidence limit search.

Now that we have our confidence limits, we can save these values
in a custom file format:
\begin{verbatim}
isis> fp = fopen ("gfit.txt", "w");
isis> () = fprintf (fp, "Center  Sigma   Flux (F_lower, F_upper)\n");
isis> () = fprintf (fp, "%10.7f %12.4e  %12.4e  (%9.4e, %9.4e)   \n",
              get_par(2), get_par(3), get_par(1), amin, amax);
isis> fclose(fp);
\end{verbatim}
The first line opens the file {\tt "gfit.txt"} for writing (that's
what the {\tt "w"} is for). The second line prints some
informative column headers (not aligned with the data columns) and
the third prints the data values using a syntax which should be
very familiar to C programmers; e.g. \verb|"10.7"| indicates a
field of width 10 with 7 digits of precision and the {\tt f} and
{\tt e} format specifiers indicate decimal and scientific notation
formats respectively.  Note that we have explicitly ignored the
status return values from the {\bf fprintf} function. Similarly,
one can write a short function to load values from ascii columns,
but it may be simpler to use the built-in functions \verb|readcol|
and \verb|writecol| to read and write ascii files with columns of
numbers. We could also have stored our fit results in a FITS
binary table using the \verb|cfitsio| module.\footnotemark

\footnotetext{For information on the various modules available,
see {\tt http://space.mit.edu/cxc/software/slang/modules/}}

Plots of 2D confidence contours may be generated using
\verb|conf_map_counts| or \verb|conf_map_flux| and
\verb|[o]plot_conf|.

\chapter{Programming ISIS}
\label{chap:prog}

\section{Interactive Scripting}

A convenient way to use \isisx for spectral analysis is to write one or more
scripts, usually in the form of several useful functions, and to iteratively
edit and run these scripts to achieve the desired result. This may sound
cumbersome, but in practice often works quite efficiently, because the
\isisx intrinsic functions already handle a number of tedious tasks such as
manipulating complex data files and searching the spectroscopy database.

For example, one might write one script to load several available data
sets and to set up the spectroscopy database.  Once that script exists,
one can start off later analysis sessions by just running the setup
script.

Similarly, one might write another script to carry out a few standardized
analysis steps, independent of which data set is loaded.  Repeating those
analysis steps for several data sets might then be a matter of running the
analysis script several times.

Some example scripts may be found on the \isisx web page; several
usage examples are discussed in \S\ref{chap:common-tasks}.

In cases where a large, specialized task is currently unsupported in \isis,
it is possible for users to extend \isisx by linking in other subroutine
libraries, {\it without} editing {\it any} of the \isisx source code (see \S
\ref{sec:extending-isis}). This allows large specialized tasks to be handled
in compiled code, yet still take advantage of the existing \isisx functions.

\section{Scripts}
\label{sec:scripts}

To run an \isisx script from the Unix shell, supply the path to the
\isisx script on the Unix command line:
\begin{verbatim}
           unix> isis path/script.sl
\end{verbatim}
when the script finishes, control will return to the
\isisx prompt.  To have control return to the Unix shell when
the script finishes, use the {\tt --batch} option or use
{\tt exit(num)} or {\tt quit} as the last line of the script.

It is also possible to create executable scripts similar to Unix
shell scripts.  If the first line of the script contains
something like
\begin{verbatim}
    #! /usr/bin/env isis
\end{verbatim}
and the script is made executable, e.g.
\begin{verbatim}
    chmod +x path/script.sl
\end{verbatim}
then the script can be executed like any other unix command,
by simply typing the name of the script at the unix prompt:
\begin{verbatim}
    unix>  path/script.sl
\end{verbatim}
In this case, the operating system uses the program specified
on the first line of the script, namely \isis, to interpret
the rest of the file.

To run a script during an interactive \isisx session, use
\begin{verbatim}
           isis> .load path/script.sl
\end{verbatim}
When the script finishes, control will
return to the \isisx prompt (unless {\tt script.sl} contains the {\tt
quit} command).  Note that this shortcut syntax works only in interactive
mode; in a script one must use
\begin{verbatim}
            ()=evalfile("path/script.sl");
\end{verbatim}
The {\tt .source} short-cut is similar to {\tt .load} except that
the script is executed exactly as though each line were entered in
interactive mode.  This provides a useful mechanism for replaying
\isisx log-files.

At startup, \isisx searches for the file {\tt \$HOME/.isisrc} (where
{\tt HOME} is the path to the user's home directory).  If this file
exists, \isisx attempts to interpret it as a \slang\ script.  Any
functions which should run at \isisx startup for, {\it e.g.}
initialization and user-customization should be invoked in this file.
For example, to have the spectroscopy database
loaded automatically, one could add this line to the {\tt .isisrc} file:
\begin{verbatim}
           plasma(aped);
\end{verbatim}
As written, this example assumes the existence of the {\tt aped}
data structure. Alternatively, one may define convenient aliases for
often used functions (see {\tt alias()}).  Site-wide \isisx
customizations may be added and documented using the files
{\tt etc/local.sl} and {\tt doc/local\_help.txt} in the \isisx source
code directory (see \S\ref{chap:quick}).

If it exists, the configuration file {\tt \$HOME/.isisrc} is automatically
loaded before executing any scripts specified on the \isisx
command line.  To prevent loading the configuration file,
use the {\tt -n} option on the command line:
\begin{verbatim}
           unix> isis -n path/script.sl
\end{verbatim}
To load an alternate configuration file, use the \verb|-i| option:
\begin{verbatim}
           unix> isis -i ~user/.isisrc
\end{verbatim}

Scripts may also take command-line arguments using a mechanism
familiar to C programmers. This feature provides a convenient
way for a script to obtain needed parameters from the command
line (e.g. the names of input and output files), allowing
scripts to be run without ever entering the ISIS interactive
mode. The command-line is available as an array of strings
(\verb|__argv|) of length \verb|__argc|. The command line
arguments are most conveniently handled when the first line of
the script is
\begin{verbatim}
    #! /usr/bin/env isis
\end{verbatim}
For example, consider this script:
\begin{verbatim}
  #! /usr/bin/env isis
  define isis_main ()
  {
     vmessage (" _debug_info = %d", _debug_info);
     vmessage ("__argc = %d", __argc);
     message ("__argv:");
     print (__argv);
  }
\end{verbatim}
as command-line arguments (note that \verb|_debug_info| is a
\slang\ intrinsic variable).  Invoking this script (named 'doit')
with two command-line arguments yields
\begin{verbatim}
unix> ./doit a.fits b.txt
 _debug_info = 0
__argc = 3
__argv:
"/tmp/doit"
"a.fits"
"b.txt"
\end{verbatim}
As expected, the command-line array has size \verb|__argc=3|.

\section{Extending ISIS}
\label{sec:extending-isis}

It is possible to add functionality to \isisx without modifying the
\isisx source code.  This can be accomplished in several ways:

One way is to define new \slang\ functions using the existing \isisx
and \slang\ intrinsics.  If these \slang\ function definitions
are placed in a file named e.g. {\tt myfunctions.sl}, they
can easily be made available at the \isisx prompt
\begin{verbatim}
     isis>  ()=evalfile("myfunctions.sl")
     isis>  .load myfunctions.sl                   % simpler equivalent
\end{verbatim}
In fact, much of the \isisx command line interface is implemented this way.

Another way to add new functions is to define new intrinsics in C,
compile that code into a dynamically linked library (named e.g.  {\tt
myfunctions-module.so}) and then import that library at \isisx
run-time using the \slang\ {\tt import} function:
\begin{verbatim}
       import ("myfunctions")
\end{verbatim}
This method is necessarily restricted to machines which support
ELF standard dynamic linking (e.g. Solaris 2.x and Linux provide
support, but SunOS 4.x does not).  Most \xspec\ functions
can already be imported in this way -- see
\verb|modules/xspec/src/xspec-module.c|.  See the \slang\
documentation for more information on dynamic linking.

Finally, several parts of ISIS support user-defined
alternatives. In particular, in fitting models to data, ISIS
provides a number of user-definable operations including
user-defined fit-functions, fit-kernels, instrument responses
(ARFs and RMFs), fit-statistics and minimization algorithms.
Some of these may be implemented in both C (or other compiled
language) and S-lang while others support only
compiled-language or only S-Lang implementations. For details
on adding user-defined fit-functions, see
\verb|add_slang_function| or \verb|add_compiled_function|. To
add a user-defined fit-kernel, see \verb|load_kernel|. To add a
user-defined minimization algorithm or fit-statistic, see
\verb|load_fit_method| and \verb|load_fit_statistic|,
respectively. Although \slang\ is very efficient,
computationally-intensive extensions may be best implemented in
C or Fortran.

The {\sc slirp} code generator makes it very easy to add
arbitrary compiled codes to \isis, including new models.  It
can dramatically reduce the time and effort required to make C,
C++, or {\sc fortran} code callable directly from \isis,
automatically vectorize functions to take advantage of the
powerful numerical and array capabilities native to \slang, and
can even generate Makefiles to automate the build process.

\section{Language Syntax}

The \isisx command language syntax is the syntax of \slang, its
C-like embedded scripting language. Although \isisx can be used
without becoming an expert with \slang, it will be helpful to
understand something of how the scripting language works and, in
particular, how to use its array-manipulation syntax.

All command lines must end with a semicolon (;) (but see the
discussion in \S\ref{about-semicolons} about their use in
interactive mode). Multiple commands are allowed on the same line
and command phrases may also extend over multiple lines.  For
example, try:
\begin{verbatim}
isis> message("testing...." +
      string(1 + 2 + 3));
\end{verbatim}
In this example, the first line was ended with a carriage return.

The comment character is the percent symbol (\%);  all characters
following a percent symbol (\%) on a given line are ignored.

Arrays and complex data structures may be defined and manipulated
(see the \slang\ documentation for details).
\slang\ array indexing syntax is similar to that used in {\sc IDL}.
Array elements are indexed starting at zero;
{\tt x = [ 1, 2, 3, 4 ]} defines {\tt x} as array of 4 values with indices
0, 1, 2, 3 so that, e.g. {\tt x[1] = 2}. The colon shorthand notation is
used to specify ranges, {\it e.g.} {\tt [ 2:7 ]} = {\tt [ 2, 3, 4, 5, 6, 7
]}.  This notation is quite powerful and allows many array manipulation
tasks be to be expressed simply and clearly.  For example, to reverse the
order of elements in an array {\tt x}:
\begin{verbatim}
    x = [2:7];           <---- this means x = [2, 3, 4, 5, 6, 7]

    n = length(x);       <---- n=6  (because x has 6 elements)

    reversed_x = x[[n-1:0:-1]];

            % result is --->  reversed_x = [x[n-1], x[n-2], ..  x[0]]
            %                            = [   7,     6,    ..   2  ]
\end{verbatim}
this order reversal arises e.g. when converting from a wavelength grid
in increasing order to an energy grid in increasing order.

An unusual aspect of the syntax involves functions that return multiple
values.  For example, if a function returns three values, the return values
can be assigned to specific variables using this syntax:
\begin{verbatim}
        variable x,y,z;
        (x,y,z) = some_function ();
\end{verbatim}
Functions may also return values through the function argument
list, using syntax which should be familiar to C programmers:
\begin{verbatim}
        variable x,y,z;
        a_function (&x, &y, &z);
\end{verbatim}
In scripts, variables must be declared before use as above, but in interactive
mode, variables are declared automatically.

Return values may also be discarded. To save only the second
return value from the above function while discarding the first
and third, use this syntax:
\begin{verbatim}
        (,y,) = some_function();
\end{verbatim}
For functions which return only one value, the syntax is more familiar:
\begin{verbatim}
        x = returns_one_value();
\end{verbatim}
To explicitly discard the single return value, use
\begin{verbatim}
        () = returns_one_value();
\end{verbatim}

In interactive mode, it rarely matters to the user that \slang\ is a stack-based
language.  This is primarily because handling of function return values is
simplified in interactive mode: the stack is automatically emptied after
each function executes and any return values not explicitly handled are
simply popped off the stack and printed on the screen.
For example:
\begin{verbatim}
      isis> x = [47, 12, 13, 92, 46, 12];         % define an array
      isis> y = max(x);                           % now y = 92
      isis> max(x);               % When the return value isn't "caught",
      92                          % it is popped off the stack automatically.
\end{verbatim}
This is true {\it only} in interactive mode, however.

When writing scripts, one must be more careful to explicitly handle all
function return values.  When a function is invoked without explicitly
handling all of its return values in some way, the remaining return values
are placed on the stack.  The next function call which pops arguments off
the stack will get those values as input. This feature can be exploited to
improve the efficiency of \slang\ scripts, but can also lead to unexpected
results if incorrect arguments are unintentionally passed to a function
because the return value from a previous function call was not handled
correctly.  Using a somewhat pathological example, the operation of the
stack can be seen in interactive mode
\begin{verbatim}
     isis> [47, 12, 13, 92, 46, 12]; max();
     92
\end{verbatim}
In this example, an array is first pushed onto the stack, then the {\tt
max() } function pops an array argument off the stack, finds the largest
array element, and pushes that value back onto the stack.  Because this is an
interactive mode example, the value remaining on the stack is then
automatically printed on the screen.

Don't be concerned if this sounds a little complicated. As stated above, in
interactive mode, the presence of the stack is usually an unimportant
detail.  The main reason for mentioning it here is to provide a short
introduction to the language structure and suggest ways in which it can be
exploited.

For full details, see the \slang\ documentation at
\begin{verbatim}
    http://www.jedsoft.org/slang/
\end{verbatim}
or in the \slang\ source directory.

\chapter{Common ISIS Tasks}
\label{chap:common-tasks}

This section provides several examples to illustrate how to carry out common
analysis tasks using \isis.  These examples are intended to provide a
starting point and to give the user an idea of how \isisx can be used.  They
do not illustrate everything \isisx can do and do not provide a complete
description in any sense.  For full details on all \isisx functions, see the
\isisx Function Reference in chapter \ref{chap:funcref}.

The following examples use sample data files which are
available from the \isisx source code distribution (see the
\verb|isis/test/data| subdirectory).
\begin{enumerate}

\item a Type II pha file called \verb|acisf01318N003_pha2.fits|
which contains Chandra/HETG counts spectra for several plus and
minus diffraction orders of both HEG and MEG.

\item an Effective Area function (ARF) called
\verb|acisf01318_000N001MEG_-1_garf.fits|

\item a Redistribution Matrix function (RMF) called
\verb|acismeg1D1999-07-22rmfN0002.fits|

\item a spectral model definition file called {\tt model.dat} (see {\tt
load\_model} for a description of the format).

\item a \slang\ script ({\tt aped.sl}) describing the layout of the
spectroscopy database (see \S\ref{chap:specdb}).

\item the spectroscopy database itself.
\end{enumerate}

The \slang\ scripts used to generate the figures in this manual
are in the {\tt doc/scripts} directory. For instructions on
how to obtain and install the spectroscopy database, see \S
\ref{chap:specdb}

\section{Reading and displaying spectral data}

\isisx can read data in either FITS (Type II pha) or ASCII format.
To read a Type II pha file and display selected spectra (see Figures
\ref{fig:data_cts} and \ref{fig:data_flx}):

\verbatiminput{scripts/data.sl}

Data plots use a linear axis scale by default; to make a log plot, use {\tt
xlog} and/or {\tt ylog} -- {\tt xlin} and {\tt ylin} will restore the linear
axis scaling.

\begin{verbatim}
  () = open_plot("/xwin");
  xlog; ylog;
  plot_data_counts (sp);       % plot log-log
\end{verbatim}

To change the axis ranges, use the {\tt xrange} and {\tt
yrange} commands.  Continuing the example:

\begin{verbatim}
  erase;                       % clear the plot window
  xlin; ylin;                  % use a linear scale
  xrange (11,12);              % set X-range to 11-12 angstrom
  yrange;                      % take Y ranges from the data
  plot_data_counts (sp);       % plot data
\end{verbatim}

The plot coordinates can be changed (e.g. to plot vs energy in keV
instead of wavelength in \AA) using the {\tt plot\_unit} command.

\begin{verbatim}
   erase;                      % clear the plot window
   plot_unit ("kev");          % plot in energy units
   plot_data_counts (sp);      % plot data
\end{verbatim}

\begin{figure}[ht]
\putfig{figures/data_cts}
\caption{Example plot of observed counts per bin vs. wavelength}
\label{fig:data_cts}
\end{figure}

\begin{figure}[ht]
\putfig{figures/data_flx}
\caption{Example plot of a flux corrected spectrum}
\label{fig:data_flx}
\end{figure}

Although the current version of \isisx supports analysis of a flux-corrected
spectrum, it does not automatically compute the flux-corrected spectrum from
the counts histogram. The flux-corrected spectrum may be provided in the
input data file or may be computed within \isisx after loading the
appropriate effective area (ARF) file:
\begin{verbatim}
  % load one ARF, return value is arf=1
  arf = load_arf ("acisf01318_000N001MEG_-1_garf.fits.gz");

  assign_arf (arf, sp);          % assign the ARF to the current data set
  flux_corr (sp, 2);             % flux-correct, ignoring
                                 % bins with S/N < 2
\end{verbatim}
The flux-corrected result is stored separately and does not over-write
the counts histogram. Note that because the S/N threshold was set to a
non-zero value (the second argument to {\tt flux\_corr}), bins with
very few counts above 25 \AA~ are assigned a flux of zero in Figure
\ref{fig:data_flx};  see the
description of {\tt flux\_corr} in the reference section for more detail.

\section{Initializing the spectroscopy database}
\label{specdb-init}

To initialize the spectroscopy database, \isisx must first obtain
the location and contents of the database.  The person who
installs \isisx should provide a S-Lang script (perhaps by editing
one of the included example files) which describes the local
version of the spectroscopy database.  After installation, it is
not necessary for casual users to access this database
configuration script directly.

See the {\tt etc/local.sl} file in the \isisx source distribution for
an example of how the necessary information can be provided by a
configuration script which is automatically loaded when an
associated initialization function is referenced.  For example, to
load the spectroscopy database described by configuration script
{\tt etc/aped.sl}, calling the {\tt aped} function as an argument to
{\tt plasma}:
 \begin{verbatim}
  plasma (aped);
 \end{verbatim}
causes the associated configuration script ({\tt aped.sl}) to load
and execute automatically, providing paths to
the atomic data and the emissivity tables (if available).
The {\tt plasma} function then loads these database tables into
\isis.
Similarly, one can load the atomic data tables only using the
{\tt atoms} function:
\begin{verbatim}
  atoms (aped);
 \end{verbatim}
If the atomic data tables are loaded first, loading the emissivity
tables will not unload them -- any ``new'' emission lines
encountered in the emissivity tables (ie not already listed in the
wavelength tables) will be merged into the internal wavelength
list.

By default, when \isisx loads the database, it reads all the specified files
into memory, including tables of emission line wavelengths, atomic energy
levels, ionization balance and line emissivities.  With a large
spectroscopy database (or a computer with a relatively small memory) this
behavior might tax the system memory resources. To encourage \isisx to use
less memory, the user can specify that it access large files by reading the
necessary pieces from disk as needed rather than reading the entire file
into memory at startup (see \verb|Use_Memory|).  Because of its large size,
the continuum emissivity file is never loaded entirely; instead, the
structure of this file is ``mapped'' so that run-time access for specific
items in the file is as efficient as possible.

Important technical note: Although \cfitsio\ is capable of reading
gzip-compressed FITS files transparently, the \cfitsio\ implementation first
uncompresses the {\it entire} FITS file into memory before the read operation
begins. This presents a severe problem if the {\it uncompressed} FITS file is
larger than the computer memory(!) To avoid problems of this nature, it is
best to uncompress the individual database files before reading them into
\isis. Reading uncompressed files has the added benefit that the files can
be read in more quickly and run-time memory usage is minimized.

Note that even if the atomic database (wavelength tables, energy levels,
etc.) is unavailable, the line and continuum emissivity tables may still be
used to generate spectrum models.  In this case, the \isisx functionality
which requires the atomic data tables will be unavailable.

\section{Identifying emission lines using a spectral model}

Emission line identification is simplified by the ability to plot the
locations of lines expected from a particular ion or lines which are
expected to be bright at a given temperature.  This process may be
complicated by the fact that some database wavelengths may be incorrect --
an important contribution of high-resolution observations will be in
providing improved measurements of many line wavelengths.  \isisx provides a
mechanism to incorporate improved wavelength measurements without changing
the database files directly (see {\tt change\_wl}).

The process of line identification might start by identifying the brightest
lines in the spectrum (since they are likely to have reasonably well
measured wavelength values).  One approach is to compute a model
spectrum and try to match the brightest model lines to those that have
been observed.  To do this, load a data set and then compute a model
spectrum on the same grid using the spectroscopy database:

 \begin{verbatim}
   % reset global program state (unloads all data sets, etc.)
   reset;

   % load the entire type II pha file
   load_data ("acisf01318N003_pha2.fits");

   plot_data_counts (9);              % plot counts spectrum

   plasma (aped);
   load_model ("model.dat");          % or use edit_model
   use_thermal_profile;               % thermal + turbulence
   d = get_data_counts(9);            % use the data grid (Angstroms)

   flux = model_spectrum (d.bin_lo, d.bin_hi);
 \end{verbatim}

Now, select the brightest 10
lines in a particular wavelength range in the model spectrum and
over-plot those lines on the observed spectrum (e.g. Figure
\ref{fig:line_id}):

\begin{figure}[ht]
\putfig{figures/line_id}
\caption{Example of emission line labeling}
\label{fig:line_id}
\end{figure}

\begin{verbatim}
 g = brightest(10, where (wl(10,12)));    % get indices of bright lines
                                          % between 10-12 Angstrom

 plot_group(g);                     % overlay lines on an existing plot
 page_group(g);                     % browse the data on those lines.
 save_group (g, "bright_10.out");   % save the list in a file
\end{verbatim}
In this case, note that the brightest lines in the model don't accurately
predict all of the brightest lines in this region of the spectrum.

For a more direct comparison, the model intensities should be compared to
the flux-corrected spectrum so that the variation of effective area with
wavelength is removed from the observed spectrum (see {\tt flux\_corr}).
This is especially important when identifying fainter lines as is the effect
of contamination from higher-order features. Locations of features in other
diffraction orders can be plotted using {\tt lambda\_mth\_order}.

Even if collisional ionization equilibrium is not an appropriate model for
the data, one may still make use of the wavelength tables in the
spectroscopy database.  For example, to plot the locations of all the Fe XVI
and XVII lines between 10-10.5 \AA:
 \begin{verbatim}
 fe_lines = where (wl(10,10.5) and el_ion(26,[16,17]));
 plot_group (fe_lines);

   OR

 plot_group(where (wl(10,10.5) and el_ion(26,[16,17])));
 \end{verbatim}
Note that the output of the {\tt where} command can be used directly without
first being stored in a \slang\ variable.

By defining symbols like {\tt Fe = 26} in the {\tt .isisrc} file, one can
avoid having to remember the proton numbers of the various elements (a
sample {\tt .isisrc} file is included in the \isisx distribution):
 \begin{verbatim}
  fe_lines = where (wl(10,10.5) and el_ion (Fe,[16,17]));
 \end{verbatim}

\begin{figure}[ht]
\putfig{figures/elev}
\caption{Example energy level diagram with over-plotted line transitions}
\label{fig:elev}
\end{figure}

Having identified lines of interest, one might want to look at an energy
level diagram to better understand how those lines are formed. Naturally,
this requires that the spectroscopy database contain energy level
information. If LS coupling energy level data are available, a simple energy
level diagram can be generated (e.g. Figure \ref{fig:elev}), over-plotting
lines transitions listed in a \slang\ array
 \begin{verbatim}
 plot_elev (Fe, 16);                 % Fe XVI
 oplot_lines (Fe, 16, g);            % using an array g as defined above
 list_elev (Fe, 16);                 % list the energy level table
 \end{verbatim}
When transition probabilities are available, the energy level listing also
includes the total downward spontaneous radiative transition rate for each
level, simplifying identification of meta-stable states.

\section{Measuring line intensities}

Observed line intensities may be measured using several different
techniques with varying accuracy and sophistication.

The simplest measurement is a sum over the bins which make up a particular
feature; because this approach neglects the effect of the line response
function it probably should not be used to measure the intensities of
individual lines in a blend.

To examine different methods of making line measurements, first load
a data set and plot a spectrum, perhaps zooming in to a region of interest.

 \begin{verbatim}
   % load spectrum number 9
   % variable sp = 1 if this is the only data currently loaded
   sp = load_data ("acisf01318N003_pha2.fits", 9);

   xrange(10,11);
   yrange;
   plot_data_counts (sp);            % plot counts spectrum
 \end{verbatim}

  \begin{enumerate}
  \item Summing bin values:

     \begin{verbatim}
     p = region_counts (sp, 10.2, 10.4);
     print(p);                       % get struct field names
     p.sum;                          % isis will echo the value
     \end{verbatim}
     OR
     \begin{verbatim}
     (xmin, xmax) = xinterval;       % mark the interval using the
                                     % plot cursor
     p = region_counts (sp, xmin, xmax);
     \end{verbatim}
     OR
     \begin{verbatim}
     cursor_counts (sp);               % another cursor-based option
     \end{verbatim}

Notice that the region of interest is defined by specifying a {\it
wavelength} range in Angstrom (\AA) regardless of the units in the input
data. Also, notice that the {\tt region\_counts} function returns a \slang\
{\it structure} rather than a simple scalar or array value.  The fields of
this structure are accessible using the dot notation which will be familiar
to C and IDL programmers.

  \item Fitting line profile functions:

When measuring the intensities of blended lines, one may account for the
effect of the line response function by fitting the line blend with a sum of
suitably chosen line profile functions plus a continuum function.

In interactive mode it may be most convenient to obtain initial estimates of
the fit parameters by marking data regions with the plot cursor. To do that,
start by plotting the data in appropriate bin-density units (e.g. counts/\AA~
rather than counts/bin):

     \begin{verbatim}
     open_plot;
     plot_bin_density;      % required for using ifit_fun() below
     plot_data_flux (sp);   % assumes flux_corr() has been run
     \end{verbatim}

Now, narrow the plot range and {\tt notice} the
bins to be fit:

     \begin{verbatim}
     xrange(15.9,16.1); yrange;
     errorbars (1);               % turn on error-bars

     plot_data_flux (sp);

     xnotice(sp,15.9,16.1);
     \end{verbatim}

As above, the bin-coordinates are always specified in Angstrom (\AA)
units, regardless of the physical units in the input data file.

One can initialize the fit parameters by clicking the mouse cursor on the
screen plot -- to do that, define the fit function using {\tt ifit\_fun};
here the ``i'' is for ``interactive'':

\begin{figure}[ht]
\putfig{figures/profile_fit}
\caption{Example of fitting a line-blend with over-plotted error-bars.}
\label{fig:profile_fit}
\end{figure}

\begin{verbatim}
     ifit_fun("Lorentz(1) + Lorentz(2) + poly(1)");
     \end{verbatim}

The indices in the fit function components are used to label multiple
occurrences of a particular component type.  Here, we have two Lorentzian
components labeled as number 1 ({\tt Lorentz(1)}) and number 2 {\tt
Lorentz(2)}.  After interactively assigning fit parameters, check the
quality of the initial values, then do the fit and over-plot the result:

     \begin{verbatim}
     renorm_flux;                       % automatically adjust normalization
     oplot_convolved_model_flux (sp);   % plot to check the initial params
     fit_flux;
     oplot_convolved_model_flux (sp);
     \end{verbatim}

It is important to remember that when fitting, all noticed bins in {\it all
currently loaded spectra} are fit simultaneously. To fit a few line profiles
to a small region of a single loaded spectrum, it is essential to first
ignore all other spectra and all bins outside the region of interest
\begin{verbatim}
                                 % If 12 spectra are loaded, and you want
                                 % to fit only spectrum #9:
   ignore([[1:8], [10:12]]);     % or ignore([1:8]); ignore([10:12]);
   xnotice (9, 15.9, 16.1);
\end{verbatim}

The unbinned fit function, if available for the
chosen model, may also be over-plotted as in Figure \ref{fig:profile_fit}:

     \begin{verbatim}
     x = [15.95:16.1:7.5e-4];           % generate some X coordinates
     y = get_cfun(x);                   % evaluate the function Y(X)
     oplot(x,y);
     \end{verbatim}

For further comparison, one may wish to plot the bin residuals or the ratio
between model and data.  The simplest way to do that is to use
the \verb|rplot_counts| function.  Alternatively,
one can exercise more control over the plot by
manipulating the data and model values directly.
For example:

     \begin{verbatim}
     d = get_data_flux (sp);
     m = get_convolved_model_flux (sp);

     limits;
     hplot (d.bin_lo, d.bin_hi, d.value - m.value);        % residuals

     % avoid division by zero
     i = where (m.value != 0)

     % plot the ratio
     limits;
     hplot (d.bin_lo[i], d.bin_hi[i], d.value[i]/m.value[i]);
     \end{verbatim}

Other common tasks are:

     \begin{verbatim}
     list_par;                       % list the fit parameters
     conf(2);                        % compute confidence limits
     save_par("lorentz2.fit");       % save the fit parameters
     value = get_par (idx);          % get a fit parameter value
     \end{verbatim}

If a better fit is encountered while computing confidence limits,
try re-fitting the data until a stable minimum is found.

\item Forward folding:

In principle, the most accurate approach to measuring line intensities
requires explicitly accounting for the effect of the line response
function and for variations in the total effective area across the
line blend. The sequence of commands is identical to that required to
fit line profiles, except that additional information on the line
response function (the RMF) and the total effective area (the ARF) is
required.  In addition to loading the spectral data, one must provide
the necessary RMF and ARF files and indicate which response goes with
which spectrum (see {\tt load\_rmf}, {\tt assign\_rmf}, {\tt
load\_arf} and {\tt assign\_arf}).  A detailed example is given in
\S\ref{subsec:simpleexample}.

By default, whenever response functions (ARF/RMF) are assigned to a
spectrum, they are applied when fitting a model to that data set (e.g.
forward-folding is the default).  Alternatively, the {\tt fit\_*} and
{\tt renorm\_*} functions accept flags which may be used to apply an
ideal ARF and/or RMF even when a realistic instrument response has
been assigned.  This mechanism provides an easy way to isolate the
effect of the instrument response.

\end{enumerate}

\section{Automatically finding, identifying and fitting emission lines}

Although \isisx does not currently have intrinsic functions for
automatic spectrum processing of this sort, it is possible to do this
kind of automatic processing with a script.  The advantage of this
approach is that users can modify the script without having to
recompile the code, thereby customizing the automatic processing for
particular cases. An extended example is given in the
examples tar file available from the \isisx web page;
see the files
\begin{verbatim}
     scan/scan.sl
     scan/scan-demo1.sl
     scan/scan-demo2.sl
\end{verbatim}
The first of these files contains some useful and fairly generic \slang\ functions
whose usage is demonstrated in the other two files.

Here is a simple example of how one might use the function {\tt find\_lines}
(defined in {\tt scan/scan.sl}) to quickly find and plot
the brightest lines in a spectrum. First, copy the contents of the
examples directory a working directory, then run \isis:
\begin{verbatim}

   % load and plot an example spectrum
   isis> load_data("obsid_1103_Sky_MEGm1_isis.dat");
   isis> plot_data_counts (1);

   % load the scan functions
   isis> .load scan.sl

   % read the Usage message
   isis> find_lines;

   % find strong lines in spectrum 1
   isis> (flam, fbin) = find_lines (1, 10);

   % how many lines were found?
   isis> n = length (flam);

   % label plot using data values
   isis> d = get_data_counts(1);
   isis> for (i=0; i < n; i++) {
             xylabel(flam[i], d.value[fbin[i]], string(i));
         }
\end{verbatim}
Although the last line is rather long, there's no need to type it
every time.  Instead, one could use it to define a \slang\
function which could then be customized to suit a specific application.

\section{Comparing line measurements with theory}

Measurements of line intensity ratios are often used to infer physical
conditions in the emitting plasma.  For example, the intensity ratio of
bright lines from different ions of the same element may be used to infer
the relative populations of the different ions, providing a measure of the
ionization balance.  Similarly, pairs of lines which arise from the same
upper energy level in a single ion may be used to infer the optical depth;
if one of the lines is optically thick, the branching ratio should differ
from the value expected using the spontaneous transition rates (Einstein A
values) alone.  Radiative transitions involving meta-stable states often
provide useful density diagnostics; such states may be identified using
the energy level listing (see {\tt list\_elev}) which includes the total
downward spontaneous radiative transition rate for each level.

Bright, relatively unblended lines may be selected using the line grouping
functions discussed above (e.g. {\tt brightest}, {\tt unblended}).  Lines
which have the same upper energy level may be identified
using the function {\tt list\_branch}; for example,
\begin{verbatim}
   atoms(aped);              % First load the atomic data
   list_branch (Fe, 18);     % Fe = 26
\end{verbatim}
lists branching ratios for Fe XVIII:
\begin{verbatim}
Fe XVIII
upper level =    3
lower         lambda       branch       A        index
    2   1.039370e+02   2.6669e-01   3.3400e+10   14751
    1   9.392300e+01   7.3331e-01   9.1840e+10   14752
 ....
\end{verbatim}
This listing indicates that, of downward transitions from the third
excited state of Fe XVIII (see the corresponding energy level table),
73\% produce a line at 93.923 \AA~ and 27\% produce a line at 103.937 \AA.

\begin{figure}[ht]
\putfig{figures/crude_dem}
\caption{Example of estimating the emission measure implied by the flux in a
single line.}
\label{fig:crude_dem}
\end{figure}

Having identified line ratios which may be of interest, one can plot the
predicted ratio of two lines with indices {\tt n1} and {\tt n2} vs
temperature:

 \begin{verbatim}
 plasma(aped);                 % first load the emissivity tables
 t = 10.0^[6.0:7.4:0.05];           % define a log spaced temperature grid
 r = ratio_em (n1, n2, t);          % compute the ratio
 plot(t,r);                         % plot the ratio vs. temperature
 \end{verbatim}

For a given {\it measured} line ratio, one could read off an estimate of the
plasma temperature.  A thorough analysis of a spectrum would normally use
several, or even all, of the observed features to infer a distribution of
physical conditions; for obvious reasons, relying on a single line ratio is
not recommended.

Alternatively, because the ratio of the measured flux ($F_\lambda$) to the
computed emissivity ($\eta_\lambda(T)$) may be expressed as
\begin{equation}
{ F_\lambda \over \eta_\lambda(T) } = \kappa(T) { \int n_e
n_H~\D V \over 4\pi D^2 }.
\end{equation}
one can generate a crude estimate of the differential emission measure near a
given temperature using the measured flux ({\tt flux\_obs}) in a single line
({\tt "k"}). To plot the measured flux divided by the theoretical emissivity
vs. temperature (Figure \ref{fig:crude_dem}):
  \begin{verbatim}
  t = 10.0^[6.0:7.9:0.01];             % define a Temperature grid
  em = line_em (k,t);                  % get emissivity vs. temperature for
                                       % line k
  i = where(em > 0.0);
  plot (t[i], flux_obs / em[i]);      % plot the ratio
  \end{verbatim}
From this curve, one can read off values proportional to the emission
measure at a given temperature.

In general, the emitting plasma will occupy a range of temperatures.
To infer the temperature {\it distribution}, more sophisticated
analysis techniques may be required (e.g. differential emission
measure analysis). Although such algorithms are not currently
implemented in \isis, many of the required building blocks are
provided.

\section{Computing a spectral model using the XSPEC module}

On systems which have \xspec\ (Arnaud 1996) installed, the \xspec\
module provides convenient access to selected functions in the
\xspec\ function library.  On ELF systems, this module may be
accessible by dynamic linking at \isisx run-time using the \slang\
\verb|import| function. On such systems, one can explicitly
\verb|import| the module, or it will be automatically imported
when any of the \xspec\ functions is used for the first time.
Alternatively, the \xspec\ module may be also be statically linked
to the \isisx executable so that calling \verb|import| is not
required at all.

Using this module, most \xspec\ library routines are available
as fit-functions.  Selected \xspec\ routines are also available
as S-Lang functions which take the spectrum grid and other
parameters directly as function arguments. Here is an example
showing one way to compute and plot an \xspec\ model spectrum
(Figure \ref{fig:xspec}):

\verbatiminput{scripts/xspec.sl}

\begin{figure}[ht]
\putfig{figures/xspec}
\caption{Example XSPEC model plot, illustrating the effect of an $N_H = 1.0 \times
10^{20}$ cm${}^{-2}$ absorbing column on a 5.0 keV "solar" abundance MEKAL
plasma model.}
\label{fig:xspec}
\end{figure}

Some array-index manipulation was required in this example because the
\isisx convention for representing histograms differs from the
\xspec\ convention. If plotting the model flux vs. the low-edge of each bin would
have been good enough, typing
 \begin{verbatim}
   require ("xspec");                     % (this is optional)
   e = 10.0^[-1:1:0.005];                 % make a log spaced energy grid
   s = _mekal (5.0, e);                   % 5 keV, solar abundance
   plot (e[[0:n-1]], s);
 \end{verbatim}
would have produced a similar plot without introducing the
additional variables {\tt lo} and {\tt hi}.

\section{Global fitting}

In this section, the term {\it global fit} refers to fitting the
entire range of input data with a plasma model which has a
relatively small number of variable parameters (e.g. a one or two
temperature CIE plasma model). Although global fits to
high-resolution spectra are unlikely to accurately reproduce the
wealth of observed features, a global fit may e.g. provide a quick
estimate of the dominant plasma temperature(s) which are present.
The current version of \isisx supports global fitting with {\sc
XSPEC} models (Arnaud 1996) (see \S\ref{chap:xspec-module}), with
the \isisx built-in fit-functions and with user-supplied fit
functions. Global fits using spectral models generated using the
spectroscopy database are supported via the \verb|create_aped_fun|
function which can create a custom fit-function with
fit-parameters defined by relatively simple data structure
(see \verb|create_aped_fun| for further details).

\index{background!options}
After loading the data and assigning the appropriate instrument
responses, a background component can be included from a file
(\verb|define_back|), from \slang\ variables (\verb|_define_back|)
or from a user-defined function (\verb|back_fun|).  Background
subtraction may also be done ``by hand'' using a user-defined
function such as this:
\verbatiminput{scripts/bgd_subtract.sl}
Fitting is then carried out using the same sequence of steps
described in \S\ref{subsec:simpleexample}.

\section{Examining ionization balance curves}

Much of the temperature dependence of emission lines in collisional
ionization equilibrium comes from the temperature dependence of the
ion concentration.

To examine ionization balance curves, first initialize the spectroscopy database
so that an ionization balance table is loaded
 \begin{verbatim}
  plasma (aped);
 \end{verbatim}
Then plot the ionization fraction of Fe XVII vs. temperature (Figure
\ref{fig:ion_frac}):

\begin{figure}[ht]
\putfig{figures/ion_frac}
\caption{Example plot of Fe XVII ion fraction vs. temperature.}
\label{fig:ion_frac}
\end{figure}

\begin{verbatim}
   t = 10.0^[6.0:7.2:0.05];          % define a log spaced temperature grid (K)
   limits;                           % reset the plot limits
   frac = ion_frac(Fe, 17, t);       % assuming Fe = 26 defined in ~/.isisrc
   plot (t,frac);

   label ("Temperature [K]", "Ion Fraction", "");     % label axes
\end{verbatim}

The {\tt plot()} function used in this example allows plotting any set of
X-Y points held in \slang\ arrays; a similar function {\tt hplot()} is
provided for plotting arbitrary histograms.  As a trivial example of the
usefulness of this feature, the above plot could be regenerated vs.
temperature in keV by typing
\begin{verbatim}
   limits;
   K_per_keV = 1.16e7;                    % conversion factor
   plot ( t / K_per_keV, frac);
\end{verbatim}
to apply the conversion factor to the temperature array before plotting.

In these example, the array of ion fractions returned by {\tt ion\_frac} is
first stored in a variable before being passed to the plot function;  this
is especially useful if the array values will be used in further calculations.
The intermediate variable is not necessary however:
\begin{verbatim}
    plot (t, ion_frac(Fe, 17, t));
\end{verbatim}
produces the same result -- here, the array returned by {\tt ion\_frac} is
passed directly to the {\tt plot} function.

To compare the relative concentrations of ions of different elements
as a function of temperature (Figure \ref{fig:ion_bal}):

\begin{verbatim}
   (i_fe, f_fe) = ion_bal (Fe, 1.e7);         % Fe at T = 1.e7 K
   (i_ca, f_ca) = ion_bal (Ca, 1.e7);         % Ca at T = 1.e7 K
   limits;                                    % reset the plot limits
   hplot (i_ca-0.5, i_ca+0.5, f_ca);          % plot as histograms
   ohplot (i_fe-0.5, i_fe+0.5, f_fe);         % over-plot Fe on Ca
   xrange(14,26);                             % pick a better plot range
   hplot (i_ca-0.5, i_ca+0.5, f_ca);          % re-plot
   ohplot (i_fe-0.5, i_fe+0.5, f_fe);         %
\end{verbatim}

\begin{figure}[ht]
\putfig{figures/ion_bal}
\caption{Example plot comparing Fe and Ca ionization balance at $T = 10^7$ K.}
\label{fig:ion_bal}
\end{figure}

If the current plot device supports it, over-plots are automatically done
in a different color to help simplify complex plots; this feature can be
disabled using {\tt plot\_auto\_color ()}.

\section{Examining continuum emission components using the spectroscopy
database}

First, initialize the spectroscopy database to scan the continuum
emissivity tables:
 \begin{verbatim}
  reset;              % reset the global state
  plasma (aped);
 \end{verbatim}
then, generate a wavelength grid and retrieve the continuum components
for a particular temperature
\begin{verbatim}
   (lo, hi) = linear_grid(1, 20, 3000);
    p = get_contin (lo, hi, 3.e6);        % use T = 3.e6 K

    who;                                  % how many variables are defined?
    print (p);                            % print struct components
\end{verbatim}
{\tt true} is the sum of true continuum components including
continua due to bremsstrahlung, radiative recombination, and
two-photon emission and {\tt pseudo} is the pseudo-continuum of weak
emission lines.

Now, plot the components for comparison
\begin{verbatim}
ymax = max ([p.true, p.pseudo]);           % set the plot range
yrange (ymax*1.e-4, ymax);                 % so all components fit
ylog;

hplot (lo, hi, p.true);
label ("Wavelength [Angstrom]",
       "log Flux [photon cm\\u3\\d s\\u-1\\d]",
       "T = 3.0e6 K");
ohplot (lo, hi, p.pseudo);

q = get_contin (lo, hi, 3.e6, 1.0e-3, O);        % Contribution from Oxygen
ohplot (lo, hi, q.true);
ohplot (lo, hi, q.pseudo);
\end{verbatim}

The fields of struct {\tt p} can be used in further calculations. For
example, one can integrate the various emission components over the
wavelength range of interest to determine the various continuum
contributions:
\begin{verbatim}
isis> e_erg = 1.988e-8/(0.5*(lo+hi));         % photon energy at bin center
isis> tot_true = sum(e_erg * p.true);         % sum over bins
isis> tot_true;                               % print the value
\end{verbatim}

\begin{figure}[ht]
\putfig{figures/contin}
\caption{Example of plotting continuum emission components for a solar abundance plasma at $T = 3 \times 10^6$ K.}
\label{fig:contin}
\end{figure}

\section{Modeling Event Pileup in CCD Detectors}
\label{sec:pileup}

For a detailed discussion of the pileup model see Davis (2001),
available on the web from
\begin{verbatim}
 http://space.mit.edu/~davis/pileup2001.html
\end{verbatim}
See \S\ref{pileup-help} for a suggestion on how to speed up
the pileup model computations.
This section provides a brief example showing how to use the
model to fit CCD data.

For an on-axis point source, extract counts in a circular region
with a radius of about four pixels; this will enclose
about 95\% of the encircled energy.  A larger extraction
region will enclose more source counts but will also increase
the background level.

Then,  in \isisx issue the appropriate commands to load the data, e.g.,
\begin{verbatim}
   () = load_data ("data.fits");
   () = load_arf ("arf.fits");
   assign_arf (1,1);
   () = load_rmf ("rmf.fits");
   assign_rmf (1, 1);
\end{verbatim}
Equivalently, one could use:
\begin{verbatim}
  load_dataset ("data.fits", "rmf.fits", "arf.fits");
\end{verbatim}

Now group the data bins, e.g. use
\begin{verbatim}
   group_data (1, 12);
\end{verbatim}
to group every 12 pha channels together.

Then specify a model, e.g.,
\begin{verbatim}
   require ("xspec");               % this is optional
   fit_fun ("wabs(1)*powerlaw(1)");
\end{verbatim}

Now indicate that you want to fit this data set using pileup:
\begin{verbatim}
   set_kernel (1, "pileup");
\end{verbatim}

Finally, edit the parameters:
\begin{verbatim}
   edit_par;
   list_par;
\end{verbatim}

This will produce something like:
\begin{verbatim}
wabs(1)*Powerlaw(1)
 idx  param         tie-to  freeze    value      min    max
  1  wabs(1).NH_22       0     0       0.01      1e-5   0.1
  2  Powerlaw(1).norm    0     0      0.003      1e-5   0.01
  3  Powerlaw(1).alpha   0     0          1         0   0
  4  pileup.<1>nregions  0     1          1         1   1.5
  5  pileup.<1>g0        0     1          1         0   1
  6  pileup.<1>alpha     0     0        0.5         0   0.75
  7  pileup.<1>psffrac   0     1       0.95       0.9   1
\end{verbatim}

The \verb|pileup<1>| parameters are specific to the pileup model and the
number in angle-brackets (\verb|"<>"|) is the data-set index, e.g. here
indicating that the pileup model is being applied to data set 1.
For an on-axis point source, allow only \verb|alpha| to vary, leaving
\verb|psffrac| fixed at 0.95.  This indicates that 95 percent
of the encircled energy in the extraction region fell within the
central 3x3 pixel.

Finally, run the fit:
\begin{verbatim}
   () = fit_counts;
\end{verbatim}

Because the chi-square space is quite complicated, it is advisable
to repeat the fit several times, starting from random parameter
values.  To simplify this process, \isisx provides a {\tt
randomize} function to automatically randomize all free
fit-function parameters within the currently specified {\tt
min-max} parameter ranges. It may also be helpful to fit first
using {\tt subplex} to locate the neighborhood of the global
minimum and then use {\tt mpfit} to refine the answer.  For
example:

\begin{verbatim}
   set_fit_method ("subplex");
   loop (3)
     {
        () = fit_counts;
     }
   set_fit_method ("mpfitx");
   () = fit_counts;
\end{verbatim}

\part{ISIS Reference Manual \label{part:refman}}

\chapter{The Spectroscopy Database}
\label{chap:specdb}

This section discusses the database content, layout and parameter file
definition in some detail and may be of interest primarily to the person
installing \isisx and maintaining the local spectroscopy database.

\section{Obtaining Spectroscopy Database Files}

\isisx should be able to read files from the spectroscopy database assembled
by Smith, Brickhouse, Liedahl \& Raymond (2001).  These files may be
downloaded from the web at
\begin{verbatim}
    http://cxc.harvard.edu/atomdb/
\end{verbatim}
The minimum \isisx configuration requires only the line emissivity tables
available from from this web page (see \S \ref{subsec:min-specdb}).

\section{Organization}

The structure of the local database is specified to \isisx by
providing directory paths and file names via a S-Lang structure.
Perhaps the most convenient way to specify this structure is by
creating and initializing it using a short S-Lang script; for
example, the following script is included in the \isisx
distribution as \verb|etc/aped.sl|:
\begin{verbatim}
public define aped ()
{
   variable db = struct
     {
        dir, atomic_data_filemap,
           abundance, ion_balance,
           line_emissivity, continuum_emissivity
     };

   db.dir = "/nfs/atum/d2/houck/isis/data/aped/atomdb";
   db.atomic_data_filemap = "filemap";

   db.abundance = "APED/misc/Abundances.fits";
   db.ion_balance = "APED/ionbal/MM98_ionbal.fits";

   db.line_emissivity = "apec_line.fits";
   db.continuum_emissivity = "apec_coco.fits";

   return db;
}
\end{verbatim}
This script generates an instance of the necessary \slang {\tt
Struct\_Type} containing the path to the spectroscopy database and
the names of files containing the line and continuum emissivities
({\tt apec\_line.fits} and {\tt apec\_coco.fits}), the
ionization balance tables ({\tt MM98\_ionbal.fits}), elemental
abundance tables ({\tt Abundances.fits}) and a filemap listing the
associated atomic-data files containing, among other things,
tables of energy levels and wavelengths of X-ray line transitions.

In general, such an initialization script is defined only once,
perhaps when \isisx or when a new database is
installed, and is not accessed by the casual user afterward.

Also, perhaps it is an obvious point, but please keep in mind that the
functionality of \isisx depends on the content of the spectroscopy database
provided by the user.  Importantly, this database is {\it not part of
\isisx}. If the database contains little or no information on the wavelength
range of interest, the problem is in the database and not in \isis.

In general, the spectroscopy database is logically divided into two
sections: 1) an emissivity database containing ionization balance tables and
tables of line and continuum emissivities as a function of plasma state
parameters (e.g. temperature and density and 2) a set of atomic data (energy
levels, emission line wavelengths and transition probabilities for selected
ions of astrophysically abundant elements -- quantities generally
independent of the plasma physical state).  This organization is mirrored in
the two commands used to load data from the database (see {\tt atoms}
(\S\ref{sec:atomic-db}) and {\tt plasma} (\S \ref{sec:plasma-db}) below).
The database files are in FITS format and are described in detail in the CXC
Spectroscopy Database ICD.

Although the atomic data tables are optional, when both data sets are used
together, it is assumed that the emissivity database has been derived from
the atomic database. Depending on the assumed emission model, different
emissivity databases may be derived from the same atomic data set.

The standard emissivity database assumes collisional ionization equilibrium
as a function of electron temperature $T$ and electron density $n$.
\isisx supports reading several types of files from a collisional ionization
equilibrium spectroscopy database:
\begin{itemize}
\item A line emissivity file containing the
  line spectrum for a solar abundance plasma as a function of temperature and
  density. Each extension contains the line spectrum at a single
temperature, density combination.
\item A continuum emissivity file containing continua for a solar abundance
  plasma as a function of temperature and density.
  Continua are available for individual elements, with true-continuum
  and pseudo-continuum (weak lines) stored separately;  optionally,
  continuum components broken down by ion may also be available.
\item A set of cosmic elemental abundance tables in a single FITS file.
\item An ionization balance file containing tables of ionization balance as a
      function of temperature.
\end{itemize}

\isisx also supports reading these files from the atomic database:
\begin{itemize}
\item Wavelength tables -- one per element -- with each extension containing
  a list of  wavelengths, A-values and energy-level indices for a single ion.
\item Energy level tables -- one per element -- with each extension
  containing a list of energy levels for a single ion.
\end{itemize}
The spectroscopy database may be configured in several different ways,
depending on which of these files are available.

Important technical note: Although \cfitsio\ is capable of reading
gzip-compressed FITS files transparently, the \cfitsio\ implementation first
uncompresses the {\it entire} FITS file into memory before {\it any} read
operation begins (even reading a single keyword from the header is enough).
This presents a severe problem if the {\it uncompressed} FITS file is larger
than the computer memory(!). To avoid problems of this nature, it is best to
uncompress the individual database files before reading them into
\isis. Reading uncompressed files has the added benefit that the files can
be read in more quickly and run-time memory usage is minimized.

\subsection{Minimal Configuration}
\label{subsec:min-specdb}

As mentioned above, the contents of the spectroscopy database must be specified
using a S-Lang structure of the form:
\begin{verbatim}
 variable db = struct { dir, atomic_data_filemap,
                        abundance, ion_balance,
                        line_emissivity, continuum_emissivity
                      };
\end{verbatim}
(the name of the structure is arbitrary -- for this example,
we have chosen to call it {\tt db})
The fields of this structure are strings which provide the
spectroscopy database directory and the names of selected files.
\begin{center}
\begin{tabular}{|l|p{2.4in}|}
\hline
dir & database directory \\
atomic\_data\_filemap & APEC-format atomic-data filemap \\
abundance & Table of elemental abundances \\
ion\_balance & Ionization balance table \\
line\_emissivity & Table of line emissivities \\
continuum\_emissivity & Table of continuum emissivities \\
\hline
\end{tabular}
\end{center}

Note that it is not necessary to have all of these files available
in order to use the spectroscopy database. The minimal database
configuration requires e.g. only a single line-emissivity table.
In this case, the required database configuration structure may be initialized by
defining only two of the struct fields:
\begin{verbatim}
     db.dir = "/data/apec";
     db.line_emissivity = "apec_line.fits";
\end{verbatim}
We point out that the database files can be placed in any convenient
directory -- for the purpose of this example, we assume the
database is in "/data/apec".

Once the database configuration structure is defined, the indicated
files are loaded using the functions {\tt plasma} and/or {\tt atoms}.
To load both the atomic data and emissivity tables, use
\begin{verbatim}
   plasma (db);
\end{verbatim}
where {\tt db} is the name of the database configuration structure.
Similarly, to load only the atomic-data files, use
\begin{verbatim}
   atoms (db);
\end{verbatim}

Note that the various database files need not all lie in the same
directory tree. If the files lie in different directories, one can
define the directory to be an empty string ({\tt dir = ""}) and
then use the other struct fields to specify the full path to each
file.

To simplify creating the database configuration structure and to
provide greater versatility, we recommend defining the structure
in a S-Lang function.  For example, the full APEC database might
be defined using a function like this:
\begin{verbatim}
public define aped ()
{
   variable db = struct
     {
        dir, atomic_data_filemap,
        abundance, ion_balance,
        line_emissivity, continuum_emissivity
     };

   db.dir = getenv("ATOMDB");
   if (db.dir == NULL) db.dir = "./";

   db.atomic_data_filemap = "filemap";

   db.abundance = "APED/misc/Abundances.fits";
   db.ion_balance = "APED/ionbal/MM98_ionbal.fits";

   db.line_emissivity = "apec_line.fits";
   db.continuum_emissivity = "apec_coco.fits";

   return db;
}
\end{verbatim}
Because this subroutine initializes and returns the necessary
structure, the subroutine itself can be used as the argument
of the {\tt plasma} or {\tt atoms} functions.  For example,
\begin{verbatim}
  plasma (aped);
\end{verbatim}
is exactly equivalent to
\begin{verbatim}
  db = aped();
  plasma (db);
\end{verbatim}

\chapter{Interactive Mode Features}
\label{chap:interactive}

\section{Command Line Editing}

If \isisx was compiled with GNU \verb|readline|, the command
line editing features are those provided by GNU
\verb|readline|; see the GNU \verb|readline| documentation for
details.  The editing features discussed below are those
provided by the native S-Lang interpreter.  To select the
command-line behavior, use \verb|set_readline_method|.

{\tt emacs}-style command line editing is supported.  The cursor
movement keys can be used to navigate the command history as can
the following the control sequences:

\begin{center}
\begin{tabular}{|l|p{4.5in}|}
\hline
ctrl-a  &  beginning of line \\
ctrl-e  &  end of line \\
ctrl-b  &  cursor left \\
ctrl-f  &  cursor right \\
ctrl-p  &  previous command \\
ctrl-n  &  next command \\
ctrl-d  &  delete the character under the cursor (also exits \isisx if it
          is the only character typed on the command line) \\
ctrl-h  &  delete the character to left of the cursor (or use the delete key) \\
ctrl-k  &  delete to end of line \\
\hline
\end{tabular}
\end{center}

Command line editing works well for browsing and editing the history
of single-line commands, but doesn't fully support editing
multi-line commands.

\section{Control Sequences}

Several control sequences are available for controlling \isisx
in interactive mode:

\begin{center}
\begin{tabular}{|l|p{4.5in}|}
\hline
ctrl-c  &  Halts execution of an \isisx command, returning to the \isisx prompt.
           Use {\tt quit} to exit from ISIS. \\
ctrl-z  &  Suspend \isisx and return the Unix system prompt. \\
ctrl-s  &  XON/XOFF flow control; suspends the terminal\\
ctrl-q  &  XON/XOFF flow control; un-suspend the terminal\\
\hline
\end{tabular}
\end{center}

\section{Unix Shell Escapes}

\index{"!|see{shell escapes}}
\index{shell escapes}
If the first character on the command line is an exclamation
point(!), the remainder
of the line is passed to the Unix Bourne shell {\tt /bin/sh}.  For example,
the following commands are equivalent:
\begin{verbatim}
    isis> !ls ..
    isis> ()=system("ls ..");
\end{verbatim}

Because the Unix Bourne shell parses the command string,
csh-like special characters are not understood:
\begin{verbatim}
    isis> !ls ~            % fails;  Bourne shell doesn't understand '~'
    isis> !ls src/*.fits   % works;  Bourne shell understands `*'
    isis> !ls $HOME        % works;  Bourne shell understands `$HOME'
\end{verbatim}
Unix shell aliases are also unavailable because shell configuration files
(e.g. \verb|~/.cshrc|) are {\it not} invoked.

The {\tt cd} (change directory) command is an exception. Because the
string argument of the {\tt cd} command is {\it not} interpreted by a Unix
shell, the specified directory path must be given explicitly without
making use of any environment variables or wildcard characters:
\begin{verbatim}
    isis> !cd ..           % works; '..' is a real directory
    isis> !cd $HOME        % fails; unless there is a directory named $HOME
\end{verbatim}

\section{Command Shortcuts}
\label{sec:shortcuts}

In interactive-mode, if the first character on the command line is a
period (.) the next non-blank characters are interpreted as a shortcut
command name and the rest of the line supplies whitespace-delimited
arguments for that command shortcut (if any).

\begin{isisfunction}
{.apropos}                             % function
{Shortcut for the apropos() function}  % synopsis
{.apropos string}                      % usage
{apropos}                              % see also

See the documentation for the S-Lang {\tt \_apropos} intrinsic function
for details; the only difference between the shortcut and the
intrinsic function is that intrinsic function provides namespace and
filter arguments which are not supported by the shortcut command.
In particular, both support S-Lang regular expressions.

\begin{verbatim}
For example:

isis> apropos data

Found 39 function matches in namespace Global:
__data_weights             __datatype                 __is_datatype_numeric
all_data                   combine_datasets           copy_data_keywords
delete_data                get_data                   get_data_backscale
get_data_counts            get_data_exposure          get_data_flux
get_data_info              get_dataset_metadata       get_rmf_data_grid
group_data                 have_data                  list_data
load_data                  load_dataset               match_dataset_grids
oplot_data                 oplot_data_counts          oplot_data_flux
plot_data                  plot_data_counts           plot_data_flux
put_data                   put_data_counts            put_data_flux
rebin_data                 rebin_dataset              set_data_backscale
set_data_color             set_data_exposure          set_data_info
set_dataset_metadata       uncombine_datasets         unset_data_color

Found 6 variable matches in namespace Global:
DataError                  DataType_Type              ENODATA
Isis_Active_Dataset        Isis_Data_Info_Type        _FITS_BAD_DATA_FILL
isis>
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{.cd}
{change \isisx working directory while in interactive-mode}
{.cd path}
{chdir}
This is the same as using the Unix shell-escape (see below) to
change directories:
\begin{verbatim}
    isis> !cd ..
\end{verbatim}
Because the argument is not evaluated by the Unix shell, wildcards
and environment variables may not be used.
\end{isisfunction}

\begin{isisfunction}
{.help}
{Shortcut for the help() function}
{.help topic}
{apropos, help}
See the documentation for the {\tt help} intrinsic function.
\end{isisfunction}

\begin{isisfunction}
{.load}
{run a \slang\ script in interactive-mode}
{.load filename}
{.source, evalfile}

This is an interactive-mode shortcut for the \slang\ intrinsic function {\tt
evalfile()} which interprets a file containing \slang\ code.  For example,
the following commands are almost equivalent:
\begin{verbatim}
    isis> .load script.sl
    isis> ()=evalfile("script.sl");
\end{verbatim}
The only difference is that {\tt evalfile()} returns an integer status code
to indicate whether or not the file was interpreted successfully (1 for
success, 0 for failure); the {\tt .load} command does not return a status
code and is only available in interactive-mode.

The ``{\tt .sl}'' extension on the script name is optional.

\end{isisfunction}

\begin{isisfunction}
{.source}
{read \slang\ commands from a file}
{.source filename}
{.load, evalfile}

This function is very similar to the {\tt .load} shortcut except that
lines from the file are interpreted as though they had been typed at the
command line -- all command shortcuts are available and variables need
not be declared before use.
\end{isisfunction}

\chapter{ISIS Function Reference}
\label{chap:funcref}

This chapter documents all parameters and functionality of all \isisx
intrinsic functions; related functions are grouped together in separate
sections. Valid functions may be \isisx intrinsics (e.g. {\tt load\_data})
or \slang\ intrinsics (e.g. {\tt message}).  Only \isisx intrinsic
functions are described here; see the \slang\ documentation for a
description of the available \slang\ functions.

Many \isisx functions take a variable number of arguments.  In the
following descriptions, optional arguments are enclosed in brackets
([]).  Similarly, the notation {\tt [o]plot} is intended to stand for
either {\tt plot} or {\tt oplot}.

The \isisx interactive help system supplies function name lookup ({\tt
apropos}) as well as more extensive documentation (({\tt help}). For
quick-reference, most \isisx functions display a usage message when invoked
with no arguments (\slang\ intrinsics do not).

%\begin{isisfunction}              % a template
%{} % name
%{} % synopsis
%{} % usage
%{} % see also
%\end{isisfunction}

\newpage
\section{Utility Functions}

A number of utility functions are provided for execution control ({\tt
quit}, {\tt reset}), customization ({\tt alias}), and help ({\tt apropos}, {\tt
help}).  Repetitive tasks may be simplified by first logging an
interactive session (see \verb|start_log|, \verb|stop_log|,
\verb|save_input|) and
then editing the log-file to produce one or more scripts to handle
subsequent repetitions.

\begin{isisfunction}
{\_A}
{Convert grids between \\Angstrom and keV}
{\_A (lo[, hi]) }
{}

This simple function can convert either one or two numerical
arguments from \\Angstrom wavelength units to keV energy units
or the  reverse.  For array input, the returned arrays have
the same numerical sort order as the input array, making it
convenient to convert an array of energies to an array of
wavelengths, each in increasing order.

\begin{verbatim}
  Example:

  isis> e_kev = [1,2,3];
  isis> print(_A(e_kev));
  4.132806e+00
  6.199209e+00
  1.239842e+01
  isis> lo_kev = [1,2,3];
  isis> hi_kev = [2,3,4];
  isis> (lo_angstrom, hi_angstrom) = _A(lo_kev, hi_kev);
  isis> print(lo_angstrom);
  3.099605e+00
  4.132806e+00
  6.199209e+00
  isis> print(hi_angstrom);
  4.132806e+00
  6.199209e+00
  1.239842e+01
\end{verbatim}

When the function argument is a \verb|Struct_Type| of the
form
\begin{verbatim}
  struct {bin_lo, bin_hi, value, err},
\end{verbatim}
the arrays \verb|bin_lo, bin_hi| are converted as above
and the \verb|value| and \verb|err| arrays are reversed.
This allows one to use the \verb|_A| function in conjunction
with the various routines that handle these structures.
For example:

\begin{verbatim}
  d = get_data_counts(1);
  hplot(_A(d));
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{\_featurep}
{Test whether or not a feature is present}
{Int\_Type \_featurep (String\_Type feature)}
{require, provide}

The \verb|_featurep| function returns a non-zero value if the
specified feature is present.  Otherwise, it returns 0 to indicate
that the feature has not been loaded.

\end{isisfunction}

\begin{isisfunction}
{add\_help\_file}
{Add a documentation file to the list searched by help}
{add\_help\_file (file)}
{help, apropos, add\_help\_hook}

When search for documentation on a given symbol, isis searches
a list of ascii-format files and can also call a number of
user-supplied functions which also search for help.

\verb|add_help_file| prepends a file to the list of
ascii-format documentation files which are searched to find
help on a specified topic.

\end{isisfunction}

\begin{isisfunction}
{add\_help\_hook}
{Add a function to display user-supplied help information}
{add\_help\_hook (name)}
{help, apropos, add\_help\_file}

When search for documentation on a given symbol, isis searches
a list of ascii-format files and can also call a number of
user-supplied functions which also search for help.

\verb|add_help_hook| adds to the list of functions which search
for help and display the search results.

\end{isisfunction}

\begin{isisfunction}
{add\_to\_isis\_load\_path}
{Add a directory to the file search path}
{add\_to\_isis\_load\_path ("dir")}
{get\_isis\_load\_path}

{\tt add\_to\_isis\_load\_path} prepends a directory to
the script-search path.

Related functions with fairly obvious definitions are:
\verb|set_isis_load_path|, \verb|prepend_to_isis_load_path|,
\verb|append_to_isis_load_path|.
\index{set\_isis\_load\_path@{\tt set\_isis\_load\_path}}
\index{prepend\_to\_isis\_load\_path@{\tt prepend\_to\_isis\_load\_path}}
\index{append\_to\_isis\_load\_path@{\tt append\_to\_isis\_load\_path}}

\end{isisfunction}

\begin{isisfunction}
{add\_to\_isis\_module\_path}
{Add a directory to the module search path}
{add\_to\_isis\_module\_path ("dir")}
{get\_isis\_module\_path}

{\tt add\_to\_isis\_module\_path} prepends a directory to
the path searched for dynamically linked libraries (.so
files) containing, e.g. compiled modules or user-defined
fit-functions.

For example, if a user-defined function is contained in a
dynamically linked library at
\verb|/home/joe/modules/libmodel.so|, one could add the directory
\verb|/home/joe/modules/| to the module search path using
\begin{verbatim}
   add_to_isis_module_path ("/home/joe/modules");
\end{verbatim}

Related functions with fairly obvious definitions are:
\verb|set_isis_module_path|, \verb|prepend_to_isis_module_path|,
\verb|append_to_isis_module_path|.
\index{set\_isis\_module\_path@{\tt set\_isis\_module\_path}}
\index{prepend\_to\_isis\_module\_path@{\tt prepend\_to\_isis\_module\_path}}
\index{append\_to\_isis\_module\_path@{\tt append\_to\_isis\_module\_path}}

\end{isisfunction}

\begin{isisfunction}
{alias}
{define an alternate name for an intrinsic function}
{alias ("oldname","newname")}
{who}

After defining an alias for an intrinsic function, the function can be
accessed using either the new name or the original name.
\end{isisfunction}

\begin{isisfunction}
{apropos} %name
{recall object names satisfying a regular expression} %purpose
{apropos("s")}
{.apropos, help, who}

The apropos function may be used to get a list of all defined objects whose
name matches the regular expression {\tt "s"}.
\begin{verbatim}
For example:

isis> apropos load

Found 23 function matches in namespace Global:
add_to_isis_load_path      append_to_isis_load_path   autoload
get_isis_load_path         get_slang_load_path        load_alt_ioniz
load_arf                   load_conf                  load_data
load_dataset               load_fit_method            load_fit_statistic
load_kernel                load_line_profile_function load_model
load_par                   load_rmf                   mt_load_model
prepend_to_isis_load_path  prepend_to_slang_load_path rline_load_history
set_isis_load_path         set_slang_load_path
isis>
\end{verbatim}
Because all strings generate a match with the empty string ({\tt ""}), this
can be used to obtain a list of almost all available \isisx intrinsic
functions and variables.
\end{isisfunction}

\begin{isisfunction}
{array\_struct\_field} %name
{Make an array from one field of an array of Struct\_Type} %purpose
{a[] = array\_struct\_field (Struct\_Type[], "field\_name")} %usage
{print}

For example:
\begin{verbatim}
   isis> d=load_data ("pha2.fits");
   Reading: ............
   isis> info = get_data_info(d);
   isis> part = array_struct_field(info, "part");
   isis> part;
   Integer_Type[12]
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{delete} %name
{un-initialize a variable} %purpose
{delete (["pattern"])} %usage
{who}

All variables whose names contain {\tt "pattern"} are un-initialized; if if
{\tt "pattern"} is absent, all currently defined variables are
un-initialized.
\begin{verbatim}
For example:

     isis> x=[1,2,3,4];        % define 3 variables
     isis> y=&x;
     isis> z=x*3.0;
     isis> who;                % verify they exist
     x: Integer_Type[4]
     y: &x
     z: Double_Type[4]
     isis> delete;             % delete all 3
     isis> who;
     x: *** Not Initialized ***
     y: *** Not Initialized ***
     z: *** Not Initialized ***
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{atexit} %name
{Register a function to be called when ISIS exits} %purpose
{atexit (\&fcn)} %usage
{ }

Use this function to indicate that a particular function should
be called when ISIS exits.  The function will be called with
no arguments and should return nothing.

If several such functions are specified, the functions will be
called in reverse order. If a slang error occurs when one of
the functions is called and if that error is not cleared, the
remaining functions registered with \verb|atexit| will not be
called.

For example:
\begin{verbatim}
isis> define cleanup1 () {message ("called cleanup1");}
isis> define cleanup2 () {message ("called cleanup2");}
isis> atexit (&cleanup1);
isis> atexit (&cleanup2);
isis> exit;
called cleanup2
called cleanup1
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{chdir} %name
{Change directories} %purpose
{s = chdir (dir)} %usage
{ }

If successful, this function returns \verb|s=0|,
otherwise it returns \verb|s=-1|.
\end{isisfunction}

\begin{isisfunction}
{debug} %name
{Debugging in ISIS} %purpose
{isis> help debug} %usage
{help, apropos, isis --help option}

There are several ways ISIS users may debug or fine-tune the
performance of analysis sessions and scripts.  We summarize
them here, and refer the reader to the S-Lang user manual for
more details.

Interactive Debugging:

The \verb|sldb| command will invoke the interactive S-Lang
debugger and change the prompt accordingly.  Type
\verb|help sldb| for more information.

Function and Variable Tracing:

\verb|_traceback| is an intrinsic integer variable whose
bitmapped value controls the generation of the call-stack
traceback upon error. When set to 0, no traceback will be
generated.  Otherwise its value is the bitwise-or of the
following integers:
\begin{verbatim}
       1        Create a full traceback
       2        Omit local variable information
       4        Generate just one line of traceback
\end{verbatim}
In batch mode, the default value of this variable is 4;
in interactive mode, the default value is 0.

Apropos:

The \verb|apropos| and \verb|_apropos| functions may be used to
find function and/or variable definitions which match a given
expression.  For more details consult the help content for each
function.

Command Line Options:

Invoking isis on the command line with the \verb|--help| option
displays several options which can assist debugging.  Among
these are:

\begin{verbatim}
--sldb [FILE]  Invoke S-Lang debugger, optionally on the given FILE

--sldb-isis    Invoke S-Lang debugger on isis internals

--prof [options] script args...

               Invoke S-Lang profiler, optionally on the given FILE
               The profiler can be helpful to increase the performance of
               your scripts by enabling one to see which functions are
               called most often and for how long.

-g             Include debugging information when byte-compiling scripts
               (this automatically sets _traceback to 1)

-v             Show verbose loading messages, which can be helpful to
               discern where scripts are being loaded from, especially
               if multiple copies of them exist on your system.
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{sldb}
{Initiate interactive debugging}
{sldb}
{\_traceback, help debug, isis --sldb and --help options}

This command will invoke the interactive S-Lang debugger and
change the prompt accordingly.  The \verb|sldb| debugger is
loosely patterned after \verb|gdb| and similar debuggers, and
allows one to set breakpoints, step through S-Lang statements
line by line, inspect or change variable values, and so forth.
Type \verb|help sldb| at the ISIS prompt for more information,
or \verb|help| once \verb|sldb| is invoked, or consult the sldb
chapter of the S-Lang user manual.

\end{isisfunction}

\begin{isisfunction}
{fft} %name
{Compute the discrete Fourier transform of a complex array} %purpose
{X[] = fft (x[], sign)} %usage
{fft1d}
\begin{verbatim}
  fft(x, sign)[k] = sum_j( x[j] * exp(sign* 2*PI*i *j*k / length(x)) )
                    /sqrt(length(x))

\end{verbatim}
where \verb|sign| is \verb|+1| or \verb|-1|.
\end{isisfunction}

\begin{isisfunction}
{fft1d} %name
{Compute the discrete 1D Fourier transform} %purpose
{(R, I) = fft1d (re, im, sign)} %usage
{fft}

{\it This function is deprecated:} \verb|fft1d| is essentially the
same function as \verb|fft| except that it handles the real and
imaginary parts separately. See \verb|fft| for details.
\end{isisfunction}

\begin{isisfunction}
{get\_isis\_load\_path}
{Get the current script load path}
{value = get\_isis\_load\_path ()}
{add\_to\_isis\_load\_path}

When loading scripts, \isisx searches directories specified in the
current load path which, by default, is initialized using the
{\sc ISIS\_LOAD\_PATH} and {\sc SLANG\_LOAD\_PATH} environment
variables. {\tt get\_isis\_load\_path} retrieves this search path.
\end{isisfunction}

\begin{isisfunction}
{get\_isis\_module\_path}
{Get the value of the current module search path}
{value = get\_isis\_load\_path ()}
{add\_to\_isis\_load\_path}

When loading scripts, \isisx searches directories specified in the
current module path which, by default, is initialized using the
{\sc ISIS\_MODULE\_PATH} and {\sc SLANG\_MODULE\_PATH} environment
variables. {\tt get\_isis\_module\_path} retrieves this search
path.
\end{isisfunction}

\begin{isisfunction}
{grand}
{Generate Gaussian-distributed random numbers}
{nums = grand ([n [,m ...]])}
{urand, prand, seed\_random}
\index{Random numbers!Gaussian}

If no arguments are given, a single random number will be
generated.  If N integer arguments are provided, they
are interpreted as defining the dimensionality of an
array which is to be populated with random numbers.

For example:
\begin{verbatim}
   x = grand();         % returns Double_Type
   a = grand(10);       % returns Double_Type[10]
   b = grand(100,200);  % returns Double_Type[100,200]
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{help} %name
{Retrieve help on \isisx and \slang\ intrinsics} %purpose
{help ("string")} %usage
{apropos, who}
\index{?@{\tt ?}}

If the string argument matches the name of a documented function,
the documentation for that function is displayed.

If no documentation is found, the function prints a list of \slang\
and \isisx intrinsic function names containing the string argument.
The function list is the same as would be obtained using the apropos
function with {\tt flags = 0xF}. Because all strings generate a match
with the empty string ({\tt ""}), an empty topic string can be used to
obtain a list of all available intrinsic functions.

A usage message is generated if no topic string is specified.

\end{isisfunction}

\begin{isisfunction}
{histogram}
{Bin scatter data into a histogram}
{nx = histogram(x, lo [, hi[, \&rev]])}
{hplot, histogram2d, linear\_grid, make\_hi\_grid}

Given $M$ values, $x_m$, and a set of $K$ bins, $[x_k^{\rm lo},
x_k^{\rm hi})$, this function computes the number of values, $n_x$,
falling within each bin, such that $x_k^{\rm lo} <= x < x_k^{\rm
hi}$.  It is assumed that $x_{k-1}^{\rm hi} = x_k^{\rm lo}$,
e.g. the grid has no holes.

If this function is called with only 2 arguments, a default
\verb|hi| grid is constructed such that
\begin{verbatim}
   hi = [lo[[1:K-1]], DBL_MAX].
\end{verbatim}
This ensures that the last bin is an ``overflow bin'' containing
the number of values $x_m >$~\verb|lo[K-1]|.

If present, the last optional argument is used to return an
array of arrays.  Each array element is an array containing the
indices of the values falling into the corresponding bin. In
other words, using the above notation, \verb|rev[k]| is an
array listing the members of bin \verb|k|, so that
\verb|length(rev[k]) = nx[k]|.

For example:
\begin{verbatim}
    % Bin some Gaussian distributed random values:
    (lo,hi) = linear_grid (-5,5,1024);
    x = grand (10000);
    nx = histogram (x, lo, hi);
    hplot (lo, hi, nx);

    % Demonstrate the reverse-index array:
    x = grand(10);
    (lo, hi) = linear_grid (-2,2,5);
    variable rev;
    nx = histogram (x, lo, hi, &rev);
    m = array_map (Int_Type, &length, rev);

    print(m);
    => 1
       1
       6
       2
       0
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{histogram2d}
{Bin scatter data into a 2-D histogram}
{num[,] = histogram2d (x[], y[], xgrid[], ygrid[] [, \&rev])}
{histogram, plot\_contour, plot\_image}

Given $M$ points, ($x_m$, $y_m$), and a grid for each
coordinate axis $(xgrid_j, ygrid_k)$,
this function computes the number of points, $N(j,k)$,
falling within each bin, such that
$xgrid_j <= x < xgrid_{j+1}$ for $j=0,N_j-1$ and
$ygrid_k <= y < ygrid_{k+1}$ for $k=0,N_k-1$.
The last bin in each row or column is an overflow bin
such that its upper limit is at infinity.

If present, the optional argument is used to return an array of
arrays such that \verb|rev[i,j]| contains a list of the indices
of the values that went into bin \verb|[i,j]|.
\end{isisfunction}

\begin{isisfunction}
{howmany}
{Count non-zero array elements}
{n = howmany (x[])}
{where, any}

This function returns the number of non-zero elements in
the specified array.

\end{isisfunction}

\begin{isisfunction}
{isis\_get\_pager} %name
{Retrieve the current pager definition string} %purpose
{s = isis\_get\_pager ()} %usage
{isis\_set\_pager}

\end{isisfunction}

\begin{isisfunction}
{isis\_set\_pager} %name
{Specify how extensive text output should be displayed} %purpose
{isis\_set\_pager ("pager\_command")} %usage
{isis\_get\_pager}

By default, ISIS uses the program specified by the \verb|PAGER|
environment variable to display extensive text output such as ISIS
documentation and tables of emission line parameters. This
behavior can be changed by providing a different pager definition.
For example, to have text information displayed in a separate
window which is opened automatically, do something like this
(assuming your favorite pager program is \verb|most|)
\begin{verbatim}
   isis_set_pager ("cat > /tmp/isis.help; xterm -e most /tmp/isis.help &");
\end{verbatim}
To simply dump text output to the screen, use
\begin{verbatim}
   isis_set_pager ("cat");
\end{verbatim}
To revert to the default behavior, do
\begin{verbatim}
   isis_set_pager (NULL);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{linear\_grid} %name
{generate a linear histogram grid} %purpose
{(binlo[], binhi[]) = linear\_grid (min, max, nbins);} %usage
{make\_hi\_grid}
This function generates a linear grid of histogram bins
such that
\begin{verbatim}
             binlo[0] = min
       binhi[nbins-1] = max
  binhi[j] - binlo[j] = (max - min) / nbins
  binhi[j] = binlo[j+1]                     for j=0,1,...nbins-2
\end{verbatim}
For example, to generate a wavelength grid with 1000 bins
extending from 1-20 \AA, type
\begin{verbatim}
    (lo, hi) = linear_grid (1, 20, 1000);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{make\_hi\_grid} %name
{Use a single grid array to define a histogram grid} %purpose
{hi[] = make\_hi\_grid (lo[]);} %usage
{linear\_grid}

Given a grid which provides the lower bin edges of
a histogram grid, the high edges are defined as
\begin{verbatim}
   hi = [ lo[[1:n-1]], 2*lo[n-1] - lo[n-2] ];
\end{verbatim}
so that the last two bins have the same width.

\end{isisfunction}

\begin{isisfunction}
{mean} %name
{Find the average value of an array} %purpose
{avg = mean (array)} %usage
{median, moment}
\end{isisfunction}

\begin{isisfunction}
{median} %name
{Find the median value of an array} %purpose
{m = median (array)} %usage
{mean, moment}
\end{isisfunction}

\begin{isisfunction}
{moment} %name
{Generate statistics for an array} %purpose
{Struct\_Type = moment (array)} %usage
{median, mean}
For example:
\begin{verbatim}
isis> x=grand(1000);         % Gaussian random numbers
isis> s = moment(x);
isis> print(s);
    num = 1000               % number of values
    ave = -0.00860764        % average
    var = 0.918971           % variance
    sdev = 0.95863           % standard deviation
    sdom = 0.0303145         % std dev. of the mean
    min = -2.8576            % smallest
    max = 2.82887            % largest
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{prand}
{Generate Poisson-distributed random values}
{x = prand (rate [,num])}
{grand, prand, seed\_random}
\index{Random numbers!Poisson}
If called with a single argument, this function returns an
equal-sized array of Poisson-distributed random values.
\begin{verbatim}
Example:
   isis> print(prand([3,3,3]));
   1.000000e+00
   0.000000e+00
   8.000000e+00
\end{verbatim}
If called with two scalar arguments, the specified number
of random values are chosen from the Poisson distribution
corresponding to the given rate.
\end{isisfunction}

% \begin{isisfunction}
% {print} %name
% {Print the fields of a \slang\ structure, or elements of an array} %purpose
% {print (s)} %usage
% {writecol, who}
% \index{printing struct fields}
% \index{printing array elements}
%
% This function is useful for printing out elements
% of 1- and 2-D arrays and for determining the names and values
% structure fields in interactive mode.
%
% \begin{verbatim}
% Example:
%
% isis> y=line_info(127);       % retrieve data on line #127
% isis> print(y);
%     id = 127
%     lambda = 256.318
%     flux = 0
%     Z = 2
%     ion = 2
%     upper = 6
%     lower = 1
%     up_name =
%     lo_name =
% \end{verbatim}
%
% This output shows that line 127 happens to be a He~II transition with
% $\lambda = 256.318$ \AA.  Although energy level labels are apparently not
% available, this transition connects energy levels 1 and 6 in the He~II
% energy level table.
% \end{isisfunction}

\begin{isisfunction}
{provide} %name
{Declare that a specified feature is available} %purpose
{provide (String\_Type feature)} %usage
{require, \_featurep}
The \verb|provide| function may be used to declare that a
``feature'' has been loaded.  See the documentation for
\verb|require| for more information.
\end{isisfunction}

\begin{isisfunction}
{quit} %name
{exit \isis} %purpose
{quit} %usage
{exit}
Use this function to exit \isis.  It is sometimes useful to have a script
exit and return an error code to the Unix shell;  for this, use
{\tt exit (err)}, where {\tt err} is the integer error code.
\end{isisfunction}

\begin{isisfunction}
{readcol} %name
{Read columns from an ASCII file} %purpose
{(a, b, ....) = readcol (file, [c1, c2, ....])} %usage
{writecol}
\index{ASCII files!reading}
The values \verb|c1|, \verb|c2|, etc. give the column numbers to
be read.  For example, to read columns 3 and 6:
\begin{verbatim}
  (x, y) = readcol ("ascii.dat", 3, 6);
\end{verbatim}
Lines beginning with a ``\verb|#|'' character are ignored.
\end{isisfunction}

\begin{isisfunction}
{reset} %name
{reset \isis} %purpose
{reset([force])} %usage
{quit}

This function frees all allocated memory, closes all plot windows and resets
most internal status variables to their internal defaults, but does {\it
not} reload the user's {\tt .isisrc} file.

If invoked with no arguments, {\tt reset} prompts the user to confirm the
reset.  If invoked with a non-zero value for {\tt force}, no user
confirmation is requested.
\end{isisfunction}

\begin{isisfunction}
{require} %name
{Make sure a feature is present, and load it if not} %purpose
{require (String\_Type feature [,String\_Type file])} %usage
{provide, \_featurep, evalfile}
The \verb|require| function ensures that a specified ``feature'' is present.
If the feature is not present, the \verb|require| function will attempt to
load the feature from a file.  If called with two arguments, the feature
will be loaded from the file specified by the second argument.  Otherwise,
the feature will be loaded from a file given by the name of the feature,
with ``\verb|.sl|'' appended.

If after loading the file, if the feature is not present,
a warning message will be issued.

Note that ``feature'' is an abstract quantity that is undefined here.

A popular use of the \verb|require| function is to ensure that a specified
file has already been loaded.  In this case, the feature is the
filename itself.  The advantage of using this mechanism over using
\verb|evalfile| is that if the file has already been loaded, \verb|require|
will not re-load it.  For this to work, the file must indicate that it
provides the feature via the \verb|provide| function.
\end{isisfunction}

\begin{isisfunction}
{save\_input} %name
{save commands to a disk file} %purpose
{save\_input [("filename" | File\_Type)]} %usage
{start\_log, stop\_log, .source}

If no file name is specified, the command log is saved in the file
{\tt isis.log}. If the log file already exists, the log is
appended to the existing file.

If passed a \verb|File_Type| pointer, the associated file
will not be closed by \verb|save_input|.
\end{isisfunction}

\begin{isisfunction}
{seed\_random}
{Seed the random number generator}
{seed\_random (int)}
{urand, grand, prand}
\index{Random numbers!seed value}

\end{isisfunction}

\begin{isisfunction}
{set\_readline\_method}
{Select the command prompt readline method}
{set\_readline\_method ("method");}
{}
\index{Readline method}

Use this function to select how the command-line interface
should behave.

If \isisx was compiled with GNU \verb|readline|, then GNU
\verb|readline| will manage the command line, providing
command-line editing and other features.

To use the command-line editing features provided by the
\slang interpreter, use
\begin{verbatim}
  set_readline_method ("slang");
\end{verbatim}

To turn off the command-line editing features, use
\begin{verbatim}
  set_readline_method ("stdin");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{start\_log} %name
{save commands to a disk file} %purpose
{start\_log [("filename")]} %usage
{stop\_log, save\_input, .source}

If no file name is specified, the log is saved in the file {\tt isis.log}.
If the log file already exists, the log is appended to the existing file.
\end{isisfunction}

\begin{isisfunction}
{stop\_log} %name
{turn off command logging} %purpose
{stop\_log} %usage
{start\_log, .source}
\end{isisfunction}

\begin{isisfunction}
{urand}
{Generate Uniformly-distributed random numbers}
{nums = urand ([n [, m ...]])}
{grand, prand, seed\_random}
\index{Random numbers!uniform}

If no arguments are given, a single random number will be
generated.  If N integer arguments are provided, they
are interpreted as defining the dimensionality of an
array which is to be populated with random numbers.

For example:
\begin{verbatim}
   x = urand();         % returns Double_Type
   a = urand(10);       % returns Double_Type[10]
   b = urand(100,200);  % returns Double_Type[100,200]
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{who} %name
{list currently defined variables and functions} %purpose
{who (["pattern"])} %usage
{apropos, print}

All variables and functions hose names contain {\tt "pattern"} are listed; if if {\tt
"pattern"} is absent, all symbols are listed.
\begin{verbatim}
For example:

     isis> x=[1,2,3,4];
     isis> y=&x;
     isis> z=x*3.0;
     isis> who;
     x: Integer_Type[4]
     y: &x
     z: Double_Type[4]
     isis>
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{writecol} %name
{Write arrays to an ASCII file} %purpose
{writecol (fp, a, b, ....);} %usage
{readcol}
\index{ASCII files!writing}
The first argument may be either a filename or a file pointer.
For example:
\begin{verbatim}
   % write to a file:
isis> writecol ("ascii.dat", x, y);

   % write to the screen
isis> x=[1:10];
isis> writecol (stdout, x,x,x,x,x,x);
1       1       1       1       1       1
2       2       2       2       2       2
3       3       3       3       3       3
4       4       4       4       4       4
5       5       5       5       5       5
6       6       6       6       6       6
7       7       7       7       7       7
8       8       8       8       8       8
9       9       9       9       9       9
10      10      10      10      10      10
\end{verbatim}
\end{isisfunction}

\newpage
\section{Handling High Resolution Spectra}
\label{sec:highres}

\isisx manipulates histogram data in which both bin edges are explicitly
specified, along with data values and uncertainties in each bin.  The
input data values in each bin must represent the integral of an
underlying continuous distribution over the bin-width.  In other
words, the input data values must be in bin-integral units like {\it
counts} or {\it counts/bin}, rather than bin-density units like {\it
counts/\AA}.  Although the {\it input} data values must be in
bin-integral units, the data can be {\it displayed} in either
bin-integral or bin-density units; see {\tt plot\_bin\_density}, {\tt
plot\_bin\_integral}.

For each input data set, \isisx maintains storage to hold the
associated counts histogram, the flux-corrected data and model spectra
in both flux and counts units; the flux-corrected version of the data
is optional.  When folding a spectral model through the instrument
response, \isisx stores both the input spectral model in flux units
and the counts histogram obtained by folding that model through the
instrument response.  Either version of the model or data is accessible
through commands such as {\tt get\_data\_counts}, {\tt
plot\_model\_flux}, etc.

For each dataset, the counts histogram, $D(h)$, is referred to
as \verb|data_counts|.  The corresponding predicted counts
histogram, $C(h)$, is referred to as \verb|model_counts| and is
computed according to equation (\ref{eq:model-counts}).
Flux-corrected data, ${\bar S(h)}$, is derived from the counts
histogram, $D(h)$, and the instrument responses according to
equation (\ref{eq:flux-corr}).  The term \verb|model_flux|
refers to the bin-integrated spectral model, $S(E)dE$. The term
\verb|convolved_model_flux| refers to the spectrum model
obtained by folding the model, $S(E)dE$ through the instrument
response, $RMF(h,E)$, with unit effective area, $A(E)$.

\isisx also maintains a separate, rebinned version of the data to
support fitting rebinned data ``on-the-fly''.  With \isis, it is not
necessary to run a separate program to generate a rebinned spectrum
file.  Because the rebinned data is stored separately from the input
data, reverting to the input grid is a trivial operation.

When folding data through the instrument response, one can also
rebin the instrument response matrix (RMF) using \verb|rebin_rmf|.
More often, it may be useful to simultaneously rebin the RMF and
the corresonding dataset using \verb|rebin_dataset|.
See \verb|rebin_rmf| for details.

Histograms may be loaded from FITS Type I or Type II pha files or
from ASCII files (see \verb|load_data|, \verb|define_back|).  \isisx
can handle multiple spectra simultaneously; reading successive
files appends the contents of each file to the internal list of
data sets.  {\tt list\_data} displays a list of the currently
loaded spectra and {\tt delete\_data} removes items from the list.
Type II pha files can contain both count histograms and
flux-corrected spectra; both are accessible.

Spectrum plots are generated using {\tt [o]plot\_data\_counts} and
{\tt [o]plot\_data\_flux}; model fits computed on the same grid as the
data may be displayed using {\tt [o]plot\_model\_counts} and {\tt
[o]plot\_model\_flux}.  The data values may be accessed using the
functions {\tt get\_data\_counts} and {\tt put\_data\_counts}, and
similar functions for flux-corrected data. Similar functions are
available for obtaining model spectrum values, either in flux-units or
in counts (as usually determined by folding a source spectrum through
the instrument response).

Effective area functions (ARFs) in both Type I and Type II formats may be
manipulated in a similar way using {\tt load\_arf}, {\tt list\_arf}, {\tt
delete\_arf}, {\tt get\_arf} and {\tt put\_arf}.
Event Redistribution Matrix Functions (RMFs) are accessible using
using {\tt load\_rmf}, {\tt list\_rmf}, {\tt assign\_rmf}, {\tt
unassign\_rmf}, and {\tt delete\_rmf}.
Observed spectra may be ``flux-corrected'' using {\tt flux\_corr}.

Positions of higher-order spectral features may be displayed using
{\tt lambda\_mth\_order}.

\begin{isisfunction}
{all\_arfs} %name
{Get a list of indices for all currently loaded ARFs} %purpose
{ids = all\_arfs();} %usage
{load\_arf, delete\_arf, all\_rmfs, all\_data}

This function is useful when you want to do something to all currently
loaded ARFs.  For example
\begin{verbatim}
  isis>  delete (all_arfs);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{all\_data} %name
{Get a list of data-set indices for all currently loaded data-sets} %purpose
{ids = all\_data([noticed]);} %usage
{load\_data, exclude, include, ignore, notice}

This function is useful when you want to do something to all currently
loaded data sets.  For example
\begin{verbatim}
  % to ignore all data sets
  isis>  ignore (all_data);

  % to get info on all % data sets
  isis>  info = get_data_info (all_data);
\end{verbatim}

If the optional argument (\verb|noticed|) is non-zero, the
function returns only the indices of data sets which have
noticed bins.
\end{isisfunction}

\begin{isisfunction}
{all\_rmfs} %name
{Get a list of indices for all currently loaded RMFs} %purpose
{ids = all\_rmfs();} %usage
{load\_rmf, delete\_rmf, all\_arfs, all\_data}

This function is useful when you want to do something to all currently
loaded RMFs.  For example
\begin{verbatim}
  isis>  delete (all_rmfs);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{assign\_arf} %name
{Assign an ARF to one or more spectra} %purpose
{assign\_arf (arf\_index[], hist\_index[])} %usage
{load\_arf,  list\_arf, unassign\_arf, flux\_corr, assign\_rsp}

After loading an ARF, it may be associated with one or more
histograms by specifying the index of the ARF and the histograms.
This indicates which ARF function should be used when computing
flux-corrected spectra and for fitting.  If an RMF is applied, the
ARF and RMF grids must match exactly.

\begin{verbatim}
Example:
        assign_arf (2, 1);             % ARF 2 goes with spectrum 1

        assign_arf (2, [3:6]);         % Spectra 3, 4, 5 and 6 should
                                       % use ARF 2
\end{verbatim}

\index{Allow\_Multiple\_Arf\_Factors@{\tt Allow\_Multiple\_Arf\_Factors}}

When a dataset has been assigned an RMF that includes an ARF
factor, assigning another ARF will generate a warning message,
but the ARF will be assigned anyway.  To prevent assigning such
additional ARF factors, set the intrinsic variable
\verb|Allow_Multiple_Arf_Factors| to a negative value. To allow
additional ARF factors to be assigned without complaint, set
\verb|Allow_Multiple_Arf_Factors=1|.  The default behavior
corresponds to \verb|Allow_Multiple_Arf_Factors=0|.

\end{isisfunction}

\begin{isisfunction}
{assign\_rmf} %name
{Assign an RMF to one or more spectra} %purpose
{assign\_rmf (rmf\_index[], hist\_index[])} %usage
{load\_rmf,  list\_rmf, unassign\_rmf, assign\_rsp}
After loading an RMF, it may be associated with one or more histograms
by specifying the indices of the RMF and the histograms.  This indicates
which RMF functions should be used when fitting models to data.
\begin{verbatim}
Example:
        assign_rmf (2, 1);             % RMF 2 goes with spectrum 1

        assign_rmf (2, [3:6]);         % Spectra 3, 4, 5 and 6 should
                                       % use RMF 2
\end{verbatim}

Note that the ARF and RMF grids must match exactly; relative
tolerances on the accuracy of the grid mismatch are controlled by
the intrinsic variable \verb|Rmf_Grid_Tol|.  If the RMF grid match
is inexact but ``close enough'' one can suppress grid-mismatch
errors by setting \verb|Rmf_Grid_Tol| to a small positive value.
For example, \verb|Rmf_Grid_Tol=0.001| would indicate that
acceptable mismatches must be smaller than 1 part in 1000.
\end{isisfunction}

\begin{isisfunction}
{assign\_rsp} %name
{Assign one or more ARF/RMF pairs to one or more spectra} %purpose
{assign\_rsp (arf\_list, rmf\_list, hist\_index\_list)} %usage
{load\_arf, load\_rmf, assign\_arf, assign\_rmf}

Although \verb|arf_list| and \verb|rmf_list| can refer to a single
ARF or RMF, this function is primarily intended to support
assigning multiple responses to one or more datasets (e.g. for
fitting LETG data which must include contributions from higher
orders). The responses listed are applied pairwise (e.g. {\tt
arf\_list[k]} goes with {\tt rmf\_list[k]}).

\begin{verbatim}
For example:
   % Assuming ARFs 1-10 and RMFs 1-10 correspond to
   % responses for dispersed orders 1-10:
        assign_rsp ([1:10], [1:10], 1);

   % Assign ARF #2 and RMF #3 to dataset 1.
        assign_rsp (2, 3, 1);
\end{verbatim}

The wavelength grid for the data is taken from the first RMF in
the {\tt rmf\_list}. Therefore, in analyzing data containing
multiple dispersion orders, the first element of {\tt arf\_list}
and the first element of {\tt rmf\_list} should normally
correspond to first-order.

Generating plots which compare the contribution from different
dispersion orders can be somewhat tricky to generate.
Here's how to examine the 3rd order contribution
to LETG/HRC data using a given spectral model:
\begin{verbatim}
   % Assuming ARFs 1-10 and RMFs 1-10 correspond to
   % responses for dispersed orders m=1-10:

        assign_rsp ([1:10], [1:10], 1);

   % First overplot the data with a model including
   % orders m=1-10.  Note that this plot uses the
   % 1st order wavelength grid.

        plot_data_counts (1);
        () = eval_counts;
        oplot_model_counts (1);

   % Now evaluate the 3rd order contribution and
   % overplot it using the 1st order wavelength grid

        assign_rsp (3,3, 1);
        () = eval_counts;
        assign_rsp (1,1, 1);
        oplot_model_counts (1);
\end{verbatim}

Values of \verb|arf_index|=0 or \verb|rmf_index|=0 imply the
corresponding identity response (e.g. ARF=1 or RMF=1).

\end{isisfunction}

\begin{isisfunction}
{combination\_members} %name
{Get a list of combined datasets} %purpose
{list = combination\_members (gid)} %usage
{combine\_datasets, match\_dataset\_grids, uncombine\_datasets, get\_combined, get\_combined2, rebin\_combined, set\_pre\_combine\_hook}

\end{isisfunction}

\begin{isisfunction}
{combine\_datasets} %name
{Combine several datasets to improve the fit-statistics} %purpose
{gid = combine\_datasets (list [, weights])} %usage
{combination\_members, match\_dataset\_grids, uncombine\_datasets, get\_combined, get\_combined2, set\_eval\_grid\_method, rebin\_combined, set\_pre\_combine\_hook}
\index{Combining datasets}
\index{Coupled sources}

This function may be used to label several datasets which
should be combined to improve statistics during a model fit.
This function may also be used to help solve coupled systems of
equations describing multiple sources which are only marginally
resolved.

Datasets to be combined must have identical grids; all spectral
bins must be the same and the same bins must be noticed in
each.  Use \verb|match_dataset_grids| to put several datasets
onto a common spectral grid.

The optional \verb|weights| argument specifies weights which
are used when combining the datasets.  In particular, the value
of bin $k$ in the combined dataset is
\begin{equation}
   D_k = \sum_i f_i D_{k,i}
\end{equation}
where the sum extends over all datasets and where $f_i$ is the
weight corresponding to dataset $i$.

The return value is the index of the dataset combination. Multiple
dataset combinations are supported.

Combining datasets in this way is conceptually equivalent to
summing datasets, but is somewhat more consistent because the
models for the individual datasets are treated consistently for
any fit-kernel.

For example, the $\chi^2$ fit statistic for the combined
datasets is computed as
\begin{equation}
  \chi^2 = \sum_k W_k \left(\sum_i f_i D_{ki} - M_{ki}\right)^2
\end{equation}
where $D_{k,i}$ and $M_{k,i}$ are the data and model values,
respectively, for bin $k$ of dataset $i$ and where $W_k$ is the
statistical weight for bin $k$ in the combined dataset.  For Poisson
statistics,
\begin{equation}
  W_k = {1 \over \sum_i f_i D_{ki}}.
\end{equation}

When working with combined datasets, one can use the
\verb|ignore|/\verb|notice| functions as long as each member is
treated the same way.  For example:

\begin{verbatim}
 % create a dataset group:
  g = [1, 2, 3, 4];
  match_dataset_grids (g);
  gid = combine_datasets (g);

 % ignore the same data-range in every group member
  ignore (g, 13.4, 14.2);

 % fit models in the usual way
  () = fit_counts;
\end{verbatim}

One may also combine datasets to analyze data for coupled
sources.  For example, consider an observation of 2 sources
(\verb|a,b|) which are only marginally resolved.  Suppose the
spectrum model for source (\verb|a|) is \verb|S_A| and
the model for source (\verb|b|) is \verb|S_B|. Separate spectra
(\verb|D_a, D_b|) may be extracted, but each spectrum is
contaminated by the other so that, in general, the 2 datasets
are represented by a system of equations of the form
\begin{verbatim}
   D_a = R_Aa * S_A + R_Ba * S_B;
   D_b = R_Ab * S_A + R_Bb * S_B;
\end{verbatim}
in which both source models contribute to each dataset through
a set of responses \verb|R_xy|. In this expression, the
products \verb|R*S| are intended as a shorthand notation to
represent folding the source model \verb|S| through the
(possibly nonlinear) instrument response \verb|R|.

To solve this system of coupled equations, one can do the
following:

\begin{verbatim}
     load_dataset (D_a, R_Aa);    % dataset #1
     load_dataset (D_a, R_Ba);    %         #2
     load_dataset (D_b, R_Ab);    %         #3
     load_dataset (D_b, R_Bb);    %         #4

     weights = [0.5, 0.5];

     combine_datasets (1,2, weights);
     combine_datasets (3,4, weights);

     define coupled_sources_model()
     {
         switch (Isis_Active_Dataset)
         { case 1 or case 3:  return S_A(); }
         { case 2 or case 4:  return S_B(); }
     }

     fit_fun ("coupled_sources_model()");
\end{verbatim}

Consider how this works for the combination of datasets 1 and
2.  Evaluating the coupled source model for dataset 1 yields the
product \verb|R_Aa*S_A| and evaluating it for
dataset 2 yields the product \verb|R_Ba*S_B|.
Combination of the models for datasets 1 and 2 then yields
\begin{verbatim}
       R_Aa*S_A + R_Ba*S_B
\end{verbatim}
while the weighted combination of the datasets themselves yields
\begin{verbatim}
       0.5*D_a + 0.5*D_a = D_a.
\end{verbatim}
(And similarly for the combination of datasets 3 and 4). It
follows that minimizing the fit-statistic for all 4 datasets
simultaneously yields the solution to the system of 2 coupled
equations.

\end{isisfunction}

\begin{isisfunction}
{copy\_data\_keywords} %name
{Copy keywords values between two data sets} %purpose
{copy\_data\_keywords (to\_id, from\_id)} %usage
{load\_data}

\end{isisfunction}

\begin{isisfunction}
{cursor\_counts} %name
{Compute statistics for a given wavelength region} %purpose
{cursor\_counts (hist\_index [, out\_file [, flag]])} %usage
{cursor\_flux, region\_counts, region\_flux }.

This function is analogous to the {\tt region\_counts} function except that 1)
the input {\tt xmin}, {\tt xmax}, {\tt ymin}, {\tt ymax} values are taken
from reading the cursor position on a data plot and 2) the computed
statistics are automatically saved to a file. If {\tt flag} is one or is not
set, the statistics are continuum subtracted; if {\tt flag} is zero, the
continuum is assumed to be zero.
\end{isisfunction}

\begin{isisfunction}
{cursor\_flux} %name
{Compute statistics for a given wavelength region} %purpose
{cursor\_flux (hist\_index [, out\_file [, flag]])} %usage
{cursor\_counts, region\_counts, region\_flux }.
See {\tt cursor\_counts}.
\end{isisfunction}

\begin{isisfunction}
{define\_arf}  % name
{Define an ARF using \slang\ arrays} % purpose
{id = define\_arf (Struct\_Type |  binlo, binhi, arf, arf\_err)} % usage
{set\_arf\_exposure, set\_arf\_info, get\_arf\_info}

This function provides a way to define a new ARF using \slang\
arrays.  As input, it accepts 1) a Struct\_Type with fields
\verb|bin_lo, bin_hi, value, err| or 2) a list of four
equal-length arrays with the same data.  The \verb|bin_lo|,
\verb|bin_hi| arrays provide a wavelength grid in Angstrom
units, sorted in ascending order. The new ARF is added to the
internal list just as though the data had been loaded from a
FITS data file.  Normally, the function returns the integer
index of the new data-set.  If the function fails, the return
value is -1.

Note that when an ARF is defined in this way, one must
set the associated exposure time explicitly using either
\verb|set_arf_exposure| or \verb|set_arf_info|.
\end{isisfunction}

\begin{isisfunction}
{define\_back}  % name
{Define a background spectrum file} % purpose
{status = define\_back (index, "file")} % usage
{define\_counts, define\_flux, load\_data, back\_fun, \_define\_back, get\_back}
\index{background!file}

Use this function to specify a background spectrum for a data set
(e.g. the $B(h)$ term in equation (\ref{eq:model-counts})).  The
background spectrum file format may be either ASCII or OGIP/FITS
Type-I PHA.  If the FITS format is used, the BACKSCAL and EXPOSURE
keywords are used to scale the background relative to the data
spectrum. If the ASCII format is used, no re-scaling is performed.

To unassign the background, use \verb|define_back(index,NULL)|.

For example:
\begin{verbatim}
  () = define_back (1, "background.pha");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{\_define\_back}  % name
{Define a background spectrum using \slang\ variables} % purpose
{status = \_define\_back (index, bgd [, area [, exposure]])} % usage
{define\_counts, define\_flux, load\_data, back\_fun, define\_back, get\_back}
\index{background!\slang\ variables}

Use this function to specify a background spectrum for a data set
(e.g. the $B(h)$ term in equation (\ref{eq:model-counts})).  The
optional values of \verb|area| and \verb|exposure| are used to
scale the background relative to the data spectrum.  The array
\verb|bgd| containing the background values must be on an
ascending wavelength grid and must match the data set grid; the
\verb|rebin| function may be used to match the grids if
necessary).

To unassign the background, use \verb|_define_back(index,NULL)|.

For example:
\begin{verbatim}
  bgd_area = 400.0;     % extraction region [pixels^2]
  bgd_exposure = 4.e4;  % exposure time [sec]
  () = _define_back (1, bgd_array, bgd_area, bgd_exposure);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{define\_counts}  % name
{Define a counts-histogram using \slang\ arrays} % purpose
{s = define\_counts (Struct\_Type | bins | [lo, hi,] counts [, err])} % usage
{define\_flux, define\_back, Minimum\_Stat\_Err}

This function provides a way to define a new data-set using
\slang\ arrays.  As input, it accepts 1) a Struct\_Type with
fields \verb|bin_lo, bin_hi, value, err| or 2) a list of four
equal-length arrays with the same data or 3) a single array
containing only the bin values.  The new data-set is
added to the internal list just as though the data had been
loaded from an ascii or FITS data file.  Normally, the function
returns the integer index of the new data-set.  If the
function fails, the return value is -1.

The wavelength grid arrays (\verb|bin_lo, bin_hi|) and the
uncertainty (\verb|err|) arrays are optional.  If the wavelength
grid arrays are shorter than the \verb|counts| array (or are
missing), they are ignored, and the data grid is assumed to be
supplied by an RMF.  If the uncertainty array is shorter than the
\verb|counts| array (or is missing), a default uncertainty array
will be supplied assuming Poisson statistics.
\end{isisfunction}

\begin{isisfunction}
{define\_flux}  % name
{Define a flux-corrected histogram using \slang\ arrays} % purpose
{s = define\_flux (Struct\_Type | lo, hi, flux, err)} % usage
{define\_counts}

This function is similar to \verb|define_counts| except that
it is used to define a flux-corrected histogram.

\end{isisfunction}

\begin{isisfunction}
{delete\_arf}  % name
{Delete one or more ARFs from the internal table} % purpose
{delete\_arf (arf\_index\_list)} % usage
{list\_arf}

This function removes the indicated ARFs from the internal list; it does
{\it not} affect the FITS file containing the ARF.
\begin{verbatim}
Example:
      isis> delete_arf (3);
      isis> delete_arf ([4,8,9]);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{delete\_data} %name
{delete spectra from the internal list} %purpose
{delete\_data (hist\_index\_list)} %usage
{ list\_data}
This function removes the indicated spectra from the internal list;
it does not affect the disk files containing the spectra.
\begin{verbatim}
Example:
      isis> delete_data (3);
      isis> delete_data ([4,8,9]);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{delete\_rmf}  % name
{Delete one or more RMFs from the internal table} % purpose
{delete\_rmf (rmf\_index\_list)} % usage
{list\_rmf}

This function removes the indicated RMFs from the internal list; it does
{\it not} affect the file containing the RMF definition.
\begin{verbatim}
Example:
      isis> delete_rmf (3);
      isis> delete_rmf ([4,8,9]);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{factor\_rsp} %name
{Factor a response matrix (RSP) into an ARF and a normalized RMF} %purpose
{arfs = factor\_rsp (rmfs)} %usage
{load\_rmf, list\_arf, flux\_corr, eval\_flux}
\index{Response Matrices!factorization}
\index{flux-correction!RSP matrix}

Some response matrices are defined as the product of the
instrument effective area (the ARF) and the instrument
redistribution function (the RMF).

After loading such a response matrix with \verb|load_rmf|, this
function factors out the effective area and appends the
corresponding ARF function to the internal list of effective
area functions.  In the process, the response matrix is
renormalized such that the redistribution function for each
incident photon energy is unit normalized.

If the function succeeds, it returns the indices of the ARFs
appended to the internal list.  If an error occurs, the function
returns -1.

\begin{verbatim}
EXAMPLE:

 % load a response matrix which includes the
 % effective area and the redistribution function

 rsp = load_rmf ("rsp.fits");

 % factor out the effective area function
 % and normalize the redistribution function

 arf = factor_rsp (rsp);

 % assign the ARF and RMF to a dataset of interest

 assign_rmf (rsp, data_index);
 assign_arf (arf, data_index);

\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{fakeit}  % name
{Generate fake data using a given model, ARF and RMF} % purpose
{fakeit ([\&noise\_fun])} % usage
{load\_arf, load\_rmf, fit\_fun, set\_frame\_time, set\_arf\_exposure, define\_back, set\_fake}

This function may be used to generate fake data with user-defined
uncertainties for a list of ARF, RMF pairs (any real datasets
which happen to be loaded at the time will not be overwritten). If
a noise function (\verb|noise_fun|) is not provided, Poisson
statistics are assumed; to generate noiseless data, use
\verb|fakeit (NULL)|.

For example, to generate a single fake data set,
first load a matching ARF and RMF
and assign them to a non-existent data set index,
causing \isisx to generate an empty data set.
For example:
\begin{verbatim}
  load_arf ("arf.fits");
  load_rmf ("rmf.fits");

  assign_arf (1,1);
  assign_rmf (1,1);
\end{verbatim}
Having created an empty data set, the next step is
to populate it with fake data.

To do that, first define a spectral model using \verb|fit_fun|.
For example, one might use the XSPEC module:
\begin{verbatim}
   require ("xspec");                 % this is optional
   fit_fun ("phabs(1)*mekal(1)");
\end{verbatim}
Adjust the model parameters to the values desired
for the fake data set.

Now, use \verb|fakeit| to populate the counts vector
for this data set, plus Poisson errors:
\begin{verbatim}
   fakeit;
   rplot_counts (1);
\end{verbatim}
Here, we've also used \verb|rplot_counts| to plot the data,
model and residuals.

A user-defined noise function should take the model value
for a given bin as an argument and return the noise-added
value.   For example, to add uniformly
distributed noise with a 10\% amplitude use:
\begin{verbatim}
  define my_noise (model_in)
  {
      variable r = 2.0 * (urand(1) - 0.5);
      return model_in * (1.0 + 0.1 * r);
  }

  fakeit (&my_noise);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{flux\_corr}  % name
{Compute the flux-corrected spectrum} % purpose
{flux\_corr (hist\_index [,threshold])} % usage
{flux\_corr\_model\_counts, load\_arf, assign\_arf, unassign\_arf, back\_fun}

This function computes the ``flux-corrected'' spectrum, ${\bar
S(h)}$, defined by the expression
\begin{equation}
 {\bar S(h)} \equiv \frac{ C(h) - B(h)}{t~\int_{\Delta E(h)}\D E~{\cal F}\Bigl(R(h,E), A(E), 1\Bigr)}
\label{eq:flux-corr}
\end{equation}
where $A(E)$ is the effective area (the ARF) at energy $E$, $R(h,E)$
is the redistribution function (the RMF), $C(h)$ is the number of
source counts in detector bin $h$ and $t$ is the exposure time (from
the ARF EXPOSURE keyword). In this expression,
the fit ``kernel'', ${\cal F}(R, A, s)$ is evaluated for
a constant spectrum, $s(E)=1$,
and defaults to
\begin{equation}
       {\cal F}\left(R,A,1\right) = R(h,E)A(E)
\end{equation}
for the standard kernel. The integral spans the energy range,
$\Delta E(h)$, that contributes to detector bin $h$ (e.g.
all energies represented by the response).

In general, the degree to which this transformation produces a
useful result depends on the condition of the data, the
characteristics of the instrument response and the effect of the
relevant kernel, ${\cal F}$. For the standard kernel, in the limit
that $R(h,E)$ approaches a delta-function, the flux-corrected
spectrum, ${\bar S(h)}$, approaches the model spectrum, $s(E)$.
For example, flux-correcting high-resolution grating spectra
unaffected by photon pileup often provides a good estimate of the
incident spectrum (but uncorrected for blurring due to the line
spread function).  With moderate levels of pileup, the
flux-corrected spectrum may also yield a good estimate of the
incident spectrum.  For CCD resolution spectra which are
unaffected by photon pileup, the flux estimate may be reasonably
good for energies above $\sim 1$ keV and may be useful for
visualization purposes.  But for $E \lesssim 1$ keV, the CCD RMF
becomes rather broad and the resulting estimate ${\bar S(h)}$ may
differ significantly from the incident spectrum $s(E)$.

Note that the relevant instrumental background, $B(h)$, is
automatically subtracted (if available) to compute the number of
source counts $C(h)$. The flux result is stored separately and
does not over-write the counts histogram.  If the counts histogram
is re-grouped or rebinned after being flux-corrected, {\tt
flux\_corr} should be re-run to compute the flux values on the new
grid.

For the standard fit-kernel, uncertainties on the
flux-corrected spectrum are computed directly from the counts
so that
\begin{eqnarray}
   &{\bar S_k} = \frac{C_k - B_k}{I_k} \\
   &\delta{\bar S_k} = \frac{\sqrt{C_k + B_k}}{I_k}
\end{eqnarray}
where $k$ is the bin index and
\begin{equation}
I_k \equiv t~\int_{\Delta E(k)}\D E~R(k,E)A(E)
\end{equation}

The optional argument {\tt threshold} (= 0.0 by default) specifies the
detection limit in terms of the minimum acceptable signal-to-noise ratio
($S/N = C_k / \delta C_k$); bins which fall below this limit are assigned a
flux of zero.
\end{isisfunction}

\begin{isisfunction}
{flux\_corr\_model\_counts}  % name
{Compute a flux-corrected model spectrum} % purpose
{flux\_corr\_model\_counts (hist\_index [, threshold])} % usage
{flux\_corr, load\_arf, assign\_arf, unassign\_arf, back\_fun}

This function computes the ``flux-corrected'' model spectrum,
${\bar S^{(m)}(h)}$, defined by the expression
\begin{equation}
 {\bar S^{(m)}(h)} \equiv { {\Large\int}_{\Delta E(h)}\D E~{\cal
F}\Bigl(R(h,E), A(E), s(E)\Bigr)
                \over \int_{\Delta E(h)}\D E~{\cal
F}\Bigl(R(h,E), A(E), 1\Bigr) }
\end{equation}
where $A(E)$ is the effective area (the ARF) at energy $E$,
$R(h,E)$ is the redistribution function (the RMF) mapping into
detector bin $h$. In the numerator of this expression, the model
counts are predicted using the fit ``kernel'' ${\cal F}(R, A, s)$
as applied to the model spectrum, $s(E)$. In the denominator, this
``kernel'' is evaluated for a constant spectrum, $s(E)=1$. Recall
that the standard kernel is
\begin{equation}
       {\cal F}\left(R,A,s\right) = R(h,E)A(E)s(E).
\end{equation}
The integrals span the energy range, $\Delta E(h)$, that
contributes to detector bin $h$ (e.g.
all energies represented by the response).

The result, ${\bar S^{(m)}(h)}$, over-writes the internal array
used to store the convolved model flux; to retrieve the
numerical values, use \verb|get_convolved_model_flux()|.

Because the current implementation works only on an unbinned model
spectrum, the model must be computed on the same grid as the
unbinned data.  See \verb|flux_corr| for further details.

\end{isisfunction}

\begin{isisfunction}
{get\_arf}  % name
{Get numerical values from an ARF} % purpose
{Struct\_Type = get\_arf (arf\_index)} % usage
{put\_arf, list\_arf}.

This function retrieves an ARF function from the internal list
and loads the data into the fields of a \slang\ structure.

\begin{verbatim}
arf_index = integer index of ARF in internal list
 s.bin_lo = bin left edge [Angstrom]
 s.bin_hi = bin right edge [Angstrom]
  s.value = ARF value [cm^2 counts/photon]
    s.err = ARF uncertainty [cm^2 counts/photon]
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{get\_arf\_info}  % name
{Get ARF information} % purpose
{Struct\_Type = get\_arf\_info (id)} % usage
{set\_arf\_exposure, set\_arf\_info, get\_arf\_info}

This function returns a structure which
contains the values of auxiliary ARF parameters:

\begin{verbatim}
isis> s=get_arf_info(1);
isis> print(s);
    order = -1
    part = 2
    srcid = 0
    exposure = 28123.4
    fracexpo = 1
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_combined}
{Retrieve the combined dataset or corresponding model}
{Struct\_Type = get\_combined (gid, \&get\_function)}
{get\_combined2, combination\_members, combine\_datasets, uncombine\_datasets, match\_dataset\_grids, rebin\_combined, set\_pre\_combine\_hook}

Use this function to obtain the specified dataset combination
or the corresponding model combination.  The return value is
a \verb|Struct_Type| of the form
\begin{verbatim}
    struct {bin_lo, bin_hi, value, err}
\end{verbatim}
where the (\verb|bin_lo, bin_hi|) fields give the wavelength
grid, the (\verb|value|) field gives the sum of the specified
histograms and the (\verb|err|) field gives the corresponding
uncertainty.  These sums are computed using the combination
weights specified via \verb|combine_datasets|:
\begin{equation}
   D_k = \sum_i f_i D_{ik}
   \delta D_k^2 = \sum_i \left(f_i \delta D_{ik}\right)^2
\end{equation}
where $D_k$ is the summed value in bin $k$, $f_i$ is the weight
for dataset $i$ and $\delta D_k$ is the uncertainty of $D_k$.
Because models are assumed to be exact, models usually have a
\verb|NULL| value in the \verb|err| field.

Note that it is assumed that the function used as the second
argument (e.g. \verb|get_function|) returns spectra with
matching grids. Any function returning a result which uses the
data grid is acceptable because \verb|match_dataset_grids| will
ensure that the specified data grids all match.  In contrast,
one cannot in general use \verb|get_model_flux| here because
the model flux is computed on the ARF grid and the ARF grids
need not match.

EXAMPLE:
\begin{verbatim}

   % To plot the sum of the combined datasets
   % and over-plot the model for the combination:

   match_dataset_grids (3,4,9,10);
   gid = combine_datasets (3,4,9,10);
   () = eval_counts ();

   d = get_combined (gid, &get_data_counts);
   m = get_combined (gid, &get_model_counts);

   hplot(d);
   ohplot(m);

\end{verbatim}

Keep in mind that \verb|get_combined| always computes the sum
of vectors provided by the second argument.  If those vectors
represent counts, then the computed sum yields the total
counts. However, if those vectors represent flux, then the
computed sum is probably not what was intended -- in this case,
an exposure weighted mean is more likely to be useful.  To use
\verb|get_combined| to generate an exposure weighted mean, the
second argument might point to a custom function of this form:

\begin{verbatim}
define exposure_weighted_model_flux (i)
{
   variable f, info, exposure, weight;
   f = get_model_flux (i);
   info = get_data_info (i);
   exposure = get_arf_exposure (info.arfs[0]);
   weight = exposure / Total_Exposure_Time;
   f.value *= weight;
   return f;
}
mean_flux = get_combined (g, &exposure_weighted_model_flux);
\end{verbatim}

In this example, it is assumed that the global variable
\verb|Total_Exposure_Time| has been previously computed.

\end{isisfunction}

\begin{isisfunction}
{get\_combined2}
{Retrieve the combined dataset or corresponding model}
{Struct\_Type[] = get\_combined2 (gid[])}
{get\_combined, combination\_members, combine\_datasets, uncombine\_datasets, match\_dataset\_grids, rebin\_combined, set\_pre\_combine\_hook}

Use this function to retrieve dataset combination(s) from the internal
table. If the list of combination ids is \verb|NULL|, then the entire list
is returned.  The return value is a structure or an array of structures
with struct fields:
\begin{verbatim}
   __Field__     __Meaning__
   combo_id     combination id number
   bin_lo       histogram bin lower edge [Angstrom]
   bin_hi       histogram bin upper edge [Angstrom]
   model        summed model spectrum
   data         summed data spectrum
   err          uncertainty on summed data values
   indices      <internal use only>
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_convolved\_model\_flux} %name
{load spectral model into a \slang\ structure} %purpose
{Struct\_Type = get\_convolved\_model\_flux (hist\_index)} %usage
{flux\_corr\_model\_counts, get\_model\_counts, get\_model\_flux}

\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [photons/sec/cm^2]
     s.err = bin uncertainty [photons/sec/cm^2]
\end{verbatim}

This function retrieves the specified convolved flux histogram
from the internal list and loads the data into a structure.
Similar functions are available to retrieve counts data and
model values.

The convolved model flux is computed using the expression
\begin{equation}
F(h) = \int R(h,E)S(E)dE
\end{equation}
unless \verb|flux_corr_model_counts| was called for this data set.

\end{isisfunction}

\begin{isisfunction}
{get\_data\_backscale}
{Retrieve the background scaling for a given spectrum}
{area = get\_data\_backscale (hist\_index)}
{set\_data\_backscale}
Returns BACKSCAL keyword from the header for histogram {\tt
hist\_index}.  Grating data may have a BACKSCAL vector
of the same length as the data array;  note that in this
case, some BACKSCAL values may be zero, corresponding
to wavelength values which fall off of the detector.
\end{isisfunction}

\begin{isisfunction}
{get\_data\_counts} %name
{load spectral data into a \slang\ structure} %purpose
{Struct\_Type = get\_data\_counts (hist\_index)} %usage
{put\_data\_counts, get\_model\_counts, get\_data\_info}

\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [counts]
     s.err = bin uncertainty [counts]
\end{verbatim}

This function retrieves the specified counts histogram from the
internal list and loads the data into a structure.  Similar
functions are available to retrieve flux-corrected data
and model values.

\end{isisfunction}

\begin{isisfunction}
{get\_data\_exposure}
{Retrieve the exposure time for a given spectrum}
{t = get\_data\_exposure (hist\_index)}
{set\_arf\_exposure}
Returns exposure time in seconds from the header for histogram {\tt
hist\_index}.
\end{isisfunction}

\begin{isisfunction}
{get\_data\_flux} %name
{load spectral data into a \slang\ structure} %purpose
{Struct\_Type = get\_data\_flux (hist\_index)} %usage
{put\_data\_flux, get\_model\_flux, flux\_corr, get\_data\_info}

\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [photons/sec/cm^2]
     s.err = bin uncertainty [photons/sec/cm^2]
\end{verbatim}

This function retrieves the specified flux-corrected histogram
from the internal list and loads the data into a structure. See
\verb|flux_corr| for details on flux-correcting counts spectra.

\end{isisfunction}

\begin{isisfunction}
{get\_data\_info} %name
{load spectrum parameters a \slang\ structure} %purpose
{Struct\_Type[] = get\_data\_info (index\_list)} %usage
{set\_data\_info, load\_data, list\_data, array\_struct\_field}

This function returns an array of structures whose fields
contain the {\tt spec\_num, order, part} and {\tt srcid}
keywords for each data set listed in the {\tt index\_list}
along with the {\tt target} name string and the observation
start time, {\tt tstart} and the frame time, {\tt frame\_time}.
This structure also contains \verb|notice| and
\verb|notice_list| arrays indicating which data bins are
currently noticed (for model fitting) and a flag array,
\verb|rebin|, which indicates which of the original bins have
been grouped together (see \verb|rebin_data| for details). In
addition, the returned structure contains the indices for the
ARF(s) and RMF(s) assigned to the data set.  The \verb|exclude|
field indicates whether or not the dataset is currently
excluded from the fit. The names of the spectrum file
(\verb|file|) and associated background file (\verb|bgd_file|)
are also provided.

\begin{verbatim}
Example:
    isis> id = load_data ("o1318_heg+1_pha.fits");
    isis> s=get_data_info(id);
    isis> print(s);
        spec_num = 1
        order = 1
        part = 1
        srcid = 1
        exclude = 0
        combo_id = 0;
        combo_weight = 1;
        target = CAPELLA
        tstart = 7.5667e+07
        frame_time = 3.2
        arfs = Integer_Type[1]
        rmfs = Integer_Type[1]
        notice = Integer_Type[8192]
        notice_list = Integer_Type[8192]
        rebin = Integer_Type[8192]
        file = o1318_heg+1_pha.fits
        bgd_file =
\end{verbatim}

To extract a specific field from a returned array of
structures, use \verb|array_struct_field|.
\begin{verbatim}
Example:
   isis> d=load_data ("pha2.fits");
   Reading: ............
   isis> info = get_data_info(d);
   isis> part = array_struct_field(info, "part");
   isis> part;
   Integer_Type[12]
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_dataset\_metadata}
{Retrieve user-defined meta data associated with a dataset}
{meta = get\_dataset\_metadata (hist\_index)}
{set\_dataset\_metadata}

Use this function to retrieve arbitrary (user-defined) metadata
associated with a particular dataset.  The ability to assign
arbitrary metadata to a dataset and later retrieve it can be
useful to support analysis techniques unforseen during isis
development.
\end{isisfunction}

\begin{isisfunction}
{get\_flux\_corr\_weights}
{Retrieve the weights used to perform flux-correction}
{wt[] = get\_flux\_corr\_weights (hist\_index)}
{flux\_corr}

Define
\begin{equation}
W(h) = t \int dy R(h,y)A(y).
\end{equation}
This function returns the array $W(h)$ at full resolution.
In the linear regime, the flux-corrected data and uncertainties
are defined to be
\begin{eqnarray}
       f(h) &= (C(h) - B(h)) / W(h) \\
    df^2(h) &= (C(h) + B(h)) / W^2(h)
\end{eqnarray}
Summing over several bins $h$, to make a wider bin $H$,
a rebinned version is:
\begin{eqnarray}
     f(H) &= \frac{\sum_h C(h) - \sum_h B(h)}{\sum_h W(h)} \\
  df^2(H) &= \frac{\sum_h C(h) + \sum_h B(h)}{(\sum_h W(h))^2}
\end{eqnarray}
If we define weights
\begin{equation}
   w(h) = \frac{W(h)}{\sum_h' W(h')}
\end{equation}
we can rewrite the rebinned version, $f(H)$ and $df(H)$, as:
\begin{eqnarray}
     f(H) &= \sum_h w(h) f(h) \\
  df^2(H) &= \sum_h w^2(h) df^2(h)
\end{eqnarray}
This approach allows one to perform arbitrary rebinning
after computing the $f(h)$, $df(h)$ and $W(h)$ values only once.
\end{isisfunction}

\begin{isisfunction}
{get\_frame\_time} %name
{Get the CCD frame-time for a data set} %purpose
{frame\_time\_sec = get\_frame\_time (hist\_index)} %usage
{set\_frame\_time, get\_data\_info}
\index{Pileup!getting the frame time}

This function is normally used in conjunction with the CCD photon
pileup model.  The frame time is specified in units of seconds.

\end{isisfunction}

\begin{isisfunction}
{get\_back}
{Retrieve the scaled instrumental background for a given spectrum}
{b = get\_back (hist\_index)}
{define\_back, \_define\_back, back\_fun}

Returns an array of instrumental background values.
These values are on the same wavelength grid as that returned
by e.g. \verb|get_data_counts|.
\end{isisfunction}

\begin{isisfunction}
{get\_rmf\_arf\_grid}  % name
{Get ARF grid from an RMF} % purpose
{Struct\_Type = get\_rmf\_arf\_grid (rmf\_index)} % usage
{list\_rmf, get\_rmf\_data\_grid}.

This function retrieves the ARF grid from a specific RMF,
returning a \slang\ structure containing a wavelength grid
(angstrom units) in monotonic increasing order. The structure
returned has the form

\begin{verbatim}
 s.bin_lo = bin left edge [Angstrom]
 s.bin_hi = bin right edge [Angstrom]
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{get\_rmf\_data\_grid}  % name
{Get the data grid from an RMF} % purpose
{Struct\_Type = get\_rmf\_data\_grid (rmf\_index)} % usage
{list\_rmf, get\_rmf\_rmf\_grid}.

This function retrieves the data grid from a specific RMF,
returning a \slang\ structure containing a wavelength grid
(angstrom units) in monotonic increasing order. The structure
returned has the form

\begin{verbatim}
 s.bin_lo = bin left edge [Angstrom]
 s.bin_hi = bin right edge [Angstrom]
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{get\_sys\_err\_frac}  % name
{Get the fractional systematic error} % purpose
{sys\_err\_frac = get\_sys\_err\_frac (hist\_index)} % usage
{set\_sys\_err\_frac, load\_data}.

See \verb|load\_data| for a definition of fractional systematic
error, e.g. \verb|SYS_ERR|.

\end{isisfunction}

\begin{isisfunction}
{set\_sys\_err\_frac}  % name
{Set the fractional systematic error} % purpose
{set\_sys\_err\_frac (hist\_index, sys\_err\_frac[])} % usage
{get\_sys\_err\_frac, load\_data}.

See \verb|load\_data| for a definition of fractional systematic
error, e.g. \verb|SYS_ERR|.

\end{isisfunction}

\begin{isisfunction}
{group}
{Group spectral bins using S/N ratio and/or channel}
{group (datasets[] [; qualifiers])}
{group\_bin, group\_data, rebin\_data, use\_file\_group, regroup\_file, rebin\_dataset, set\_rebin\_error\_method, rebin, rebin\_array}
\index{Rebinning!signal to noise ratio}
\index{Rebinning!channel}

Rebin data sets using a combination of minimum signal-to-noise
(S/N) ratio and minimum number of channels in each grouped bin.
If multiple datasets are to be grouped, their grids must match
exactly.

The background data set, if it exists, is included in the S/N
calculation. \verb|group| presumes that the total noise goes as:
\begin{verbatim}
   sqrt( (Total_Counts) + (Back_Counts)*(Back_Scale*Exposure_Ratio)^2 )
\end{verbatim}
where the totals represent sums over all datasets (or those
specified by the \verb|sn_data| qualifier, if it is present).

The last channels are binned into a single group, regardless of
whether or not they meet the binning criteria.

Different rebinning criteria may be applied simulataneously to
different parts of the spectrum.  Spectrum subintervals are
specified using the \verb|bounds| and \verb|unit| qualifiers,
and grouping criteria are specified as arrays with one entry
for each subinterval.

\begin{verbatim}
Qualifier    Default     Meaning
---------    -------     -------
min_sn        0          Final bin will have S/N ratio >= min_sn
sn_data       all        List of datasets to be used for S/N calculation
                           (by default, all specified datasets are used)
min_chan      1          Final bin will contain at least min_chan bins
bounds        NULL       Endpoints of spectrum subintervals that
                            will be grouped differently
unit          Angstrom   Physical units of `bounds' coordinates
\end{verbatim}

For example,
\begin{verbatim}
    group ([1,2,3]; sn_data=[1,2],
                    bounds=[0.5,2], unit="kev",
                    min_chan=[2,4], min_sn=5);
\end{verbatim}
will group data sets 1,2, and 3, starting at 0.5 keV, to minimum S/N of
5 for the combination of data sets 1 and 2 only, and to a minimum of 2
channels between 0.5-2 keV, and 4 channels above 2 keV.
\begin{verbatim}
    group ([1:4]; bounds=[1.5,6,12,18], unit="a",
                  min_chan=[2,4,8,16], min_sn=0);
\end{verbatim}
will group data sets 1-4 to 2 channels per bin between 1.5-6
Angstroms, to 4 channels per bin between 6-12 Angstroms, to 8
channels per bin between 12-18 Angstroms, and to 16 channels
per bin above 18 Angstroms.
\begin{verbatim}
\end{isisfunction}

\begin{isisfunction}
{group\_bin}
{Group data to approximately match a specified grid}
{group\_bin (datasets[], lo, hi [; qualifiers])}
{group, group\_data, rebin\_data, use\_file\_group, regroup\_file, rebin\_dataset, set\_rebin\_error\_method, rebin, rebin\_array}

Regroup the specified datasets to match a particular histogram
grid as closely as possible without changing the underlying
spectral grids. If multiple datasets are to be grouped, their
grids must match exactly.

The physical units of the input grid may be specified using the
\verb|unit| qualifier. The current default physical units may
be obtained or changed using the \verb|unit_default| intrinsic.

To regrid a dataset to exactly match a particular grid, use
\verb|rebin_dataset|.
\end{isisfunction}

\begin{isisfunction}
{group\_data}
{Group spectral bins by an integer factor}
{group\_data (hist\_index\_array, factor)}
{group, group_bin, rebin\_data, use\_file\_group, regroup\_file, rebin\_dataset, set\_rebin\_error\_method, rebin, rebin\_array}
\index{Rebinning!integer factor}

The count data of each histogram in {\tt hist\_index\_array} is
rebinned by summing the contents of the original input data bins
and the associated bin uncertainties ({\tt stat\_err}) are
recomputed assuming Poisson statistics.  Use
\verb|set_rebin_error_method| to change the way bin uncertainties
are recomputed. Note that this rebinning does not involve an event
list.

\begin{verbatim}
Example:

  group_data (1, 4);   % group data set 1 by a factor of 4
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{back\_fun} %name
{Specify instrumental background function for a data-set} %purpose
{back\_fun (idx, "function")} %usage
{fit\_fun, set\_par, flux\_corr, define\_back, \_define\_back, get\_back}
\index{background!fitted}

This function allows one to define the component of the background
which is not folded through the ARF and RMF (e.g. the $B(h)$ term
in equation (\ref{eq:model-counts})). The syntax of the function
string is the same as that used by \verb|fit_fun|.

To eliminate the instrumental background term for a data-set, use
\verb|NULL| or an empty string (\verb|""|) as the second argument.

For example:
\begin{verbatim}
  % use a sum of power-law functions to model
  % the instrumental background for data-set 1:
  back_fun (1, "Powerlaw(1) + Powerlaw(2)");

  % Turn off the instrumental background term for
  % data-set 2
  back_fun (2, NULL);
\end{verbatim}

It is important to note that the specified background function
will be evaluated on the wavelength grid associated with the
data (at full resolution). If a different wavelength grid is
required, it may be necessary to implement the background
function using \verb|eval_fun2| to ensure that the correct grid
is used.

Here is one way to implement the background function using
\verb|eval_fun2|:

\begin{verbatim}
private variable First_Order_Grid = get_rmf_data_grid (1);
define backfun_fit (_l,_h,_p)
{
   variable l = First_Order_Grid.bin_lo;
   variable h = First_Order_Grid.bin_hi;
   variable p = eval_fun2 ("poly", l, h, _p[[:2]]);
   variable g = eval_fun2 ("gauss", l, h, _p[[3:]]);
   variable t = get_data_exposure (Isis_Active_Dataset);

   return t * (p + g);
}
add_slang_function ("backfun",
                     ["a0", "a1", "a2",
                      "area", "center", "sigma"]);

back_fun (h, "backfun");
set_par ("backfun", [0.030, -7.26e-6, 1.73e-6,
                     -0.32, 48.7, 16.4]);
\end{verbatim}

The most important aspect of this implementation is that it
ignores the data grid passed in the variables (\verb|_l, _h|),
instead computing the background contribution explicitly using
the first-order spectral grid contained in the structure,
\verb|First_Order_Grid|.

The distinction between the data grid and the background grid
can be important in the analysis of dispersed spectra
containing contributions from multiple dispersion orders and
with a significant background contribution(e.g. Chandra
LETG/HRC-S data).

\end{isisfunction}

\begin{isisfunction}
{interpol}
{Interpolate a function y(x) onto a new grid}
{new\_y[] = interpol (new\_x[], old\_x[], old\_y[])}
{rebin, interpol\_points}
\index{Interpolation!arrays}

The input function \verb|y(x)| specified by the \slang\ arrays
(\verb|old_x,old_y|) is linearly interpolated onto the grid
(\verb|new_x|) to determine the corresponding interpolated values
\verb|new_y|.  Both new and old grids must be in monotonic increasing order.

\begin{verbatim}
Qualifiers:
name          description
----          -----------
extrapolate   Specify extrapolation method, if any.
                extrapolate = "none"|"linear"|"logx"|"logy"|"logxy"
                     default:  extrapolate="linear"
        "linear" means perform linear extrapolation on old_y vs. old_x
          "logx" means perform linear extrapolation on old_y vs. log(old_x)
          "logy" means perform linear extrapolation on log(old_y) vs. old_x
         "logxy" means perform linear extrapolation on log(old_y) vs. log(old_x)

null_value    Y value used for off-grid X values when extrapolate="none"
                     default:  null_value=NULL
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{interpol\_points}
{Interpolate a function y(x) onto a new grid}
{new\_y[] = interpol\_points (new\_x[], old\_x[], old\_y[])}
{rebin, interpol}
\index{Interpolation!points}

This function is identical to \verb|interpol| except that
the array of X values, \verb|new_x|, need not be ordered.

\end{isisfunction}

\begin{isisfunction}
{is\_flux\_mode}
{Determine the current data mode}
{flag = is\_flux\_mode()}
{use\_flux, use\_counts}

{\it Use of this function and the \isisx data modes is not
recommended.} Experience has shown that use of these data modes leads
to confusion and unnecessary complications in analysis scripts. This
function is still available primarily to provide compatibility with
earlier versions of \isisx -- it may be removed in a subsequent
release.

Use this function to determine whether \isis is currently dealing with
flux data or count data.  If the return value is one, commands such as
{\tt get\_data}, {\tt put\_data} and {\tt plot\_data} all refer to
{\it flux-corrected} data (e.g. the {\tt FLUX} column in the Type II
PHA file).  If the return value is zero, these commands all refer to
{\it count} data (e.g. the {\tt COUNTS} column in the PHA file)
\end{isisfunction}

\begin{isisfunction}
{lambda\_mth\_order} %name
{Plot the location of $m$th order given that the $n$th order
              appears at $\lambda_n$.} %purpose
{lambda\_mth\_order (m, lambda\_n, [n])} %usage
{plot\_data\_counts}
If n is not specified, the default value is n=1.
lambda\_n is the wavelength in Angstroms (\AA).
\begin{equation}
\lambda_m = \lambda_n \left( {m \over n} \right)
\end{equation}
Non-integer orders are allowed.
\end{isisfunction}

\begin{isisfunction}
{list\_arf}  % name
{Display a list of currently loaded ARFs} % purpose
{list\_arf ([arg])} % usage
{get\_arf, put\_arf, delete\_arf}.

The optional argument is used to redirect the output.  If
\verb|arg| is omitted, the output goes to \verb|stdout|.  If
\verb|arg| is of type \verb|Ref_Type|, it the output string is
stored in the referenced variable.  If \verb|arg| is a file name,
the output is stored in that file.  If \verb|arg| is a file
pointer (\verb|File_Type|) the output is written to the
corresponding file.

The currently loaded list of effective area functions (ARFs) is
displayed.
The indices of the ARFs in this list ({\tt id} column) are used in other
commands to refer to individual ARFs; e.g. {\tt get\_arf (2)}
refers to ARF number 2.  The ARF list looks like this:
\begin{verbatim}
isis> list_arf;

Current ARF List:
 id grating detector  part/m src   nbins  exp(ksec)  target
  1    HETG     ACIS  heg+1   1     8192    89.88     mysrc
  2    HETG     ACIS  heg+2   1     8192    89.88     src2

\end{verbatim}
where the columns are defined as

\begin{verbatim}
      id = integer id number (arf_index)
 grating = e.g. HETG or LETG
detector = e.g. ACIS-S or HRC-S
       m = diffraction order (TG_M)
    part = e.g. HEG or MEG, (TG_PART)
     src = source index (TG_SRCID)
   nbins = total number of bins
     exp = Exposure time [ksec]
  target = target name
\end{verbatim}

If the intrinsic variable \verb|Isis_List_Filenames| is
non-zero, the name of the ARF file (if any) will be displayed
on the line following each list entry.

\end{isisfunction}

\begin{isisfunction}
{list\_data} %name
{display the currently loaded list of spectra} %purpose
{list\_data ([arg])} %usage
{delete\_data, load\_data, get\_data\_info, get\_dataset\_metadata}

The optional argument is used to redirect the output.  If
\verb|arg| is omitted, the output goes to \verb|stdout|.  If
\verb|arg| is of type \verb|Ref_Type|, it the output string is
stored in the referenced variable.  If \verb|arg| is a file name,
the output is stored in that file.  If \verb|arg| is a file
pointer (\verb|File_Type|) the output is written to the
corresponding file.

The currently loaded list of spectra is displayed.  The indices of
the spectra in this list ({\tt id} column) are used in other
commands to refer to individual spectra; e.g. {\tt plot\_data (2)}
refers to spectrum number 2.  The spectrum list looks like this:
\begin{verbatim}
id instrument  part/m src  use/nbins A  R     totcts exp(ksec) target
 1  HETG-ACIS  heg-3   1  6972/ 6972 -  - 4.8000e+01    0.00   src1
 2x HETG-ACIS  heg-2   1  6972/ 6972 1  1 2.2700e+02    0.00   src1
 3  HETG-ACIS  meg-1   1  6972/ 6972 -  - 6.2870e+03    0.00   src1
\end{verbatim}
where the columns are defined as
\begin{verbatim}
       id = integer data set id number ['x' => excluded from fit]
  grating = e.g. HETG or LETG
 detector = e.g. ACIS-S or HRC-S
     part = e.g. HEG or MEG, (TG_PART)
        m = diffraction order (TG_M)
      src = source index (TG_SRCID)
use/nbins = number of noticed bins/ (total number of bins)
        A = index of assigned ARF ("-" if none assigned)
        R = index of assigned RMF ("-" if none assigned)
   totcts = total counts summed over all bins
      exp = Exposure time [ksec]
   target = target name
\end{verbatim}

If the intrinsic variable \verb|Isis_List_Filenames| is non-zero,
the names of the spectrum file and background file (if any) will
also be displayed on lines following each list entry.

If the function \verb|list_data_hook| is defined in the Global
namespace, it will called for each dataset.  Among other
things, this hook can be used to display user-defined metadata.
For example, suppose you want to associate a string and a
floating point number with each dataset and you want these
values printed out whenever you call \verb|list_data|.  One way
to implement that is to store your metadata in a structure
along with a pointer to a function to do the printing. For
example, consider this structure definition:
\begin{verbatim}
   define printm (m)
   {
      vmessage ("s=%s, x=%g", m.s, m.x);
   }
   variable metadata = struct {s, x, printm};
   metadata.s = "Hello World!";
   metadata.x = 3.1415;
   metadata.printm = &printm;
\end{verbatim}
Use the \verb|set_dataset_metadata| function to associate this
structure with dataset \verb|1|:
\begin{verbatim}
   set_dataset_metadata (1, m);
\end{verbatim}
Now, to have this metadata printed out whenever \verb|list_data|
is run, provide a \verb|list_data| hook like this:
\begin{verbatim}
   public define list_data_hook ()
   {
      variable m = get_dataset_metadata (Isis_Active_Dataset);
      if (m != NULL)
       (@m.printm)(m);
   }
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{list\_rmf}  % name
{Display a list of currently loaded RMFs} % purpose
{list\_rmf ([arg])} % usage
{assign\_rmf, unassign\_rmf}.

The optional argument is used to redirect the output.  If
\verb|arg| is omitted, the output goes to \verb|stdout|.  If
\verb|arg| is of type \verb|Ref_Type|, it the output string is
stored in the referenced variable.  If \verb|arg| is a file name,
the output is stored in that file.  If \verb|arg| is a file
pointer (\verb|File_Type|) the output is written to the
corresponding file.

The list of currently loaded Redistribution Matrix Functions (RMFs)
is displayed.

\begin{verbatim}
Example:

isis> list_rmf;

Current RMF List:
 id grating detector  type   file
  1    HETG   ACIS-S  file:  hetg_rmf.fits

\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{load\_arf}  % name
{Load an effective area (ARF) file} % purpose
{status = load\_arf ("filename")} % usage
{load\_dataset, list\_arf, delete\_arf, assign\_arf, unassign\_arf}

This function loads either a FITS Type I or Type II ARF file; the
updated list of currently loaded ARFs is automatically displayed. On
return, {\tt status} is equal to the integer index of the ARF just
loaded ({\tt status} $>$ 0); a return value of {\tt status = -1} is
used to indicate failure.  (For Type II ARF input, a return value of
zero indicates success).

\end{isisfunction}

\begin{isisfunction}
{load\_data} %name
{read a spectrum from an ASCII file or FITS Type I or II PHA file} %purpose
{status = load\_data("pha\_filename" [, rows])} %usage
{load\_dataset, define\_counts, define\_flux, define\_back,
get\_data\_*, put\_data\_*, plot\_unit, set\_dataset\_metadata,
get\_dataset\_metadata, get\_sys\_err\_frac, Minimum\_Stat\_Err}

The format of the Type II PHA file is defined in the CXCDS Level 2
Data Products ICD. An ASCII-format file should contain the histogram
data in 4 columns: {\tt bin\_lo}, {\tt bin\_hi}, {\tt bin\_value},
{\tt bin\_uncertainty}.  By default, all spectra in a Type II pha file
are loaded at once; to load a particular list of spectra, supply an
array of row numbers as the (optional) second argument.

\begin{verbatim}
  Example:
          % to load spectra 9 and 10 from a standard
          % Chandra Type II pha file
          % (usually the MEG +1 and -1 order spectra):

        isis> id = load_data ("hetg_pha2.fits", [9,10]);
\end{verbatim}

Although a Type I PHA file can be loaded without first
specifying the RMF, an RMF is required to use the data.  The
RMF may be specified either by using the {\tt RESPFILE} keyword
in the FITS header or by loading the RMF file separately (see
{\tt load\_rmf} and {\tt assign\_rmf}). The ARF may be
specified either by using the {\tt ANCRFILE} keyword in the
FITS header or by loading the ARF file separately (see {\tt
load\_arf} and {\tt assign\_arf}).  To ignore the
\verb|ANCRFILE| and \verb|RESPFILE| values when loading
the PHA file, set \verb|Ignore_PHA_Response_Keywords=1|.

\index{Ignore\_PHA\_Response\_Keywords@{\tt Ignore\_PHA\_Response\_Keywords}}

Similarly, the {\tt BACKFILE} keyword in the FITS header
can be used to specify the name of the file containing
the background spectrum.  To ignore this keyword,
set \verb|Ignore_PHA_Backfile_Keyword=1|.

\index{Ignore\_PHA\_Backfile\_Keyword@{\tt Ignore\_PHA\_Backfile\_Keywords}}

By default, isis ignores the \verb|GROUPING| column of the
input PHA file.  To automatically apply the grouping on input,
set the intrinsic variable \verb|Isis_Use_PHA_Grouping| to a
non-zero value.

Input data values must be bin-integral quantities rather than
bin-densities; uncertainty values should be positive.  By default, any
input {\tt STAT\_ERR} uncertainty values smaller than 1 are reset to
\begin{verbatim}
   stat_err = max[ sqrt(N), Minimum_Stat_Err ]
\end{verbatim}
Where \verb|Minimum_Stat_Err| is the smallest acceptable
(positive) uncertainty value with a default value of 1.
To shut off warnings about invalid uncertainties being
replaced, set \verb|Warn_Invalid_Uncertainties=0|.

\index{Minimum\_Stat\_Err@{\tt Minimum\_Stat\_Err}}
\index{Minimum valid stat\_err!see{{\tt Minimum\_Stat\_Err}}}
\index{Warn\_Invalid\_Uncertainties@{\tt Warn\_Invalid\_Uncertainties}}

If the \verb|SYS_ERR| column or header keyword is present, a
systematic error is always added in quadrature so that the
uncertainty on each data bin becomes
\begin{verbatim}
     sigma = sqrt ( sigma_stat^2 + (D * sys_err)^2 ),
\end{verbatim}
where \verb|sigma_stat| is the statistical uncertainty, and
\verb|D| is the corresponding data value.  This default
behavior can be altered by using the \verb|set_sys_err_frac|
function to set the systematic errors to 0.

When the data are rebinned, isis uses the mean systematic error
in each new bin.  The mean systematic error in each new bin is
computed using
\begin{verbatim}
   syserr =  (\sum_k syserr_k  dy_k ) / (y_hi - y_lo)
\end{verbatim}
where the new bin spans the wavelength interval
\verb|[y_lo,y_hi)|, and includes contributions from
full-resolution bins with systematic error \verb|syserr_k| and
width \verb|dy_k|.

If the input data are in flux units (photons/cm**2/sec/bin) and
non-positive uncertainties are encountered, the uncertainty is
set equal to 1.0. In each case a message is printed to warn the
user.  To reset the uncertainties to another value, see {\tt
get\_data\_*} and {\tt put\_data\_*}.

Input bin coordinates may be given as Angstrom (\AA), nm, eV, keV or
Hz; if the bin coordinates are unspecified, the default is Angstrom
units. Although all internal calculations are done in Angstrom units,
plots may be generated in any of the supported physical units. See
{\tt plot\_unit}.

In the ASCII format, lines with a \# symbol in column 1 are ignored
and may be used for comments.

The ASCII file may also contain keywords analogous to the header
keywords in FITS files.  All keywords must be grouped together at the
top of the file (possibly with interspersed comment lines).  Each
keyword line must have a semicolon (;) in column 1 and may contain
only one keyword name/value pair; a maximum of 1024 characters will be
scanned on each such line. Only the first 8 characters of each keyword
name are significant; the keyword name and keyword value must be
separated by at least one space or tab character. Keyword values may
be of type int, float, double or string; string keyword values may
contain any printable characters including embedded whitespace
characters (except newline). The supported keyword names are

\begin{verbatim}
___Keyname____Type____Definition_______________________

    object   string   source name
instrument   string   e.g. ACIS-S or HRC-S
   grating   string   e.g. HETG or LETG
  exposure   double   exposure [sec]
      tg_m   int      diffraction order
   tg_part   int      e.g. HEG or MEG
  tg_srcid   int      source id number
     xunit   string   physical units of bin coordinates
   bintype   string   bin-value units; [counts|flux]
\end{verbatim}

This function returns {\tt status} equal to the integer index of the
data set(s) loaded; for Type I pha files, this is a single positive
integer ($> 0$) and for Type II pha files, this is an array of
positive integers.  Otherwise, it returns {\tt status = -1} to
indicate failure.

\begin{verbatim}
Example ASCII format file:

  # this is a comment line
  #
  ;     Object   test src 1
  #
  ; Instrument   acis-s
  ;    Grating   heg
  ;   Exposure   1.e6
  ;      xunit   angstrom
  ;    bintype   counts
  #
  #   bin_lo           bin_hi    counts stat_err
    1.5955326e+01   1.5960888e+01   4.0    2.0
    1.5960888e+01   1.5966450e+01   4.0    2.0
  #   another comment line
    1.5966450e+01   1.5972012e+01   4.0    2.0
    1.5972012e+01   1.5977573e+01   4.0    2.0
\end{verbatim}

If the function \verb|load_data_hook| is defined in the Global
namespace, it will be
called after the data is successfully loaded as
\begin{verbatim}
  load_data_hook (file, id);
\end{verbatim}
where \verb|file| is the name of the file just loaded and
where \verb|id| is an array of \verb|Integer_Type| which
gives the indices of the datasets just loaded. Among other things, this
function may be used to automatically associate user-defined
metadata with each dataset.

For example, suppose you want each dataset to carry along the
\verb|RA_NOM|, \verb|DEC_NOM|, values from the FITS header.
Consider the following function
\begin{verbatim}
  public define load_data_hook (file, id)
  {
      variable m = fits_read_key_struct (file, "RA_NOM", "DEC_NOM");
      set_dataset_metadata (id, m);
  }
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{load\_dataset} %name
{Load a spectrum, ARF and RMF} %purpose
{load\_dataset ("data-file", "rmf-file", "arf-file")} %usage
{load\_data, define\_counts, define\_flux, load\_arf, load\_rmf, assign\_arf, assign\_rmf}

This function is essentially equivalent to the sequence:
\begin{verbatim}
  d = load_data ("data.fits");
  r = load_rmf ("rmf.fits");
  a = load_arf ("arf.fits");
  assign_rmf (r,d);
  assign_arf (a,d);
\end{verbatim}
If either the RMF or ARF names are missing or NULL,
the corresponding response is not assigned and defaults
to an ideal response.
\end{isisfunction}

\begin{isisfunction}
{load\_rmf} %name
{Load an RMF} %purpose
{status = load\_rmf ("filename[:init\_name[;options]]")} %usage
{load\_slang\_rmf, load\_dataset, list\_rmf, assign\_rmf, unassign\_rmf}
\index{User-defined!RMF}
\index{Rmf\_OGIP\_Compliance@{\tt Rmf\_OGIP\_Compliance}}

An RMF is usually a FITS file which conforms to the OGIP standard
RMF format.

\isisx also supports RMFs which are defined in software either
in S-Lang (see \verb|load_slang_rmf|) or in a compiled language
such as a C.
In the latter case, the RMF is specified by giving the name of a shared
library (.so file) which provides the software implementation
conforming to the interface defined in the \isisx source code in
\verb|src/isis.h|.  See \verb|test/rmf_user.c|
for an example implementation.

The name of the initialization function for the user-defined RMF
module should be included in the string specifying the name of the
shared library; the two names fields should be separated by a
colon (:).  Additional RMF-specific options may be specified
by adding semicolon-delimited arguments; these options
are passed to the RMF module initialization function when the RMF is
initialized for a specific histogram.  User-defined RMFs may parse
this string to obtain additional useful parameters, e.g. perhaps
an auxiliary data file name or specific values for user-defined
RMF parameters.

\begin{verbatim}
Examples:
        % load an OGIP FITS-format RMF file
        () = load_rmf ("heg_rmf.fits");

        % load a user-defined RMF module from librmf.so,
        % initialized by calling my_rmf_init_function().
        () = load_rmf ("librmf.so:my_rmf_init_function");

        % here, additional option strings are used to supply
        % two parameters to the RMF function when it is initialized.
        () = load_rmf ("libotherrmf.so:init_function ;sigma=4.32;a=4");
\end{verbatim}

By default, isis will complain and refuse if asked to load a
FITS RMF file which does not adhere closely to the OGIP
standard format.  Setting \verb|Rmf_OGIP_Compliance=0| will
reduce the required level of standards compliance. If isis
remains unable to read the file, the best approach may be to
modify the RMF file to adhere more closely to the standard
format.  Usually this is just a matter of adding a few keywords
and making sure that important keywords have correct values.
In particular, isis looks for
\begin{verbatim}
  EXTNAME = EBOUNDS
  EXTNAME = MATRIX | SPECRESP MATRIX
  HDUCLAS2 = RSP_MATRIX
  HDUCLAS3 = REDIST | DETECTOR | FULL
\end{verbatim}
The \verb|HDUCLASn| keywords are required for full OGIP
compliance, but will be ignored if \verb|Rmf_OGIP_Compliance=0|.

\end{isisfunction}

\begin{isisfunction}
{load\_slang\_rmf} %name
{Define an RMF using a S-Lang function} %purpose
{id = load\_slang\_rmf (\&func, h\_bin\_lo, h\_bin\_hi, arf\_bin\_lo, arf\_bin\_hi)\\
 id = load\_slang\_rmf (\&func, hist\_index, arf\_index)} %usage
{load\_rmf, load\_dataset, list\_rmf, assign\_rmf, unassign\_rmf}
\index{User-defined!RMF}

A S-Lang function can be used to define a redistribution function (RMF) with
the effective area (ARF) and data (EBOUNDS) grids specified either as S-Lang
arrays:
\begin{verbatim}
  id = load_slang_rmf (&func, h_bin_lo, h_bin_hi, arf_bin_lo, arf_bin_hi)
\end{verbatim}
or by referring to the indices of a dataset and an ARF:
\begin{verbatim}
  id = load_slang_rmf (&func, hist_index, arf_index)
\end{verbatim}

\begin{verbatim}
Qualifiers:
  parms=value        (optional parameter passed to func)
  threshold=double   (default: 1e-6)
  grid="en|wv"       (default: "en")
\end{verbatim}

The function that computes the RMF profile must be of the form:
\begin{verbatim}
    define func (h_bin_lo, h_bin_hi, en_or_wv [,parms])
\end{verbatim}
It must compute the RMF profile integrated over the \verb|h_bins| at the
energy or wavelength value \verb|en_or_wv| (depending upon the grid
qualifier).

\begin{verbatim}
EXAMPLE:

  define rmf_profile (bin_lo, bin_hi, x, parms)
  {
     variable resolution = parms;
     variable rmf = Double_Type[length(bin_lo)];

     if (x < bin_lo[0] || bin_hi[-1] <= x)
       return rmf;

     variable i = where (x * (1.0 - resolution/2.0) <= bin_lo
                         and bin_hi < x * (1.0 + resolution/2.0));

     rmf[i] = 1.0 / length(i);
     return rmf/sum(rmf);
  }

  rmf_id = load_slang_rmf (&rmf_profile,
                           linear_grid (0.1, 10, 1024),
                           linear_grid (0.1, 10, 2048); parms=0.02);
  assign_rmf (rmf_id, dataset_id);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{match\_dataset\_grids} %name
{Put a list of datasets onto the same grid} %purpose
{match\_dataset\_grids (list[])} %usage
{combination\_members, combine\_datasets, uncombine\_datasets, get\_combined, get\_combined2, rebin\_combined, set\_pre\_combine\_hook}

This function uses \verb|rebin_dataset| to put all the listed
datasets onto the original (ungrouped) grid from the first dataset
in the list. All spectrum bins are noticed.

Note that each dataset in the provided list should have its own
set of responses; in other words, no single response function (ARF
or RMF) should be assigned to more than one dataset.  This
restriction is necessary to avoid unintended side-effects when the
responses are interpolated onto the new grid.

The main purpose of this function is to support combining
datasets to improve statistics -- see \verb|combine_datasets|.
\end{isisfunction}

\begin{isisfunction}
{plot\_data} %name
{plot spectral data (counts) using the current plot format} %purpose
{[o]plot\_data (hist\_index [,style])} %usage
{plot\_data\_counts}
This is an alias for \verb|plot_data_counts|.
\end{isisfunction}

\begin{isisfunction}
{plot\_data\_counts} %name
{plot spectral data (counts) using the current plot format} %purpose
{[o]plot\_data\_counts (hist\_index [,style])} %usage
{rplot\_counts, set\_data\_color, [o]plot\_model, title}
\index{Label\_By\_Default@{\tt Label\_By\_Default}}
\index{oplot\_data\_counts@{\tt oplot\_data\_counts}}
\index{Plot!of spectra}

This function plots the counts histogram of the specified data set.
Other similar functions are available to plot the flux-corrected data
set (See {\tt [o]plot\_data\_flux}) and to plot the corresponding
model values (See {\tt [o]plot\_model\_counts} and {\tt
[o]plot\_model\_flux})

The spectrum to plot is specified using its integer index ({\tt
hist\_index}) in the current internal list (see {\tt list\_data}). The
destination plot window if different from the current default, are
specified using {\tt window}.

The plot data coordinates are in {\AA}ngstrom units by default, but
may be changed using the {\tt plot\_unit} function.  Bin values may be
plotted in either bin-integral units (the default) or bin-density
units (see {\tt plot\_bin\_integral} and {\tt plot\_bin\_density}).

Axis ranges default to the full range of the data, but may be
specified using {\tt [xy]range}. Both linear or logarithmic axis
scales are available; see {\tt [xy]log}. Errorbars are also available
(see {\tt errorbars}).

Plot axes are labeled automatically by default, to turn off this
behavior, set {\tt Label\_By\_Default = 0}; setting this variable to a
non-zero value will restore the default behavior.

Repeated invocations of {\tt oplot\_data\_counts} will automatically
switch line colors or styles to help distinguish the over-plotted
curves.  Depending on the current setting [ see {\tt style} ] either
colors or line styles (e.g. solid vs. dashed) are used to distinguish
over-plots. To override the automatic color/style changes, the {\tt
style} index can be specified explicitly for each plot (see also {\tt
set\_data\_color}).  Alternatively, the automatic color-changes can be
disabled using {\tt plot\_auto\_color}.

See \S\ref{sec:plot-functions} for a general discussion of \isisx
plotting.
\end{isisfunction}

\begin{isisfunction}
{plot\_convolved\_model\_flux} %name
{plot convolved spectral model flux for a specific data spectrum} %purpose
{[o]plot\_convolved\_model\_flux (hist\_index [,style])} %usage
{flux\_corr\_model\_counts, [o]plot\_data\_flux, [o]plot\_model\_flux}

This function plots the model for the specified data set
broadened using the assigned RMF.  The convolved model
flux is computed using the expression
\begin{equation}
F(h) = \int R(h,E)S(E)dE
\end{equation}
unless \verb|flux_corr_model_counts| was called for this data set.

See \verb|get_convolved_model_flux| and
\verb|plot_model_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{plot\_data\_flux} %name
{plot spectral data flux using the current plot format} %purpose
{[o]plot\_data\_flux (hist\_index [,style])} %usage
{set\_data\_color, [o]plot\_model\_flux, title}

This function plots the flux histogram of the specified data
set. The flux histogram may be computed from the counts
spectrum by \verb|flux_corr|, loaded from a data file by
\verb|load_data| or defined via \slang\ arrays using
\verb|define_flux|.  For details, see \verb|plot_data_counts|.

\end{isisfunction}

\begin{isisfunction}
{plot\_model\_counts} %name
{plot spectral model counts for a specific data spectrum} %purpose
{[o]plot\_model\_counts (hist\_index [,style])} %usage
{[o]plot\_data\_counts, [o]plot\_model\_flux, [o]plot\_convolved\_model\_flux}
\index{oplot\_model@{\tt oplot\_model}}
\index{Plot!of spectra}

This function plots the model for the counts histogram of the
specified data set.  The model counts, $C(h)$, are computed
using the expression
\begin{equation}
C(h) = B(h) + t \int {\cal F}\Bigl(R(h,E), A(E), S(E)\Bigr)dE
\end{equation}
where $B(h)$ is the background spectrum, $R(h,E)$ is the RMF,
$A(E)$ is the ARF and $S(E)$ is the model for the incident
photon spectrum.

See {\tt plot\_data\_counts} for details.
\end{isisfunction}

\begin{isisfunction}
{plot\_model\_flux} %name
{plot spectral model flux for a specific data spectrum} %purpose
{[o]plot\_model\_flux (hist\_index [,style])} %usage
{[o]plot\_data\_flux, [o]plot\_model\_counts, [o]plot\_convolved\_model\_flux}

This function plots the model for the specified data set.
Normally, the model represents the incident flux, $S(E)$,
integrated over the width of each spectral bin, and has units
of photons/sec/cm${}^2$.

See {\tt plot\_model\_counts} for details.

\end{isisfunction}

\begin{isisfunction}
{put\_arf} %name
{Change ARF grid and/or values} %purpose
{put\_arf (arf\_index, arf\_struct | bin\_lo, bin\_hi, arf, arf\_err)} %usage
{get\_arf, list\_arf}

If invoked with two arguments, the second argument should be a struct
with fields {\tt bin\_lo, bin\_hi, value, err}.  If invoked with five
arguments, the last four arguments should provide the equivalent
values:

\begin{verbatim}
arf_index = integer index of ARF in internal list
 a.bin_lo = bin left edge [Angstrom]
 a.bin_hi = bin right edge [Angstrom]
  a.value = bin value [cm^2 counts/photon]
    a.err = bin uncertainty [cm^2 counts/photon]
\end{verbatim}

This command replaces internal ARF data with values from several
\slang\ array-variables. Only the internal values are changed; no disk
files are affected.

The only restrictions are that 1) the dimensionality of the arrays
cannot be changed, 2) the input histogram grid must be consistent
(Angstrom units in monotonic increasing order with {\tt bin\_lo} $<$
{\tt bin\_hi}) and 3) the uncertainty values must be positive. Any
non-positive input values of {\tt uncertainty} are reset to 1 and a
message is printed to warn the user.

\begin{verbatim}
Example:
      a = get_arf(1);
      put_arf(1, a.bin_lo, a.bin_hi, a.value, 2 * a.err);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{put\_data\_counts} %name
{Change the counts histogram for a data set} %purpose
{put\_data\_counts (hist\_index, struct | bin\_lo, bin\_hi, value, uncertainty)} %usage
{get\_data\_counts, list\_data, define\_counts, define\_flux}

If invoked with two arguments, the second argument should be a struct
with fields {\tt bin\_lo, bin\_hi, value, err}.  If invoked with five
arguments, the last four arguments should provide the equivalent
values:

\begin{verbatim}
hist_index = integer index of spectrum in internal list
  d.bin_lo = bin left edge [Angstrom]
  d.bin_hi = bin right edge [Angstrom]
   d.value = bin value [counts]
     d.err = bin uncertainty [counts]
\end{verbatim}

This command replaces internal histogram data with values from several
\slang\ array-variables. Only the internal values are changed; no
disk files are affected.  A similar function is provided to modify
the flux-corrected data values ({\tt put\_data\_flux}).

The only restrictions are that 1) the dimensionality of the arrays
cannot be changed, 2) the input histogram grid must be consistent
(Angstrom units in monotonic increasing order with {\tt bin\_lo} $<$
{\tt bin\_hi}) and 3) the uncertainty values must be positive. Any
non-positive input values of {\tt uncertainty} are reset (e.g.
according to counting statistics for {\tt counts} = $N$, {\tt
uncertainty} = $\sqrt{N}$) and a message is printed to warn the user.

\begin{verbatim}
Example:
      c = get_data_counts (1);
      put_data_counts (1, c.bin_lo, c.bin_hi, c.value, sqrt(c.value));
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{put\_data\_flux} %name
{Change the flux-corrected histogram for a data set} %purpose
{put\_data\_flux (hist\_index, struct | bin\_lo, bin\_hi, value, uncertainty)} %usage
{get\_data\_flux, list\_data, define\_counts, define\_flux}

This function is analgous to \verb|put_data_counts|, except
that it overwrites the appropriate internal array containing
flux-corrected data.  See \verb|put_data_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{put\_model\_counts} %name
{Replace the counts model for a data set} %purpose
{put\_model\_counts (hist\_index, counts[])} %usage
{put\_model\_flux, put\_convolved\_model\_flux, eval\_counts, eval\_flux}

Use this function to replace the model counts array for a
particular data set.  Note that the dimension of the input
array must match the current, possibly rebinned, data set
including both noticed and ignored bins.

\end{isisfunction}

\begin{isisfunction}
{put\_model\_flux} %name
{Replace the flux model for a data set} %purpose
{put\_model\_flux (hist\_index, counts[])} %usage
{put\_model\_counts, put\_convolved\_model\_flux, eval\_counts, eval\_flux}

Use this function to replace the model flux array, \verb|S(E)|,
for a particular data set.  Note that the dimension of the
input array must match the ARF (or the unbinned data, if no ARF
has been assigned).

\end{isisfunction}

\begin{isisfunction}
{put\_convolved\_model\_flux} %name
{Replace the convolved flux model for a data set} %purpose
{put\_convolved\_model\_flux (hist\_index, counts[])} %usage
{put\_model\_counts, put\_model\_flux, eval\_counts, eval\_flux}

Use this function to replace the convolved model flux array for
a particular data set.  Note that the dimension of the input
array must match the current, possibly rebinned, data set.

\end{isisfunction}

\begin{isisfunction}
{rebin}
{Rebin a histogram}
{newval = rebin (new\_lo, new\_hi, lo, hi, value)}
{rebin\_data, group\_data, rebin\_dataset, rebin\_array, interpol}
\index{Rebinning!histograms}
\index{Adding plus and minus orders}

Using linear interpolation where necessary, the input histogram
specified by the \slang\ arrays ({\tt lo, hi, value}) is mapped onto
the specified grid (\verb|new_lo|, \verb|new_hi|) to produce the new
bin-value array {\tt newval}. Both input and output grids must be in
monotonic order. Note that the input histogram is assumed
to be a bin-integrated quantity such as {\tt counts/bin} and that no
unit conversions are performed; to rebin a bin-density such as {\tt
counts/\AA}, the user must explicitly handle the unit conversion, e.g.
\begin{verbatim}
   x = density * (hi - lo);                     % convert to bin-integral
   new_x = rebin (new_lo, new_hi, lo, hi, x);
   new_density = new_x / (new_hi - new_lo);     % convert to bin-density
\end{verbatim}
This function can be used to simplify adding spectra together (e.g.
summing plus and minus order diffracted spectra, and summing the
associated ARFs):
\begin{verbatim}
   Example:
      m = get_data_counts (megm1);   % get MEG m=-1 order
      h = get_data_counts (hegm1);   % get HEG m=-1 order

      mcts = m.value;
      hcts = h.value;

      % map HEG onto MEG grid:
      new_hcts = rebin (m.bin_lo, m.bin_hi, h.bin_lo, h.bin_hi, hcts);

      total = mcts + new_hcts;       % total counts in -1st order MEG+HEG
                                     % using MEG -1 wavelength grid.
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{rebin\_array}
{Rebin a \slang\ array to match a rebinned spectrum}
{result[] = rebin\_array (array[], rebin\_flags[])}
{rebin\_data, group\_data, rebin\_dataset}
\index{Rebinning!arrays}

It is sometimes useful to rebin a \slang\ array so that it matches
a rebinned dataset.  For example, suppose we have a dataset with
\verb|N| bins and a matching model array with the same number of
elements. If we rebin the data, the model array no longer matches:
\begin{verbatim}
  % rebin dataset 1 to have at least 30 counts per bin
  rebin_data (1, 30);
\end{verbatim}
To generate a new, matching model array, do the following:
\begin{verbatim}
  % retrieve the flag array used to rebin the data ..
  s = get_data_info (1);
  % .. and rebin the model the same way
  m = rebin_array (model, s.rebin);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{rebin\_combined}
{Rebin a combination of binned spectra}
{rebin\_combined (gid[], min\_counts\_per\_bin | index\_array)}
{combine\_datasets, group\_data, rebin\_dataset, set\_rebin\_error\_method, rebin, rebin\_array}
\index{Rebinning!minimum counts per bin}
\index{Rebinning!using index array}

This function is the same as \verb|rebin_data| except that it
operates on dataset combinations.  For example, one can use
this function to rebin a combination of datasets so that the
sum has a specified minimum number of counts per bin.
See \verb|rebin_data| and \verb|combine_datasets| for details.

\end{isisfunction}

\begin{isisfunction}
{rebin\_data}
{Rebin a binned spectrum}
{rebin\_data (hist\_index\_array, min\_counts\_per\_bin | index\_array)}
{group\_data, rebin\_dataset, set\_rebin\_error\_method, rebin, rebin\_array}
\index{Rebinning!minimum counts per bin}
\index{Rebinning!using index array}

The count data of each histogram in {\tt hist\_index\_array} is
rebinned by summing the contents of the original input data bins
and the associated bin uncertainties ({\tt stat\_err}) are
recomputed assuming Poisson statistics.  Use
\verb|set_rebin_error_method()| to change the way bin uncertainties
are recomputed. Note that this rebinning does not involve an event
list.

The second argument to {\tt rebin\_data} may be either a positive
scalar value or an integer array of the same size as the original
input histogram.

If the second argument is a scalar, it is interpreted as the
minimum desired number of counts per bin; e.g.
\verb|rebin_data(1,25)| will rebin spectrum 1 so that each bin
contains at least 25 counts.

If the second argument is an integer array the same length as the
original input histogram, it defines the scheme for summing over
the data bins.  The integer values of this array should be either
-1, 0 or 1; neighboring bins with the same sign (-1 or +1) are
summed together, while bins with a zero are ignored.

For example, if the original data has 10 bins, the index array should
have 10 bins.  These commands will:
\begin{verbatim}
    isis> i = [1, 1, -1, 1, 0, 1, -1, -1, -1, -1];
    isis> rebin_data (meg, i);
\end{verbatim}
will generate a 4 bin version of spectrum {\tt meg} with this grouping:
\begin{verbatim}
    result_bin[0] = original_bin[0] + original_bin[1]
    result_bin[1] = original_bin[2]
    result_bin[2] = original_bin[3] + original_bin[5]
    result_bin[3] = original_bin[6] + original_bin[7]
                    + original_bin[8] + original_bin[9]
\end{verbatim}
Note that zero values mean that the associated bin should be ignored
(\verb|original_bin[4]| in this example).

The original input histogram may be restored using
\begin{verbatim}
   isis> rebin_data (idx, 0);
\end{verbatim}
This also restores the ignore/notice values in effect before the data was
first rebinned; this feature provides a mechanism to excise bad bins in the
input spectrum.

{\it The flux-columns must be recomputed after rebinning the count
data.} Similarly, any associated fit-models must be recomputed.

\end{isisfunction}

\begin{isisfunction}
{rebin\_dataset} %name
{Rebin an RMF and its assigned spectrum} %purpose
{rebin\_dataset (dataset, bin\_lo, bin\_hi)} %usage
{rebin\_rmf, rebin\_data, group\_data, set\_rebin\_error\_method, rebin}
\index{Rebinning!data and response}

This function rebins a counts spectrum and its assigned instrument
response matrix (RMF) so that the RMF maps onto the new instrument
grid \verb|bin_lo|, \verb|bin_hi|. The RMF normalization is
preserved.  See \verb|rebin_data| and \verb|rebin_rmf| for
details.

\end{isisfunction}

\begin{isisfunction}
{rebin\_rmf} %name
{Rebin an RMF} %purpose
{rebin\_rmf (dataset, bin\_lo, bin\_hi)} %usage
{rebin\_dataset, rebin\_data}
\index{Rebinning!RMF}

This function rebins an instrument response matrix (RMF) so that
it maps onto a new instrument grid (\verb|bin_lo|, \verb|bin_hi|).
The RMF normalization is preserved.

RMF rebinning makes it possible to apply an RMF to a dataset with
a grid different from that for which the RMF was originally
constructed.

As one application, RMF rebinning provides a consistent way to
apply the instrument response to CCD spectra in PI space. The
instrument response is normally measured in PHA space but, to
account for gain variations over large areas of the detector, CCD
spectra from extended sources are often analyzed in PI space. When
constructing PI-RMFs, these gain variations are usually accounted
for by simply shifting the locations of Gaussian peaks in the
PHA-RMF. However, this process does not account for the distortion
in the Gaussian profile shape introduced by the nonlinear
transformation from PHA to PI space. In contrast, constructing
PI-RMFs by rebinning PHA-RMFs automatically includes any such
distortions.

\begin{verbatim}
Example:

   % This function rebins a PHA-RMF onto a PI-RMF grid
   define make_pi_rmf (k)
   {
      variable lo, hi;

      % Standard PI energy grid [keV]
      hi = 0.0146 * [1:1024];
      lo = hi - 0.0146;

      % tweak low end to E>0
      lo[0] += 1.e-3 * hi[0];

      return rebin_rmf (k, _A(lo, hi));
   }

   pi_data = load_data ("ccd_pi.fits");
   rmf = load_rmf ("pha_rmf.fits");
   make_pi_rmf (rmf);
   assign_rmf (rmf, pi_data);

\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{regroup\_file} %name
{Apply grouping to PHA file} %purpose
{regroup\_file (grp[], file)   OR  regroup\_file (id [,file])} %usage
{group\_data, use\_file\_group, i2x\_group, x2i\_group}

Use this function to regroup a \verb|PHA| file using an \isis\
grouping array.  The grouping array, \verb|grp| should be a
standard, wavelength-ordered, isis grouping array as defined in
the documentation for \verb|rebin_data|. The length of the
grouping array should match the length of the spectrum stored
in the PHA file.  This function will convert the grouping array
to an OGIP-standard, energy-ordered grouping array and will
write that array to the \verb|GROUPING| column in the specified
\verb|PHA| file.  If the first argument is an integer dataset
index, the grouping array associated with that dataset will be
used (e.g. \verb|get_data_info(id).rebin|). If the file name is
omitted, the file name associated with the dataset will be used
(e.g. \verb|get_data_info(id).file|).

For example:
\begin{verbatim}
  % regroup a PHA file to match a given dataset
   grp = get_data_info (3).rebin;
   regroup_file (grp, "pha.fits");

  % update the input PHA file to match the current grouping:
   id = load_data ("pha_x.fits");
   group_data (id, 4);
   regroup_file (id);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{region\_counts} %name
{Compute count statistics for a given wavelength region} %purpose
{Struct\_Type = region\_counts (hist\_index, xmin, xmax [,ymin, ymax])} %usage
{region\_flux}

A data structure is returned for the histogram indicated by {\tt
hist\_index}.  This structure contains a number of statistics for the
interval {\tt [xmin, xmax)}. Individual fields are accessible using
the \slang\ structure syntax; e.g. {\tt s.sum} or {\tt
s.centroid\_err} (see below).

If {\tt ymin} and {\tt ymax} are not specified, no continuum
subtraction is performed (it is assumed that the continuum level is
zero). If {\tt ymin} and {\tt ymax} values are specified, they are
used to define a linear continuum $c(\lambda) = a * \lambda + b$
passing through the two points {\tt (xmin, ymin)} and {\tt
(xmax,ymax)}. The continuum value in bin {\tt k} between
[$\lambda_{\rm lo}^k$, $\lambda_{\rm hi}^k$] is then computed using
\begin{equation}
C_k = \left(\lambda_{\rm hi}^k - \lambda_{\rm lo}^k\right)
\left[ a { \left(\lambda_{\rm hi}^k + \lambda_{\rm lo}^k\right) \over 2}
       + b \right]
\end{equation}
Note that \verb|ymin| and \verb|ymax| represent the continuum
{\it density} and have units of e.g. counts per Angstrom
or flux per Angstrom.

With this continuum level, the structure fields are:
\begin{verbatim}
               min, max = wavelength limits defining this region [Angstrom]
                  nbins = number of noticed bins in this region
           sum, sum_err = sum of noticed bins and RMS uncertainty
           net, net_err = continuum subtracted sum of noticed bins
                          and RMS uncertainty
 centroid, centroid_err = centroid of continuum subtracted emission
                          in noticed bins and RMS uncertainty [Angstrom]
   eqwidth, eqwidth_err = equivalent width (positive/negative for
                          emission/absorption) of noticed bins and
                          RMS uncertainty [Angstrom]
          contin, slope = continuum density and slope at the
                          centroid position
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{region\_flux} %name
{Compute flux statistics for a given wavelength region} %purpose
{Struct\_Type = region\_flux (hist\_index, xmin, xmax [,ymin, ymax])} %usage
{region\_counts}

See {\tt region\_counts}.
\end{isisfunction}

\begin{isisfunction}
{rplot\_counts} %name
{Plot counts data and model with residuals} %purpose
{rplot\_counts (hist\_index)} %usage
{rplot\_flux, plot\_data\_counts, title}
\index{Plot!plotting residuals}

This function generates a two-paned plot, the upper pane
showing the counts data with model overlaid and the lower
pane showing the residuals.  The type of residuals plotted
is determined by the value of the intrinsic variable
\verb|Isis_Residual_Plot_Type|; supported values are:

\begin{verbatim}
___Value____Definition_________
   STAT     value provided by current fit-statistic
   DIFF     (data-model)
   RATIO    (data/model)
\end{verbatim}

The default is \verb|Isis_Residual_Plot_Type=STAT|. When the
fit-statistic is \verb|chisqr|, the plotted residual is
$\Delta\chi$.
% When the fit-statistic is \verb|cash|, the
% plotted residual for each bin is the (positive) Cash statistic
% for that bin, multiplied by the sign of \verb|(data-model)|.

\end{isisfunction}

\begin{isisfunction}
{rplot\_flux} %name
{Plot flux-corrected data and model with residuals} %purpose
{rplot\_flux (hist\_index)} %usage
{rplot\_counts, plot\_data\_flux, title}
\index{Plot!plotting residuals}

This function generates a two-paned plot, the upper pane
showing the flux-corrected data with model overlaid and the lower
pane showing the residuals.  See \verb|rplot_counts| for
details.

\end{isisfunction}

\begin{isisfunction}
{\_[o]rplot\_counts} %name
{Plot residuals for counts data} %purpose
{\_[o]rplot\_counts (hist\_index[, style])} %usage
{rplot\_counts, \_[o]rplot\_flux}

This function plots residuals of the type specified by the
intrinsic variable \verb|Isis_Residual_Plot_Type| See
\verb|rplot_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{\_[o]rplot\_flux} %name
{Plot residuals for flux-corrected data} %purpose
{\_[o]rplot\_flux (hist\_index[, style])} %usage
{rplot\_flux, \_[o]rplot\_counts}

This function plots residuals of the type specified by the
intrinsic variable \verb|Isis_Residual_Plot_Type| See
\verb|rplot_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{set\_arf\_exposure}
{Set the exposure time for a given ARF}
{set\_arf\_exposure (arf\_index, exposure\_sec)}
{get\_data\_exposure}

Use this to set exposure time in seconds for a particular effective
area function (ARF).

\end{isisfunction}

\begin{isisfunction}
{set\_arf\_info}  % name
{Set ARF information} % purpose
{set\_arf\_info (id, Struct\_Type)} % usage
{set\_arf\_exposure, set\_arf\_info, get\_arf\_info}

This function provides access to auxiliary ARF parameters
through a structure:

\begin{verbatim}
isis> s=get_arf_info(1);
isis> print(s);
    order = -1
    part = 2
    srcid = 0
    exposure = 28123.4
    fracexpo = 1;
isis> s.exposure=3.e4;       % change the exposure time
isis> set_arf_info(1,s);     % update the internal value
isis> list_arf;

Current ARF List:
 id grating detector part/m  src   nbins  exp(ksec)  target
  1                   meg-1   0     8192    30.00
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{set\_data\_color} %name
{Specify a plot color for one or more data sets} %purpose
{set\_data\_color (hist\_index\_list, color\_index)} %usage
{unset\_data\_color, color, plot\_data\_counts, plot\_auto\_color}

If a plot color is specified for a data set, that color will always be
used when plotting that data set. Unless this command is used to
specify a particular color, the data set will be plotted using the
default color in the corresponding plot window pane at the time the
plot is created.

\begin{verbatim}
 Example:
  red = 2;
  blue = 4;

  set_data_color (2, blue);        % always plot spectrum 2 in blue.

  set_data_color ([1,4,5], red);   % always plot spectra 1,4 and 5 in red
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_data\_backscale}
{Set the background scaling for a given spectrum}
{set\_data\_backscale (hist\_index, area)}
{set\_arf\_exposure}
Set the BACKSCALE value associated with for histogram {\tt
hist\_index}.  Normally, this is the area of the spectral
extraction region;  the same area units must be used for both
the source and background spectra.
\end{isisfunction}

\begin{isisfunction}
{set\_data\_exposure}
{Set the exposure time for a given spectrum}
{set\_data\_exposure (hist\_index, exposure\_sec)}
{set\_arf\_exposure}
Set the exposure time in seconds for histogram {\tt
hist\_index}.  Note that the ARF exposure time is the
important quantity for fitting data.
\end{isisfunction}

\begin{isisfunction}
{set\_data\_info} %name
{Change spectrum parameters using a \slang\ structure} %purpose
{set\_data\_info (index\_list, Struct\_Type)} %usage
{get\_data\_info, load\_data, list\_data}

This function changes selected data parameters using a structure
whose fields are integers which define the {\tt spec\_num,
order, part, srcid} and {\tt exclude} keywords along with
the {\tt target} name string.

\begin{verbatim}
Example:
  isis> load_data ("acisf01318N003_pha2.fits.gz");
  Reading: ............
  Integer_Type[12]
  isis> s = get_data_info(9);
  isis> print(s);
      spec_num = 9
      order = -1
      part = 2
      srcid = 1
      exclude = 0
      combo_id = 0;
      combo_weight = 1;
      target = CAPELLA
      tstart = 7.5667e+07
      frame_time = 3.2
      notice = Integer_Type[8192]
      notice_list = Integer_Type[8192]
      rebin = Integer_Type[8192]
      arfs = Integer_Type[1]
      rmfs = Integer_Type[1]
  isis>
  isis> s.order = 2;          % change #9 to 2nd order
  isis> set_data_info (9, s);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_dataset\_metadata}
{Associate user-defined meta data with a particular dataset}
{set\_dataset\_metadata (hist\_index, meta)}
{get\_dataset\_metadata}

Use this function to associate arbitrary (user-defined) metadata
with a particular dataset.  For example:

\begin{verbatim}
  set_dataset_metadata (1, "SKY_X=4013.42; SKY_Y=3987.4");
\end{verbatim}

The metadata may be retrieved using the \verb|get_dataset_metadata|
function.  The ability to assign arbitrary metadata to a
dataset and later retrieve it can be useful to support analysis
techniques unforseen during isis development.

\end{isisfunction}

\begin{isisfunction}
{set\_eval\_grid\_method} %name
{Specify the model evaluation grid method for a dataset} %purpose
{set\_eval\_grid\_method (method, datasets[][, hook [,cache]])} %usage
{combine\_datasets}
\index{Extending model grid}

Supported grid methods are \verb|MERGED_GRID|,
\verb|SEPARATE_GRID| and \verb|USER_GRID|

\verb|SEPARATE_GRID| (the default) means that, when the model
is evaluated for each dataset, it is evaluated on the
wavelength grid defined by the ARF.  If no ARF is specified,
the data grid is used.

\verb|MERGED_GRID| means that, for the specified list of
datasets, the model is evaluated once at the highest resolution
needed and then the resulting model histogram is rebinned onto
the model grid associated with each dataset (usually the
associated ARF grid). This method is automatically
selected when datasets are combined using
\verb|combine_datasets|. When computation of the model is more
expensive than rebinning and when several datasets with
extensive wavelength overlap are being fitted simultaneously,
this feature should save a considerable amount of CPU time.
Because model computation usually dominates the CPU usage,
merging grids is often a valuable optimization.

For example:
\begin{verbatim}

  set_eval_grid_method (MERGED_GRID, [1:10]);

\end{verbatim}
means that a single wavelength grid will be derived by merging
the wavelength grids assigned to datasets 1-10.  When fitting
these datasets, the model will be evaluated once on the merged
grid and then rebinned onto the grid of each individual
dataset.  This means that on each iteration, the model will be
evaluated only once and not 10 times.

To revert to the default mode, use:
\begin{verbatim}

    set_eval_grid_method (SEPARATE_GRID, [1;10]);

\end{verbatim}

\verb|USER_GRID| means that, when the model is evaluated
for each dataset, it is evaluated on the wavelength grid
supplied by a user-provided S-Lang function.  This function
must be of the form
\begin{verbatim}
    Struct_Type = grid_hook (hist_index, Struct_Type);
\end{verbatim}
where the \verb|Struct_Type| has fields \verb|bin_lo| and
\verb|bin_hi|.  The grid returned by this function must
define a wavelength grid in Angstrom units, in ascending
order.  The optional fourth argument is a boolean value
which indicates whether or not the model value computed
on the specified grid should be cached and subsequently
rebinned onto all other grids in the specified group.

For example, suppose that 10 datasets have been loaded
and we want to extend the wavelength grid of 5 of them
beyond the range covered by the ARF grid.  First, define
a function to provide the necessary grid:
\begin{verbatim}
    define extender (id, s)
    {
       % <generate s.bin_lo, s.bin_hi here>
       return s;
    }
\end{verbatim}
We can then impose this model grid using:
\begin{verbatim}
   set_eval_grid_method (USER_GRID, [3:8], &extender);
\end{verbatim}
With this grid definition, ISIS will use the extended grid when
evaluating the model, S(E), for datasets 3-8. Note that the
model will be evaluated once for each dataset. If all these
datasets have the same wavelength grid and if the same
wavelength ranges are noticed in each, considerable
computational work may be saved by specifying that the model be
evaluated for one of these datasets and then simply rebinned
for the others in this group. To turn on model-caching for the
specified datasets, the optional fourth argument should be
non-zero:
\begin{verbatim}
   set_eval_grid_method (USER_GRID, [3:8], &extender, 1);
\end{verbatim}

IMPORTANT: Note that, by default, the standard fit kernel
evaluates the fit model only on those wavelength ranges that
contribute to noticed data bins, as determined from the
instrumental response.  When fitting data with operators that
represent convolutions, this behavior may not be desirable.
In such cases, it may be necessary to compute the model and to
apply the convolution operator over a much broader wavelength
range. To ensure that the model is computed over the entire
wavelength range specified by the user-defined grid, use the
\verb|eval| option on the standard kernel.  For example,
\begin{verbatim}
   set_kernel ([3:8], "std;eval=all");
\end{verbatim}
To revert to the default behavior, use
\begin{verbatim}
   set_kernel ([3:8], "std;eval=noticed");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{set\_fake} %name
{Specify whether or not a dataset should be considered fake} %purpose
{set\_fake (hist\_index, 0|1)} %usage
{fakeit}

This function is used to change the default status of a given
dataset.  By default, spectral data generated by \verb|fakeit|
is considered to be fake and will be over-written by subsequent
calls to \verb|fakeit|.  All other spectral data is considered
to be ``real'' and will not be over-written by calls to
\verb|fakeit|.

For example, to over-write a real dataset with fake data:
\begin{verbatim}
% load ascii-format spectral data
  load_data ("ascii.dat");

% mark dataset 1 as fake data
  set_fake (1, 1);

% over-write dataset 1
  fakeit;
\end{verbatim}

Alternatively, to keep a particular fake spectrum from being
over-written by subsequent calls to `fakeit', one could change
the status of that dataset using
\begin{verbatim}
   set_fake (id, 0);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{set\_frame\_time} %name
{Specify the frame-time for a data set} %purpose
{set\_frame\_time (hist\_index, frame\_time\_sec)} %usage
{set\_kernel, load\_kernel, set\_data\_info}
\index{Pileup!setting the frame time}

This function is normally used in conjunction with the CCD photon
pileup model.  The frame time is specified in units of seconds.

\end{isisfunction}

\begin{isisfunction}
{set\_post\_model\_hook} %name
{Modify the computed model before computing the fit-statistic} %purpose
{set\_post\_model\_hook (id[], \&func)} %usage
{fit\_fun, fit\_counts}

Use this function to modify the computed model after the
separate source and background contributions have been
computed, but before the fit-statistic is computed. One can
define a function of the form
\begin{verbatim}
   m = func (lo, hi, c, b)
\end{verbatim}
which will be called during fitting for the specified dataset.
This function will be passed the original (ungrouped)
wavelength grid of the detector (\verb|lo|, \verb|hi|) along
with the predicted source (\verb|c|) and background counts
(\verb|b|).  It should return the predicted total counts in
each detector bin; by default, it returns the sum of the source
and background counts:
\begin{verbatim}
  define post_model (lo, hi, c, b)
  {
     return (c + b);
  }
  set_post_model_hook (id, &post_model);
\end{verbatim}

This function may be used for a variety of other purposes, e.g.
to plot the model at each iteration of a fit, to treat
systematic errors or to examine alternate fitting techniques.

Note that this function may also include parameters which are
varied during the fit.  Suppose the desired hook-function
depends on two parameters which we'd like to vary during the
fit. In the following example, we show how to use a do-nothing
function to introduce the two parameters:

\begin{verbatim}
define dummy_fit (l,h,p)
{
   return 1;
}
add_slang_function ("dummy", ["a", "b"]);

fit_fun ("dummy(1)*powerlaw(1)");

define tweak_model (lo, hi, counts, bgd)
{
   variable a, b, x, y;
   x = counts;
   a = get_par ("dummy(1).a");
   b = get_par ("dummy(1).b");

   y = x*(1 + a*x)*exp(-b*x) + bgd;

   return y;
}
set_post_model_hook (id, &tweak_model);
\end{verbatim}

With this definition, the computed model has two additional
parameters:

\begin{verbatim}
isis> list_par;
dummy(1)*powerlaw(1)
 idx  param             tie-to  freeze  value   min     max
  1  dummy(1).a             0     0         0     0       0
  2  dummy(1).b             0     0         0     0       0
  3  powerlaw(1).norm       0     0         1     0   1e+10
  4  powerlaw(1).PhoIndex   0     0         1    -2       9
\end{verbatim}

which will vary during the fit, controlling the action
of the hook-function provided by \verb|set_post_model_hook|.
\end{isisfunction}

\begin{isisfunction}
{set\_pre\_combine\_hook} %name
{Modify the data and computed model spectra before computing spectral sums} %purpose
{set\_pre\_combine\_hook (id[], \&func)} %usage
{combine\_datasets, set\_eval\_grid\_method}

A pre-combine hook is a function that is called on behalf of a particular
dataset immediately before that dataset (or its associated model) is added to
one of the spectral sums accumulated by \verb|combine_datasets|. Each dataset
may be assigned a pre-combine hook. A pre-combine hook has the form:
\begin{verbatim}
  define pre_combine_hook (id, y)
  {
     % compute new_y
     return new_y;
  }
\end{verbatim}
where \verb|id| is a dataset index and \verb|y| and \verb|new_y| are
\verb|Double_Type| arrays of the same length.  To assign a pre-combine hook to
one or more datasets, do:
\begin{verbatim}
   set_pre_combine_hook (id, &pre_combine_hook);
\end{verbatim}
where \verb|id| is an integer dataset index or an array of indices.
To disable the pre-combine hook, do:
\begin{verbatim}
   set_pre_combine_hook (id, NULL);
\end{verbatim}

For consistency when using a pre-combine hook, it is necessary for isis to
separately evaluate the spectral model for each associated dataset instead of
using the \verb|MERGED_GRID| method which is the default for
\verb|combine_datasets|. For this reason, it is an error to assign a
pre-combine hook to a dataset without also specifying an evaluation method
different from \verb|MERGED_GRID|.  The most common evaluation method choice
is likely to be \verb|SEPARATE_GRID|:
\begin{verbatim}
  gid = combine_datasets (id);
  set_pre_combine_hook (id, &pre_combine_hook);
  set_eval_grid_method (SEPARATE_GRID, id);
\end{verbatim}
For details on different evaluation grid methods, see
\verb|set_eval_grid_method|.

As an example application of \verb|set_pre_combine_hook|, consider a set of
observed spectra in which each spectrum has a different Doppler shift, but
you'd like to shift all the spectra into the rest frame before combining. In
general, because the responses aren't easily shifted, you can't easily shift
the data spectra before performing the fit.  Assuming that the
dataset-specific redshift is available using \verb|get_dataset_metadata|, the
necessary Doppler shift can be applied with the following pre-combine hook:
\begin{verbatim}
define shift_to_emitter_frame (y, lo, hi, z)
{
   variable
     new_lo = lo / (1.0 + z),
     new_hi = hi / (1.0 + z);

   return rebin (new_lo, new_hi, lo, hi, y);
}

define pre_combine_hook (i, y)
{
   variable
     z = get_dataset_metadata (i),  % redshift
     x = get_data_info (i),
     d = get_data_counts (i);

   variable
     lo = d.bin_lo[x.notice_list],
     hi = d.bin_hi[x.notice_list];

   return shift_to_emitter_frame (y, lo, hi, -z);
}

...
gid = combine_datasets (ids);
set_eval_grid_method (SEPARATE_GRID, ids);
set_pre_combine_hook (ids, &pre_combine_hook);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_rebin\_error\_hook}
{Retrieve error propagation hook}
{Ref\_Type = get\_rebin\_error\_hook (hist\_index)}
{set\_rebin\_error\_method, set\_rebin\_error\_hook}

Use this function to retrieve a reference to a dataset's error propagation
hook, if any.  The function returns \verb|NULL| if the Poisson statistics are
in effect (or if the dataset does not exist).
\end{isisfunction}

\begin{isisfunction}
{set\_rebin\_error\_hook}
{Change the way rebinning propagates uncertainties}
{set\_rebin\_error\_hook (hist\_index, \&hook)}
{rebin\_data, group\_data, rebin\_dataset, Minimum\_Stat\_Err}
\index{Rebinning!error propagation}

Use this function to provide a S-Lang function to define how uncertainties are
propagated when a counts spectrum is rebinned. By default, Poisson
uncertainties are assumed. To change this default, provide a S-Lang function
of the form
\begin{verbatim}
  define hook (orig_cts, orig_stat_err, grouping)
\end{verbatim}
where
\begin{verbatim}
         orig_cts = the unbinned counts array
    orig_stat_err = the unbinned uncertainties
         grouping = index array specifying which bins are to
                    be grouped (see rebin_data() for details)
\end{verbatim}
This function should return the array of uncertainties corresponding to the
specified grouping. To indicate an error, the function should return
\verb|NULL|. Because ISIS validates the uncertainties returned by this
routine, it may also be necessary to change the value of
\verb|Minimum_Stat_Err| to ensure that the uncertainties computed by the
error-hook are not modified. Uncertainties must always be positive -- negative
or zero values are not allowed.

For example, to add bin uncertainties in quadrature when dataset 1
is rebinned:
\begin{verbatim}
  define rebin_error_hook (orig_cts, orig_stat_err, grouping)
  {
     return sqrt(rebin_array (orig_stat_err^2, grouping));
  }
  set_rebin_error_hook (1, &rebin_error_hook);
\end{verbatim}
Note that this error hook is equivalent to the built-in \verb|quadsum|
method supported by \verb|set_rebin_error_method|.

To delete the error-hook for a particular dataset (reverting to Poisson
statistics), use
\begin{verbatim}
    set_rebin_error_hook (index, NULL);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_rebin\_error\_method}
{Change the way rebinning propagates uncertainties}
{set\_rebin\_error\_method (hist\_index, "method\_name" [, \&method\_hook])}
{rebin\_data, group, group\_bin, group\_data, rebin\_dataset, Minimum\_Stat\_Err}
\index{Rebinning!error propagation}

Use this function to define the way statistical uncertainties are propagated
when a counts spectrum is rebinned. Supported error propagation methods are:

\begin{verbatim}
 __Method_Name__      __Definition__
   poisson (default)  new_stat_err = sqrt (grouped_counts)

   quadsum            new_stat_err = sqrt (sum (stat_err^2))

   user               defined by `method_hook' function reference.
                      (see set_rebin_error_hook for details)
\end{verbatim}

\begin{verbatim}
EXAMPLES:
    set_rebin_error_method (1, "quadsum");
    set_rebin_error_method (1, NULL);     % equivalent to "poisson"

    set_rebin_error_method (1, "user", &my_rebin_method);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{unassign\_arf} %name
{Undo the assignment of an ARF to a data set} %purpose
{unassign\_arf (hist\_index\_array)} %usage
{load\_arf,  list\_arf, assign\_arf}

\begin{verbatim}
Example:
        unassign_arf (1);             % unassign the ARF for spectrum 1
        unassign_arf ([3:6]);         % unassign the ARF for spectra 3, 4, 5 and 6

\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{unassign\_rmf} %name
{Undo the assignment of an RMF to a data set} %purpose
{unassign\_rmf (hist\_index\_array)} %usage
{list\_rmf, assign\_rmf}

\begin{verbatim}
Example:
        unassign_rmf (1);             % unassign the RMF for spectrum 1
        unassign_rmf ([3:6]);         % unassign the RMF for spectra 3, 4, 5 and 6

\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{uncombine\_datasets} %name
{Turn off dataset combination} %purpose
{uncombine\_datasets (gid[])} %usage
{combine\_datasets, match\_dataset\_grids, combination\_members, get\_combined, get\_combined2, rebin\_combined, set\_pre\_combine\_hook}

\end{isisfunction}

\begin{isisfunction}
{unset\_data\_color} %name
{Revert to using the current default plot color when plotting a data set} %purpose
{unset\_data\_color (hist\_index\_list)} %usage
{color, plot\_data\_counts,  plot\_auto\_color}
This removes a color specification set by {\tt set\_data\_color}
and reverts to the default plot behavior.
\end{isisfunction}

\begin{isisfunction}
{use\_file\_group} %name
{Apply PHA file grouping to a specified dataset} %purpose
{use\_file\_group (id, file)} %usage
{group\_data, regroup\_file, i2x\_group, x2i\_group}

Use this function to group a dataset to match the grouping in a
specified \verb|PHA| file. The length of the spectrum stored in
the PHA file should match the length of the ungrouped dataset.
This function will convert the OGIP-standard, energy-ordered
grouping array from the file to an array that matches the isis
convention (see \verb|rebin_data|) and will apply that grouping
to the specified dataset.  If the file name is omitted, the
file name associated with the dataset will be used (e.g.
\verb|get_data_info(id).file|).

For example:
\begin{verbatim}
  % regroup a dataset to match a given PHA file
   use_file_group (id, "pha.fits");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{i2x\_group} %name
{Convert isis-convention grouping array to OGIP-convention grouping array} %purpose
{xg[] = i2x\_group (ig[])} %usage
{x2i\_group, regroup\_file, use\_file\_group}

The isis grouping array convention is described in the help
page for \verb|rebin_data|.  See the xspec documentation for
details on the OGIP grouping array convention.

\end{isisfunction}

\begin{isisfunction}
{x2i\_group} %name
{Convert OGIP-convention grouping array to isis-convention grouping array} %purpose
{ig[] = x2i\_group (xg[])} %usage
{i2x\_group, regroup\_file, use\_file\_group}

The isis grouping array convention is described in the help
page for \verb|rebin_data|.  See the xspec documentation for
details on the OGIP grouping array convention.

\end{isisfunction}

\newpage
\section{Access to the Atomic Database}
\label{sec:atomic-db}

Because wavelength tables may be unavailable or may not provide a
complete listing of all emission lines present in the line emissivity
tables, the run-time atomic database is populated using {\it both}
wavelength and energy level tables {\it and} the line-emissivity
tables.  For this reason, some of the functions described in this
section may be useful even when atomic data files are unavailable.

To simplify access to a large database of emission line wavelengths,
\isisx provides a number of functions to define, track and manipulate
{\it groups} of lines defined by various criteria. Over-plotting line groups
on observed spectra ({\tt plot\_group}) provides an important aid to line
identification.

A line group is defined by a list of integers which represent the
index of each group member in the internal wavelength table.  This
integer list may be held in a \slang\ array-variable or (optionally)
stored in an internal table. A group may be registered in the internal
table using {\tt define\_group}; groups may be deleted from this
internal list using ({\tt delete\_group}). Each group in the internal
list can be given a mnemonic name ({\tt name\_group}).

The user can browse the contents of a line group using {\tt
page\_group}. Among other things, this output provides line indices
which may be used to refer to lines individually.  Given the line
index, the {\tt line\_info} function can retrieve information on a
single line.  {\tt group} returns an array containing the indices of
all lines in a given group. Line groups may be saved to a disk file
using {\tt save\_group}.

Lines can be grouped by element, ion ({\tt el\_ion}), wavelength ({\tt
wl}) and predicted flux in some specified spectral model ({\tt flx})
using the {\tt where} command which is a \slang\ intrinsic.  The
brightest lines in the current model (see {\tt create\_aped\_fun} in \S
\ref{sec:spectral_models}) can be selected using the function {\tt
brightest}.  Groups may be defined using logical expressions as arguments to
the {\tt where} command:
\begin{verbatim}
   lines = brightest(20, where(el_ion([8,12],[3:6]) and wl(1,15)));
\end{verbatim}
uses the current spectral model to select the brightest 20 lines in
the range 1-15 \AA~ which arise from O and Mg atoms ionized 3,4,5 or 6
times (e.g. O III, O IV, O V, OVI, Mg III, Mg IV, Mg V and Mg VI).
Logical operators {\tt not}, {\tt and} and {\tt or} and may be used in
these expressions.

Because some emission line wavelengths may not be accurately known,
high-resolution spectral data may provide better values than those
listed in the atomic database.  {\tt change\_wl} allows the user to
provide ``corrected'' wavelength values for use in \isisx run-time
analysis (the wavelength values in the FITS files are {\it not}
affected).

Energy level diagrams can be plotted using {\tt plot\_elev} and {\tt
[o]plot\_elev\_subset}; line transitions can be over-plotted on energy
level diagrams using {\tt oplot\_transitions}

\begin{isisfunction}
{add\_abundances} %name
{Add a new abundance table} %purpose
{id = add\_abundances (Struct\_Type | name, abun[], Z[]);} %usage
{set\_abund, list\_abund, get\_abundances}

Use this function to define a new abundance table. The
abundance table may be defined by a structure with fields
\verb|Z[]|, \verb|abun[]| and \verb|name| containing the proton
number of each element, its abundance and the name of the
abundance table, respectively.  Alternatively, these values
may be provided as separate arguments. The abundance
values must be given as log cosmic abundance by number,
relative to Hydrogen = 12.0.  The return value is the
index of the new table.

\end{isisfunction}

\begin{isisfunction}
{aped\_bib} %name
{Retrieve bibcodes for APED database sources} %purpose
{Struct\_Type = aped\_bib (Struct\_Type db, Integer\_Type[] lines)} %usage
{aped\_bib\_query\_string, el\_ion, wl, flx, trans, page\_group}

\begin{verbatim}
EXAMPLE
    % Retrieve references for emission lines between 1-20 Angstrom
    ref_struct = aped_bib (aped, where(wl(1,20)));
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{aped\_bib\_query\_string} %name
{Make a URL to retrieve APED bibcodes from the ADS database} %purpose
{String\_Type = aped\_bib\_query\_string (Struct\_Type refs)} %usage
{aped\_bib}

\begin{verbatim}
EXAMPLE
    % Retrieve references for emission lines between 1-20 Angstrom
    ref_struct = aped_bib (aped, where(wl(1,20)));
    qs = aped_bib_query_string (ref_struct);

    () = system ("lynx -dump '$qs' > /tmp/qs.bib"$);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{aped\_fun\_details} %name
{Retrieve detailed information (e.g. emission line fluxes) on a computed APED spectral model} %purpose
{List\_Type = aped\_fun\_details ("name(id)")} %usage
{create\_aped\_fun, aped\_bib, aped\_bib\_query\_string}

A multi-temperature plasma emission model with a custom
parameterization can be constructed using
\verb|create_aped_fun|.  A particular dataset may be modeled by
a sum of such multi-temperature models -- for example, consider
a three component model:
\begin{verbatim}
   xaped(1) + xaped(2) + xaped(3)
\end{verbatim}
where each \verb|xaped| component introduces N
temperatures-density components,
\begin{verbatim}
   T[i],  n[i], i=0,1,2,...N-1.
\end{verbatim}

In the resulting model spectrum, any given emission line
represents the sum of 3N contributions -- 3 model components,
with N temperature-density components each.

The \verb|aped_fun_details| function can be used to retrieve
all of these separate contributions to each emission line. For
example, the contribution to emission line, k, from
temperature/density component, i, of model component, j, can be
retrieved like so:
\begin{verbatim}
   create_aped_fun ("xaped", p);
   fit_fun ("xaped(1) + xaped(2) + ... + xaped(N)");

 %  let 1 <= j <= N

   info = aped_fun_details ("xaped($j)"$);
   flux = info[i].line_flux[k];
\end{verbatim}

The single required input parameter is a string specifying a
particular instance of an APED model created by
\verb|create_aped_fun|.

The return value is a \verb|List_Type| quantity with one
\verb|Struct_Type| entry for each temperature-density component
of the APED model.  Each structure contains selected model
parameters:
\begin{verbatim}
   struct {density, temperature, line_flux,
           norm, redshift, vturb, metal_abund}
\end{verbatim}
The \verb|line_flux| field is an array of length equal to the
number of emission lines in the APED database. For this reason,
the line indices returned by other isis functions, e.g.
\verb|brightest|, may be used to index into this array.

\begin{verbatim}
EXAMPLE

   % define a spectral model
   create_aped_fun ("xaped", default_plasma_state());
   fit_fun ("xaped(1) + xaped(2)");

   % line index for O VIII Ly alpha 2p~^2P_{3/2} - 1s~^2S_{1/2}
   id = where(trans(O,8,4,1))[0];

   % view database parameters for this emission line
   print(line_info (id));

   % evaluate the spectral model (computing all the line fluxes)
   variable lo, hi, f;
   (lo, hi) = linear_grid (1, 20, 2000);
   f = eval_fun (lo, hi);

   % retrieve flux contribution to this line from the first
   % temperature-density component of xaped(1)
   info = aped_fun_details ("xaped(1)");
   flux0 = info[0].line_flux[ id ];

\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{atoms} %name
{load the atomic database} %purpose
{atoms (Struct\_Type)} %usage
{plasma, db\_push, db\_list, db\_select}

This function loads all the FITS-format atomic data files listed in
the ``filemap'' file specified by the {\tt atomic\_data\_filemap}
field if the database configuration structure.

\begin{verbatim}
Example:
      isis>  s.atomic_data_filemap = "data/filemap";
      isis>  atoms (s);
\end{verbatim}

Although it is not necessary to load the atomic data files, they may
provide more information than is contained in the line and continuum
emissivity tables (e.g. energy level data, transition probabilities,
identification labels for the emission lines, etc. ).
\end{isisfunction}

\begin{isisfunction}
{brightest} %name
{get indices of the k brightest lines in a given list} %purpose
{indices = brightest (k, line-list)} %usage
{line\_em, ratio\_em, create\_aped\_fun}

A plasma emission model must be defined and a model spectrum computed
{\it before} using this function. For the purpose of selecting the
brightest lines, the total flux from each line is summed over all
model components without regard to the relative Doppler-shifts or
line-profile shapes involved.

\begin{verbatim}
Example:
                        % define and compute a model spectrum
load_model("model_dat");
(lo, hi) = linear_grid (1, 25, 6000);
flux = model_spectrum (lo, hi);

                        % find the indices of the
                        % 20 brightest Fe lines
                        % in that model spectrum

b = brightest(20, where(el_ion(Fe)));    % Fe = 26

\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{change\_wl} %name
{Change internal wavelength values for specific lines} %purpose
{change\_wl("filename")} %usage
{plasma, atoms}

This function loads a file containing a list of emission lines
specified by element, ion, and upper and lower energy level indices
along with values for the line wavelength and its uncertainty. The
wavelengths and uncertainties in the file over-write those in the
\isisx memory at run time (the wavelengths in the atomic database
files on disk are {\it not} changed).

This function can be used to correct line wavelengths in the atomic
database using wavelengths measured from observational data.

The wavelength file is ASCII-formatted with these columns
in order from left to right:
\begin{verbatim}
       lambda [Angstrom]
   lambda_err [Angstrom]
proton_number
    ion state
  upper_level
  lower_level
\end{verbatim}
Lines with a \# in column 1 are ignored and may be used
for comments.
\end{isisfunction}

\begin{isisfunction}
{db\_indices}%
{Get indices of currently loaded spectroscopy databases}%
{Integer\_Type[] = db\_indices ()}% usage
{db\_push, db\_pop, db\_select, db\_list, plasma, atoms}

\end{isisfunction}

\begin{isisfunction}
{db\_list}%
{list currently loaded spectroscopy databases}%
{db\_list ([Ref\_Type | File\_Type])}% usage
{db\_push, db\_pop, db\_select, db\_indices, plasma, atoms}

This function produces a numbered list of spectroscopy databases.
Each database is identified by the path to its filemap file.
The currently selected database is indicated by an asterisk.

\begin{verbatim}
EXAMPLE:
  isis> db_list;
  Current database list:
   0 * /nfs/blackhole/d1/ji/ATOMDB/filemap_v2.0.0.rc7
   1   /nfs/cxc/a1/share/atomdb/filemap
\end{verbatim}

If called with a \verb|Ref_Type| argument, the \verb|Ref_Type| will be
assigned a string containing the database list. If called with a
\verb|File_Type| argument, the database list will be written to the indicate
\verb|File_Type|.
\end{isisfunction}

\begin{isisfunction}
{db\_pop}%
{Remove a spectroscopy database from the internal list}%
{db\_pop ([index])}% usage
{db\_push, db\_select, db\_list, db\_indices, plasma, atoms}

This function removes a spectroscopy database from the internal database list.
If no database index is specified, the operation applies to the currently
selected database.

\end{isisfunction}

\begin{isisfunction}
{db\_push}%
{load another spectroscopy database}%
{db\_push (Struct\_Type)}% usage
{db\_pop, db\_list, db\_select, db\_indices, plasma, atoms}

Use this function to load another spectroscopy database by reading its
contents from files. The \verb|Struct_Type| argument should have the same form
as the one used as input to the \verb|plasma| function.

\end{isisfunction}

\begin{isisfunction}
{db\_select}%
{select a spectroscopy database}%
{db\_select (Int\_Type k)}% usage
{db\_push, db\_list, db\_pop, db\_indices, plasma, atoms}

Use this function to select a spectroscopy database from the currently list
displayed by \verb|db_list|.  Subsequent calls to database access functions
(e.g. \verb|create_aped_fun|, etc.) will use atomic data and emissivities from
the selected database.

\end{isisfunction}

\begin{isisfunction}
{define\_group} %name
{register a line group in the internal group list} %purpose
{define\_group (group\_index, line-list)} %usage
{delete\_group, name\_group, save\_group, brightest, trans, el\_ion, wl, flx}.

Note: The main purpose of this internal list is bookkeeping. Because
essentially all line-group functionality is available using line
groups specified by \slang\ array-variables, there is no requirement
to register a group in the internal list.  Because it is not clear
that this additional functionality is useful, it may not be supported
in future releases.

A line group ({\tt line-list}) is specified by an integer array of
line indices. This array may be specified explicitly (e.g. {\tt \[ 27,
39, 415 \]}) or may be generated via a logical expression to the {\tt
where} command (a \slang\ intrinsic function). This function registers
the specified group using the specified integer {\tt group\_index},
replacing any group already registered with that index.

\begin{verbatim}
Example:
  % group 2 = brightest 20 lines from Fe XVI, Fe XVII, Ni XVI, Ni XVII
  %      with wavelengths between 10-12 angstroms or 14-15 angstroms

      define_group(2, brightest(20,
          where( el_ion([Fe, Ni], [16,17])
                           and (wl(10,12) or wl(14,15)))));

  %  The same effect can be achieved using S-Lang array
  %  operations:

  % `all' and `bright' are arrays of integer line-indices:

      all = where( el_ion([Fe, Ni], [16,17])
                           and (wl(10,12) or wl(14,15)));
      bright = brightest(20, all);
      define_group(2,bright);
      define_group(3,all);      % retains the complete list,
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{delete\_group} %name
{delete a line group} %purpose
{delete\_group (group\_index)} %usage
{define\_group}

The line group corresponding to {\tt group\_index} is deleted from the
internal list of defined groups.

\end{isisfunction}

\begin{isisfunction}
{el\_ion} %name
{flag line transitions from selected elements and ions} %purpose
{flag = el\_ion ([proton\_number\_list], [ion\_list])} %usage
{define\_group, trans, wl, flx, where, and, or, not}
\begin{verbatim}
Examples:

                       % indices of lines from Oxygen and Magnesium
o_and_mg = where( el_ion([O,Mg]));  % O = 8, Mg = 12

                       % group 2 = lines from ions VII, IX and XX
idlist = where( el_ion(, [7, 9, 20]));
define_group (2, idlist);

                       % group 1 = lines from Fe XVII, Fe XVIII, Fe XIX
define_group (1, where( el_ion(26, [17:19])));

                       % indices of lines from all elements except Iron
not_fe = where(not(el_ion(Fe)));    % Fe = 26
\end{verbatim}

{\it This function is intended to be used in conjunction with the
\slang\ intrinsic function {\tt where}.}  It returns a character
array of length equal to the number of emission lines in the current
database line list.  If a given line belongs to one of the listed
elements/ions, the corresponding array element is set equal to one,
otherwise the array element is zero.

\end{isisfunction}

\begin{isisfunction}
{flx} %name
{flag line transitions by which occupy a given flux range} %purpose
{flag = flx ([flx\_min], [flx\_max])} %usage
{define\_group, where, and, or, not}

\begin{verbatim}
Examples:
                     % indices of lines brighter than f photons/cm^2/s
above_f = where ( flx(f) );

                     % indices of lines between f1 and f2 photons/cm^2/s
between_f1_f2 =  where ( flx(f1, f2));

\end{verbatim}

{\it This function is intended to be used in conjunction with the \slang\
intrinsic function {\tt where}.} It returns a character array of length
equal to the number of emission lines in the current database line list.  If
a given line falls within the specified flux range (photons cm${}^{-2}$
s${}^{-1}$ for the currently defined model) ($F_{\rm min} \leq F < F_{\rm
max}$) the corresponding array element is set equal to one, otherwise the
array element is zero.

\end{isisfunction}

\begin{isisfunction}
{isis\_linelabel\_hook}
{Reformat line label strings for plotting}
{new\_label = isis\_linelabel\_hook (label)}
{plot\_group, line\_label\_default\_style, latex2pg}

The energy level labels in the APED spectroscopy database are
formatted using \LaTeX-style syntax which must be reformatted for
plotting purposes so that subscripts and superscripts are handled
properly.

If defined in the Global namespace, the function
\verb|isis_linelabel_hook| is used to handle this reformatting.
By default, \verb|isis_linelabel_hook| is defined as
\begin{verbatim}
   public define isis_linelabel_hook (s)
   {
      return latex2pg (s);
   }
\end{verbatim}
where \verb|latex2pg| is a simple parser which can handle
most of the APED database energy-level labels.

To change the way line labels are reformatted, simply provide an
alternate definition for \verb|isis_linelabel_hook|.
\end{isisfunction}

\begin{isisfunction}
{lines\_in\_group} %name
{get indices of lines in a given group} %purpose
{indices = lines\_in\_group (group\_index)} %usage
{line\_em, ratio\_em}

This function retrieves indices of lines belonging to a group registered in
the internal group-list. It simplifies the use of functions which require a
list of line indices as input.

\begin{verbatim}
Example:

  % define a group by a list of line indices
  all = where( el_ion([Fe, Ni], [16,17]) );
  define_group (2, all);

  % retrieve a list of line indices from a group:
  list = lines_in_group(2);

\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{line\_info} %name
{Get data for a single emission line} % purpose
{Struct\_Type s = line\_info (line\_index)} % usage
{page\_group}

This function returns a \slang\ structure defined as
\begin{verbatim}
struct
{
   id, lambda, A, flux, Z, ion, upper, lower, up_name, lo_name
 }
\end{verbatim}

The structure fields give the line index (id), wavelength (lambda)
and Einstein A-value (A), and
identify the ion and energy levels involved (proton number (Z), ionization
state (ion), upper and lower energy level indices (upper/lower) and labels
(up\_name/lo\_name) if available.  The ionization state is the integer
equivalent of the roman numeral; for example, an Fe XVII line would have
{\tt Z=26}, {\tt ion=17}. The total flux from this line in the currently
defined model (photons cm${}^{-2}$ s${}{-1}$) is returned in {\tt flux}.

\end{isisfunction}

\begin{isisfunction}
{line\_label\_default\_style} %name
{Get a structure with the default line labeling style parameters} %purpose
{s = line\_label\_default\_style ()} %usage
{plot\_group, isis\_linelabel\_hook}

The returned structure has the following fields:
\begin{verbatim}

___Field______Type____Default___Definition________________________________
 label_type   int      0        0 for short labels (e.g. Ca XI);
                                1 for long labels (e.g. Ca XI 2p 1s)
char_height   float    1.0
    justify   float    0        0=right, 0.5=centered, 1.0=left
      angle   float   90.0      [degrees]
  top_frac    float    0.6      coordinate of upper endpoint of indicator
                                line, as a fraction of the Y plot-range
bottom_frac   float    0.7      coordinate of lower endpoint of indicator
                                line, as a fraction of the Y plot-range
    offset    float    0.1      spacing of text above upper endpoint of
                                indicator line as a fraction of the
                                indicator line length
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{list\_branch} %name
{List radiative transition branching ratios for an ion} %purpose
{list\_branch (proton\_number, ion)} %usage
{list\_elev}

For each energy level having more than one downward radiative
transition, this function lists the fraction of spontaneous decays
going into each downward transition along with the transition
wavelength (\AA), A-value (s${}^{-1}$), lower level index and line
list index.

\begin{verbatim}
For example:

isis> list_branch (He, 2);                % He II

He II
upper level =    5
lower         lambda       branch       A        index
    3   1.640375e+03   3.3337e-01   3.3690e+07      14
    4   1.640533e+03   6.6663e-01   6.7370e+07      15
 ....
\end{verbatim}

The value $b_{ul}$ given in the {\tt branch} column is defined by
\begin{equation}
    b_{ul} =  { A_{ul} \over \sum_{k=1}^{u-1} A_{uk} }
\end{equation}
where $A_{uk}$ is the Einstein A value for the transition
from upper level $u$ to lower level $k$ and where the ground
state is $k=1$.
\end{isisfunction}

\begin{isisfunction}
{list\_elev} %name
{browse the energy level structure of an ion} %purpose
{list\_elev (proton\_number, ion)} %usage
{plot\_elev}

This command displays a listing of the energy level data for the
specified ion using a user defined pager. The energy level data
includes the level index, excitation energy (eV), statistical weight,
the total spontaneous downward transition rate (s${}^{-1}$), the
number of downward radiative transitions, $nLS$ quantum numbers, and a
name string.

The pager is specified by the {\sc PAGER} environment variable.  If
the {\sc PAGER} variable is not set, {\tt more} is the default.  If
{\tt more} is not found on the command search path, the function will
fail with an error message.
\end{isisfunction}

\begin{isisfunction}
{list\_group} %name
{list the currently defined line groups} %purpose
{list\_group} %usage
{define\_group, name\_group}

This function lists the number of lines in each group registered in
the internal group-list along with the group-name, if one has been
defined using {\tt name\_group}.

\end{isisfunction}

\begin{isisfunction}
{name\_group} %name
{Define a mnemonic name for a group of lines} %purpose
{name\_group (group\_index, "group-name-string")} %usage
{define\_group, list\_group}
This function is used to provide a mnemonic name for a group of lines
registered in the internal group-list.
\begin{verbatim}
Example:
    name_group (3, "Bright Fe XVII lines");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{oplot\_lines} %name
{over-plot line transitions on an energy level diagram} %purpose
{oplot\_lines (proton\_number, ion, line\_list, [style])} %usage
{plot\_elev, [o]plot\_elev\_subset}.

This function over-plots the line transitions in {\tt line\_list} on an
existing energy level diagram; {\tt line\_list} may be a single line index
or an array of line indices.

\begin{verbatim}
Example:
       % plot an energy level diagram showing how the 10 brightest
       % Fe XVI lines form (assuming a spectral model has been computed)

     Fe = 26;
     plot_elev (Fe,16);
     bright_fe16 = brightest (10, where(el_ion(Fe,16)));
     oplot_lines(Fe,16, bright_fe16);

\end{verbatim}

Repeated invocations of {\tt oplot\_lines} will automatically switch
line styles to help distinguish the overlaid line transitions.
Depending on the current setting [ see {\tt style} ] either colors or
line styles (e.g. solid vs. dashed) are used to distinguish overlaid
data sets. To override the automatic style changes, the style index
can be specified explicitly for each plot. Alternatively, {\tt
plot\_auto\_color} can be used to disable the automatic style changes.
\end{isisfunction}

\begin{isisfunction}
{page\_group} %name
{browse the data for lines in a given group} %purpose
{page\_group (group\_index or line\_list)} %usage
{plot\_group, trans, el\_ion, wl, flx}

Line data for the specified lines is presented using a user-defined pager
program. For each line, the listing provides these values:
\begin{verbatim}
  Line index
  Wavelength [Angstrom]
  Element name
  Ion state (by charge or Roman numeral)
  Einstein A [1/s]
  Flux [photons/s/cm^2]
  Energy level names and indices
\end{verbatim}
The integer line index can be used to refer to a specific
line in other commands e.g. {\tt plot\_group}

An asterisk (*) by the wavelength indicates that emissivity data for
that line is loaded.  The flux is computed using the currently defined
spectral model.  If no model is defined, the flux is listed as zero.

The pager is specified by the {\sc PAGER} environment variable.  If
the {\sc PAGER} variable is not set, {\tt more} is the default.  If
{\tt more} is not found on the command search path, the function will
fail with an error message.
\end{isisfunction}

\begin{isisfunction}
{plot\_elev} %name
{plot the energy level diagram of an ion} %purpose
{plot\_elev (proton\_number, ion)} %usage
{list\_elev}

An LS coupling energy level diagram is plotted using the current
format settings for color, line style, etc. This function requires
that LS coupling quantum numbers be available for all energy levels.

\end{isisfunction}

\begin{isisfunction}
{plot\_elev\_subset} %name
{plot a subset of the energy level diagram of an ion} %purpose
{[o]plot\_elev\_subset (proton\_number, ion, line\_list)} %usage
{plot\_elev, oplot\_lines}
\index{oplot\_elev\_subset@{\tt oplot\_elev\_subset}}

This function [over]plots an energy level diagram consisting of all
energy levels involved in the given list of line transitions ({\tt
line\_list}).  It can be used to examine a subset of the available
energy levels or to generate a color-coded energy level diagram.

\end{isisfunction}

\begin{isisfunction}
{plot\_group} %name
{over-plot a spectrum with all lines belonging to a particular group} %purpose
{plot\_group(group [, color\_index [,label\_style [, redshift]]])} %usage
{plot\_linelist, line\_label\_default\_style, isis\_linelabel\_hook, page\_group, save\_group}

All lines in the specified group are displayed on the current plot,
meaning that a vertical line is plotted at the line wavelength along
with a text label.  A line group may be specified by an array of line
indices or by giving the index of the group in the internal
group-list.

This assumes that the currently active plot window already contains a
spectrum plot.

If {\tt color\_index} is not specified, the current plot-color is
used; if {\tt color\_index} is specified, the color applies only to
the line labels and is not retained in the internal plot format
parameter structure. The third argument is used to specify formatting
information for the line labels.  If this argument is an integer, it
specifies whether short (0) or long (1) text labels should be used.
This argument may also be a structure containing multiple style
parameters; see {\tt line\_label\_default\_style} for details.

To plot lines at some Doppler shifted wavelength, specify the
redshift value defined as
\begin{equation}
 {\rm redshift} = z = {\lambda_{\rm observed} \over \lambda_{\rm emitted}} - 1
\end{equation}

\begin{verbatim}
Example:

plot_group (2);          % plot group 2 with short labels

plot_group (where(el_ion(Mg)), 2, 1);   % plot Mg lines using long
                                        % labels in color 2
\end{verbatim}

Similarly, to obtain red line labels which are 25\% smaller and tilted at a 45
degree angle with an indicator line extending all the way to the plot border,
use
\begin{verbatim}
      s = line_label_default_style ();
      s.char_height = 0.75;
      s.angle = 45;
      s.bottom_frac = 0.0;
      plot_group (g, red, s);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{plot\_linelist} %name
{over-plot a spectrum with a user-provided line list} %purpose
{plot\_linelist (lambdas, labels, [, color\_index [,label\_style [, redshift]]])} %usage
{line\_label\_default\_style, isis\_linelabel\_hook, page\_group, save\_group}

This function is essentially the same as \verb|plot_group|
except that the line wavelengths and labels are provided
explicitly by the user rather than being drawn from the
spectroscopy database.

\end{isisfunction}

\begin{isisfunction}
{save\_group} %name
{save line parameters to an ASCII file} %purpose
{save\_group (group\_index or line\_list, filename)} %usage
{page\_group}
A list of lines may be specified using a \slang\ array-variable
or by specifying the index of a group in the internal group-list.
Repeated saves to the same filename append data to the file
rather than overwriting it.
\begin{verbatim}
  Example:
     fe17 = where (el_ion(Fe,17));
     save_group (fe17, "fe17_lines.txt");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{trans} %name
{flag line transitions from a given ion} %purpose
{flag = trans ([proton\_number[, ion\_number [, upper\_list[, lower\_list]]]])} %usage
{define\_group, el\_ion, wl, flx, where, and, or, not}
\begin{verbatim}
Examples:

            % g = all lines
g = where( trans());
            % g = Neon line list
g = where( trans(Ne));
            % g = Ne IX lines
g = where( trans(Ne, 9));
            % g = Ne IX lines from levels 20-30 downward
g = where( trans(Ne, 9, [20:30]));
            % g = Ne IX lines from levels 20-30 down to levels 1-5
g = where( trans(Ne, 9, [20:30], [1:5]));
            % g = Ne IX lines down to levels 1-5
g = where( trans(Ne, 9, , [1:5]));

\end{verbatim}

{\it This function is intended to be used in conjunction with the
\slang\ intrinsic function {\tt where}.}  It returns a character
array of length equal to the number of emission lines in the current
database line list.  If a given line belongs to one of the listed
elements/ions, the corresponding array element is set equal to one,
otherwise the array element is zero.

\end{isisfunction}

\begin{isisfunction}
{unblended} %name
{get indices of unblended lines in a given list} %purpose
{indices = unblended (frac, wl\_sep, allowed\_type, line-list)} %usage
{page\_group, el\_ion, line\_em, ratio\_em}

A line with wavelength $\lambda_k$ is defined to be ``unblended'' if the
flux from the line of interest dominates the total flux from nearby {\it
contaminating} lines.  More precisely, the criterion is that $\sum_{j
\neq k} F(\lambda_j) < {\tt frac}\times F(\lambda_k)$ where the summation
extends over all {\it contaminating} lines with wavelength $\lambda_j$
within $\pm {\tt wl\_sep}\lambda_k$ of the line of interest ($\lambda_k$).
The blend type {\tt allowed\_type} specifies which lines are to be
considered contaminants.

{\tt allowed\_type = 0} indicates that wavelength spacing is the only
determining factor; any other line falling within the stated wavelength band
limit is considered a contaminant. {\tt allowed\_type = SAME\_ELEM} means
that lines from the same element are not considered contaminants and are
excluded from the summation over $j$.  Similarly, {\tt allowed\_type =
SAME\_ION} means lines from the same ionization state are not considered
contaminants. To find lines free of blends with any ion of any element, use
{\tt allowed\_type = SAME\_ELEM \& SAME\_ION}.

Note that, because this function requires line fluxes, a spectrum
model must be computed {\it before} using it.

\begin{verbatim}
Example:
                     % define and compute a model spectrum
load_model("model_dat");
(lo, hi) = linear_grid (1, 25, 6000);
flux = model_spectrum (lo, hi);

                    % find the indices of the
                    % 100 brightest lines between 1-100 Angstrom
                    % in that model spectrum

b = brightest (100, where(wl(1,100)));

                    % lines with < 10% "contamination"
                    % from other elements
                    % within +/- 0.001*lambda

ue = unblended (0.1, 0.001, SAME_ELEM, b);

                    % lines for which > 90%
                    % of the flux within +/- 0.001*lambda
                    % comes from a single ion of a single
                    % element:

uei = unblended (0.1, 0.001, SAME_ELEM & SAME_ION, b);

\end{verbatim}

For the purpose of selecting unblended lines, the total flux from each line
is summed over all model components without regard to the relative
Doppler-shifts or line-profile shapes involved. In particular, the current
implementation of this function does not support searching for unblended
lines in models which have components at significantly different redshifts;
wavelength separation is always determined using the rest-wavelength.
\end{isisfunction}

\begin{isisfunction}
{wl} %name
{flag line transitions from a given wavelength range} %purpose
{flag = wl ([min\_wavelen], [max\_wavelen])} %usage
{page\_group, where, and, or, not}

\begin{verbatim}
Examples:

% indices of all lines longward of 20 angstroms
  above_20 = where(wl(20));

% indices all lines shortward of 30 angstroms
  below_30 = where(wl(,30));

% indices Fe XVI lines between 10 and 15 angstroms
  fe_16_subset = where( el_ion(26,16) and wl(10,15));
\end{verbatim}

{\it This function is intended to be used in conjunction with the
\slang\ intrinsic function {\tt where}.}  It returns a character
array of length equal to the number of emission lines in the current
database line list.  If a given line's rest wavelength lies inside the
specified wavelength range ($\lambda_{\rm min} \leq \lambda < \lambda_{\rm
max}$) the corresponding array element is set equal to one, otherwise the
array element is zero.
\end{isisfunction}

\newpage
\section{Access to the Plasma Emissivity Database}
\label{sec:plasma-db}

The emissivity database contains theoretical models of the state of an
emitting plasma as a function of its physical state variables.  The
standard emissivity database is generated for conditions of
collisional ionization equilibrium.  Although \isisx is designed to
make it possible to work with other databases (e.b. photoionized
plasmas), at this writing the collisional ionization database is the
only one available.

In collisional equilibrium, the primary physical state variables are
the electron temperature $T$ and the electron density $n$.  Observed
line intensities and line ratios may be used to infer the temperature
and density (or distribution of temperatures and densities) in the
emitting plasmas.  To facilitate this analysis, \isisx provides
several functions to manipulate the line emissivity tables.

{\tt line\_em} retrieves the emissivity of a single line (or the sum
over lines in a group) as a function of density and/or temperature.
{\tt ratio\_em} generates line (or line group) ratios as a function of
density and/or temperature.  Details of the ionization balance as a
function of temperature can be examined using {\tt ion\_bal} and {\tt
ion\_frac}.  Each of these functions returns arrays of emissivities or
ion-fractions when can then be plotted ({\tt [o]plot}) or used in
computations via the \slang\ array-oriented mathematical operators.

For information on computing spectral models see \S\ref{sec:spectral_models}.

\begin{isisfunction}
{db\_grid} %name
{Returns the density and temperature grid used by the spectroscopy database} %purpose
{Struct\_Type = db\_grid ([file | Struct\_Type])} %usage
{plasma, [v]list\_db}

\verb|db__grid| returns a structure of the form
\begin{verbatim}
  s = struct {temp, dens}
\end{verbatim}
whose fields are arrays giving the temperature [Kelvin] and
electron density [cm$^{-3}$] grids used to compute emissivities
in the spectroscopy database.

If no argument is given, the grid used by the currently loaded
database is returned.

\end{isisfunction}

\begin{isisfunction}
{free\_alt\_ioniz} %name
{Free memory for alternate ionization balance table} %purpose
{free\_alt\_ioniz ()} %usage
{load\_alt\_ioniz}

If an alternate ionization balance table is loaded, it is used to
re-scale the line and continuum emissivities.  Freeing the alternate
ionization balance table reverts to the ionization balance that was
used to generate the emissivity tables (no re-scaling is then
performed).

\end{isisfunction}

\begin{isisfunction}
{get\_abundances} %name
{Get abundance table values} %purpose
{Struct\_Type = get\_abundances ([id | name]);} %usage
{set\_abund, list\_abund, add\_abundances}

This function returns a structure with fields \verb|Z[]|,
\verb|abun[]| and \verb|name| containing the proton number of
each element, its abundance and the name of the abundance
table, respectively.  The abundance table may be specified
either by the name or numerical index shown in the listing
produced by \verb|list_abund|. If no table is specified, the
current default table is returned. The abundance values are
normally given as log cosmic abundance by number, relative to
Hydrogen = 12.0.

\end{isisfunction}

\begin{isisfunction}
{get\_contin}
{get continuum contributions by ion}
{p = get\_contin (lo, hi, temp, [dens], [Z], [ion])}
{plasma, line\_em}
This function provide access to the continuum emissivity tables in the
spectroscopy database.

\begin{verbatim}
  lo = bin low edge [Angstrom]
  hi = bin high edge [Angstrom]
temp = electron temperature (K)
dens = electron density [cm^(-3)] [default=1.0]
   Z = proton number
 ion = ion state (1, 2, ... Z+1)
\end{verbatim}

For the specified electron temperature, this function returns the
continuum spectral contribution ({\tt photon cm${}^3$ sec${}^{-1}$})
vs. wavelength (\AA) for the true continuum ({\tt true}), which is the
sum of Bremsstrahlung, radiative recombination and two-photon
emission, and the pseudo-continuum due to weak line emission ({\tt
pseudo}) using the input wavelength grid.

These spectra are organized in a structure defined by
\begin{verbatim}
struct
{
   true, pseudo
}
\end{verbatim}
(each structure component is a \slang\ floating point
array of length $N$).

If the electron density is not specified, the default value is for a
low-density coronal plasma (or whatever is available in the database
files). If a particular element is specified (by proton number {\tt
Z}) the result contains the continuum contributions for that element
only (summed over ions), otherwise, the result will be summed over all
available elements. Similarly, if a specific ion is specified (by
proton number {\tt Z} and ionization state {\tt j}), the result
contains the contribution for that ion only.
\begin{verbatim}
Example:

   plasma (aped);                        % initialize the database

   (lo, hi) = linear_grid(1,20,5000);    % define a wavelength grid
   p = get_contin (lo, hi, 2.e6);        % get continua for T=2.0e6 K
   hplot(lo, hi, p.true);                % plot the true continuum
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{ion\_bal} %name
{get ion fractions at a specified temperature} %purpose
{(ion, frac) = ion\_bal (proton\_number, temp, [ioniz\_table\_id])} %usage
{ion\_frac, load\_alt\_ioniz}
The ion fractions are normalized so that the sum over ions of a given
element is unity.
\begin{verbatim}
          temp = input array of temperatures [K]
          frac = output array of ion fractions
           ion = output array of ion states
                 (1 = neutral, 2 = once ionized, etc.)
ioniz_table_id = index of ionization table (0=std or 1=alt)
\end{verbatim}
The ionization table index is used only if more than one ionization
table is loaded (see also {\tt load\_alt\_ioniz}); the default is to use
the standard table ({\tt ioniz\_table\_id = 0}).
\end{isisfunction}

\begin{isisfunction}
{ion\_frac} %name
{get ion fraction vs. temperature} %purpose
{frac = ion\_frac (proton\_number, ion, temp, [ioniz\_table\_id])} %usage
{ion\_bal, load\_alt\_ioniz}
The ion fractions are normalized so that the sum over ions of a given
element is unity.
\begin{verbatim}
            temp = input array of temperatures [K]
            frac = output array of ion fractions
  ioniz_table_id = index of ionization table (0=std or 1=alt)
\end{verbatim}
The ionization table index is used only if more than one ionization
table is loaded (see also {\tt load\_alt\_ioniz}); the default is to use
the standard table ({\tt ioniz\_table\_id = 0}).
\end{isisfunction}

\begin{isisfunction}
{line\_em} %name
{Compute line-group emissivity vs. temperature and/or density} %purpose
{emis = line\_em (l\_array, [temp] [,dens])}%usage
{group, ratio\_em, line\_em1, get\_contin}
\begin{verbatim}
_Variable_____Size______Value____________________________________
  l_array      nl      Input 1-D array of line indices
     temp      nt      Input 1-D array of temperatures [K]
     dens      nd      (optional) Input 1-D array of densities [cm^(-3)]
     emis   (nt)x(nd)  Output 1-D or 2-D emissivity array.
\end{verbatim}
This function computes
\begin{equation}
   {\tt emis} =
   \varepsilon\left( T,\rho\right) =
   \sum_k \varepsilon \left(T, \rho; k\right)
\end{equation}
where $\varepsilon \left(T ,\rho; k\right)$ is the emissivity of emission
line $k$ at temperature $T$ and density $\rho$ with elemental abundance and
ionization balance factors included.  When the density array is absent (the
lowest available density data is used as the default) and when either $nt=1$
or $nd=1$, {\tt emis} is a 1-D array of size max($nt,nd$). When both $nt>1$
and $nd>1$, {\tt emis} is a $nt\times nd$ 2-D array with the first index
corresponding to density and the second to temperature.  For example,
\begin{verbatim}
     t=10.0^[6.0:7.0:0.05];      % temperature array, nt=21
                                 % log-spacing
     d=10.0^[11.0:13.0:0.25];    % density array, nd=9
                                 % log-spacing

     k = lines_in_group(2);      % list of lines in group 2

     em2 = line_em(k,t,d);       % em2 = 2-D emissivity array
                                 % with dimension [9,21]

     y = em2[3,7];               % line emissivity at
                                 % density d[3], temperature t[7],
                                 % summed over lines in group 2.

     emt = line_em(k[2], t, d[4]);  % emt = 1-D emissivity array
                                    % with dimension [21]

     z = emt[9];                 % z = emissivity line line k[2] at
                                 % density d[4], temperature t[9]
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{line\_em1} %name
{Retrieve line emissivity table} %purpose
{(emis, temp, dens) = line\_em1 (line\_index)}%usage
{group, ratio\_em, line\_em, get\_contin}

This function is similar to {\tt line\_em} except that it returns the
line emissivity values tabulated in the spectroscopy database rather
than interpolating those values onto a user-specified
temperature/density grid.  For a particular line, it returns three
arrays $\varepsilon_i$, $n_i$, $T_i$, of size $N$, (where $N$ is the
number of $(n,T)$ points available in the database) giving the
emissivity as a function of density and temperature:
\begin{equation}
  \varepsilon_i (n_i, T_i),  i = 1,2,..N
\end{equation}
\end{isisfunction}

\begin{isisfunction}
{list\_abund} %name
{List the available cosmic abundance tables} %purpose
{list\_abund ([verbose]);} %usage
{set\_abund, get\_abundances}

The abundance table in the spectroscopy database may contain
several sets of elemental abundances.  This function lists the
available abundance tables providing an integer index which is
used in function arguments to select a particular table.  By
default, the optional argument is \verb|verbose=0| so that only
the names of the tables are listed. Set \verb|verbose=1| to see
the abundance values listed as well.

\end{isisfunction}

\begin{isisfunction}
{list\_db} %name
{List density and temperature range covered by the spectroscopy database} %purpose
{list\_db ([file | Struct\_Type])} %usage
{plasma, vlist\_db, db\_grid}

\verb|list_db| generates a short listing showing only the available
range of density and temperature;  \verb|vlist_db| generates a
more verbose listing showing all available density-temperature points.

If no argument is given, the grid used by the currently loaded
database is listed.

\end{isisfunction}

\begin{isisfunction}
{vlist\_db} %name
{List density and temperature range covered by the spectroscopy database} %purpose
{vlist\_db ([file | Struct\_Type])} %usage
{plasma, list\_db, db\_grid}
Similar to \verb|list_db|, but provides a more detailed listing.
\end{isisfunction}

\begin{isisfunction}
{load\_alt\_ioniz} %name
{Load an alternate ionization balance table} %purpose
{load\_alt\_ioniz (file)} %usage
{free\_alt\_ioniz}

Use this function to specify an alternate ionization balance table.
Such a table may be used to re-scale the plasma emissivities as a simple way
of seeing the effect of an alternate ionization balance calculation
without repeating a complete spectrum synthesis calculation.

By default, when two ionization balance tables are loaded, all
emissivities are re-scaled using the alternate ionization balance table.
The emissivities are re-scaled so that
\begin{equation}
  \varepsilon_1 = { X_1(T; Z,q) \over X_0(T; Z,q) } \varepsilon_0
\end{equation}
where $\varepsilon_0$ is the tabulated emissivity computed using
ionization fraction $X_0 (T; Z, q)$ for ion $(Z, q)$ at temperature $T$ and
where $X_1 (T; Z, q)$ is the ionization fraction from the alternate
ionization balance table.

To revert to the standard ionization balance table, delete the
alternate table using {\tt free\_alt\_ioniz}.
\end{isisfunction}

\begin{isisfunction}
{plasma} %name
{load the emissivity database} %purpose
{plasma (Struct\_Type ~[,density\_range ~[, temp\_range]] )} %usage
{atoms, db\_push, db\_list, db\_select, [v]list\_db}
\index{{\tt Use\_Memory}}
\index{Emissivity Database!memory usage}
\index{{\tt Incomplete\_Line\_List}}
\index{Emissivity Database!completeness of wavelength tables}

This function is similar to the {\tt atoms} function and uses the same
database configuration structure.  It causes \isisx to load the atomic
data files and the line and continuum emissivity tables into memory
(actually, because of their size, the continuum emissivity tables are
just scanned so that continua may be quickly retrieved from disk as
needed).

The optional arguments {\tt density\_range} and {\tt temp\_range} are
two element floating point arrays specifying a subset of densities
(cm${}^{=3}$) and temperatures (Kelvin) for which line and continuum
emissivities are to be loaded from the database.

Access to the emissivity tables is usually most efficient if the all
of the tables fit in memory at once (the default mode assumes that
this is the case).  For large databases, however, this may not be
practical.

To support very large line lists, it may be necessary to
increase the size of an internal hash table.  To increase the
size of the table, set the intrinsic variable
\verb|EM_Hash_Table_Size_Hint| to a value at least 25\% larger
than the number of emission lines in your database.

The {\tt Use\_Memory} variable is used to indicate whether
the emissivity tables should be loaded into memory all at once
or should be accessed from disk files as needed:

\begin{verbatim}
  __Use_Memory__    ____Behavior____
     0               Read lines and continua on-demand
     1               Read lines up front, continua on-demand
     2               Read lines on-demand, continua up front
     3               Read lines and continua up front
\end{verbatim}

As long as sufficient memory is available, model computations will
be fastest if all the data is loaded into memory at once
(\verb|Use_Memory=3|, the default), thereby minimizing the number
of relatively slow disk accesses. However, when not making use of
the continuum tables, one might prefer \verb|Use_Memory=1|; by not
loading the continuum tables, database input is faster and the
run-time memory footprint is minimized. On small memory machines,
one might prefer \verb|Use_Memory=0|.

\isisx maintains a lookup table containing a complete list of
all lines in both the atomic database and in the emissivity database.

In order to ensure that this table is complete, \isisx normally scans
the line emissivity tables on input and merges any "new" lines into
the internal tables. However, this step is necessary only if the
spectroscopy database wavelength tables are incomplete (in the sense
that some lines in the emissivity tables are not listed in the
wavelength tables loaded by \isisx). To stop \isisx from carrying out
this (sometimes slow) scanning step, set {\tt Incomplete\_Line\_List =
0}; when this variable is non-zero, input line emissivity tables will
be scanned automatically.

Note that if the scan is not performed and "new" lines are present in
the line emissivity tables, those lines will be ignored and an error
message will be generated.

\end{isisfunction}

\begin{isisfunction}
{ratio\_em} %name
{compute a line-group emissivity ratio vs. temperature and density} %purpose
{ratio = ratio\_em (l1\_array, l2\_array [,temp [,dens]])} %usage
{line\_em}
This function computes
\begin{equation}
R\left( T,\rho\right) = { \varepsilon_1\left( T,\rho\right) \over
\varepsilon_2\left( T,\rho\right)}
\end{equation}
where $\varepsilon_g\left( T,\rho\right)$ is the result of {\tt
line\_em} for line group $g$.
\end{isisfunction}

\begin{isisfunction}
{set\_abund} %name
{Choose a cosmic abundance table} %purpose
{set\_abund (id | name);} %usage
{list\_abund, get\_abundances, atoms, plasma}

The abundance table in the spectroscopy database may contain
several sets of elemental abundances.  This function specifies
an abundance table either by name or by index in the list of
tables generated by {\tt list\_abund}. If the specified
abundance table is different from the one used to generate the
line and continuum emissivity tables, the emissivities are
re-scaled using the specified table.

\end{isisfunction}

\newpage
\section{Defining a Plasma Emission Model}
\label{sec:spectral_models}

The section describes how to define a plasma emission model by summing
line and continuum emissivity components tabulated in the spectroscopy
database. Plasma models may also be obtained using the {\tt XSPEC}
module (see \S\ref{chap:xspec-module}).

After initializing the spectroscopy database (see \S
\ref{sec:atomic-db} and \S \ref{sec:plasma-db}), multicomponent
plasma models may be generated using the function
\verb|create_aped_fun()| (See \S \ref{sec:fitting-data}).

% use {\tt load\_model} and/or {\tt edit\_model} to
% define a multi-component plasma model.  The current model parameters
% may be browsed with {\tt list\_model} or saved to a disk file using
% {\tt save\_model}.

% Similarly, multiple plasma models may be created using the
% functions \verb|mt_def_model|, \verb|mt_calc_model|.  These models
% are represented as instances the ISIS-intrinsic data type,
% \verb|Model_Type|.  Such models may be saved as ASCII files
% and reloaded using the functions \verb|mt_save_model|,
% \verb|mt_load_model|.

% After generating a wavelength grid, perhaps using {\tt
% linear\_grid}, the spectrum of this model can be computed using
% {\tt eval\_fun} and fitted using \verb|fit_counts| or
% \verb|fit_flux|.

By default, spectral line profiles are delta-functions; {\tt
use\_thermal\_profile} specifies that a thermal line profile
should be used instead.

\begin{isisfunction}
{append\_model} %name
{Append model components using \slang\ arrays} %purpose
{append\_model (state[]);} %usage
{default\_plasma\_state, model\_spectrum, define\_model}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

This function is identical to the \verb|define_model| function
except that it appends an array of components to an existing model.
If no model has been defined, a new model is created.
See \verb|define_model| for details.
\end{isisfunction}

\begin{isisfunction}
{create\_aped\_fun} %name
{Create a custom fit-function using a multi-component APED spectrum} %purpose
{create\_aped\_fun (name, Struct\_Type [, hook\_ref])} %usage
{plasma, fit\_fun, eval\_fun2, aped\_fun\_details, create\_aped\_line\_modifier, create\_aped\_line\_profile, aped\_line\_modifier\_args, aped\_line\_profile\_args, aped\_hook\_args}
\index{Fitting a spectrum model}
\index{model spectrum, Fitting a}
\index{spectrum model}
\index{spectrum model!custom line profile}
\index{spectrum model!modified line emissivities}
\index{spectrum model!custom ionization balance}
\index{Emissivity Database!fitting a spectrum model}
\index{APED!fitting a spectrum model}

This function creates a custom fit-function which computes a multi-component
APED model. The first argument gives the name of the new fit-function and the
second argument is a \verb|Struct_Type| which defines the number of spectrum
components in the function's fit-parameter list. The values contained in this
structure provide default values for the associated fit parameters. The
optional third argument is used to select specific lines and continua and is
discussed further below.  Further customization can be achieved by
making use of one or more modifier functions as described in the examples
below.

The \verb|Struct_Type| argument has the form of the structure
returned by the \verb|default_plasma_state()| function:
\begin{verbatim}
  struct { norm, temperature, density,
           elem, elem_abund, metal_abund,
           vturb, redshift }
\end{verbatim}
where
\begin{verbatim}
          norm[] = float array of size Num_Components
   temperature[] = float array of size 1 or Num_Components
       density[] = float array of size 1 or Num_Components
          elem[] = NULL or int array of size Num_Elements
    elem_abund[] = NULL or float array of size Num_Elements
   metal_abund = float
         vturb = float
      redshift = float
\end{verbatim}
All components in the resulting model have the same values of
\verb|metal\_abund|, \verb|vturb|, \verb|redshift|, \verb|elem|,
\verb|elem\_abund|.  For detailed definitions of these struct
fields, see \verb|default_plasma_state()|.

EXAMPLE 1:

In the simplest case, a new fit-function can
be generated with one line:
\begin{verbatim}
  create_aped_fun ("xaped", default_plasma_state());
\end{verbatim}
This creates a fit-function called \verb|xaped| which allows
fitting a single temperature APED spectrum.  This function can be
used like any other fit-function; the resulting fit-parameter list
looks like this:
\begin{verbatim}
isis> create_aped_fun ("xaped", default_plasma_state());
isis> fit_fun ("xaped(1)");
isis> list_par;
xaped(1)
 idx  param             tie-to  freeze  value     min   max
  1  xaped(1).norm          0     1         1       0     0
  2  xaped(1).temperature   0     1     1e+07       0     0
  3  xaped(1).density       0     1         1       0     0
  4  xaped(1).vturb         0     1         0       0     0
  5  xaped(1).redshift      0     1         0       0     0
  6  xaped(1).metal_abund   0     1         1       0     0
isis>
\end{verbatim}
Any parameters not explicitly specified will receive reasonable
defaults. Note that by default, all parameters are frozen and the
parameter ranges are unbounded.  To fit such a function
to data, first thaw a few selected parameters and optionally
provide reasonable parameter ranges.

EXAMPLE 2:

Generating multicomponent models is not much more complicated. To
define a model which corresponds to an APED spectrum with 3
temperature components:
\begin{verbatim}
variable n = 3;
variable t = default_plasma_state ();

t.norm = Double_Type[n];
t.norm[*] = 1.0;
t.temperature = 1.e6 + (1.e7 * [1:n])/n;
create_aped_fun ("xaped", t);
\end{verbatim}

This yields a function with the following parameter list:
\begin{verbatim}
  isis> fit_fun ("xaped(1)");
  isis> list_par;
  xaped(1)
 idx  param              tie-to  freeze  value    min   max
  1  xaped(1).norm1          0     1          1      0     0
  2  xaped(1).norm2          0     1          1      0     0
  3  xaped(1).norm3          0     1          1      0     0
  4  xaped(1).temperature1   0     1    4333333      0     0
  5  xaped(1).temperature2   0     1    7666667      0     0
  6  xaped(1).temperature3   0     1    1.1e+07      0     0
  7  xaped(1).density        0     1          1      0     0
  8  xaped(1).vturb          0     1          0      0     0
  9  xaped(1).redshift       0     1          0      0     0
 10  xaped(1).metal_abund    0     1          1      0     0
\end{verbatim}

EXAMPLE 3:

As a more complex example, one could specify an overall metal
abundance of 0.5 solar and specify e.g. Ne, Mg and Fe explicitly:

\begin{verbatim}
t.norm = Double_Type[n];
t.norm[*] = 1.0;
t.temperature = 1.e6 + (1.e7 * [1:n])/n;
t.density = 1.0;
t.metal_abund = 0.5;
t.elem = [Ne, Mg, Fe];
t.elem_abund = [1.0, 3.1, 0.0];
t.redshift = 0.0;

create_aped_fun ("xaped", t);
\end{verbatim}

This produces the following parameter list:
\begin{verbatim}
xaped(1)
 idx  param              tie-to  freeze value   min    max
  1  xaped(1).norm1          0     1         1     0      0
  2  xaped(1).norm2          0     1         1     0      0
  3  xaped(1).norm3          0     1         1     0      0
  4  xaped(1).temperature1   0     1   4333333     0      0
  5  xaped(1).temperature2   0     1   7666667     0      0
  6  xaped(1).temperature3   0     1   1.1e+07     0      0
  7  xaped(1).density        0     1         1     0      0
  8  xaped(1).vturb          0     1         0     0      0
  9  xaped(1).redshift       0     1         0     0      0
 10  xaped(1).metal_abund    0     1       0.5     0      0
 11  xaped(1).abund_Ne       0     1         1     0      0
 12  xaped(1).abund_Mg       0     1       3.1     0      0
 13  xaped(1).abund_Fe       0     1         0     0      0
\end{verbatim}

EXAMPLE 4:

The optional \verb|hook_ref| argument can be used to
indicate that the model should compute only a specified
combination of lines and continua.  It provides
a reference to a function defined as
\begin{verbatim}
  Struct_Type f = hook (id)
\end{verbatim}
where the \verb|id| argument provides the instance of
the current fit-function (e.g. 1 for \verb|xaped(1)|
and 4 for \verb|xaped(4)|) and the returned structure looks like
\begin{verbatim}
  variable f = struct {contrib_flag, line_list}
\end{verbatim}
These struct fields carry the corresponding optional arguments
which are accepted by \verb|mt_calc_model| and
\verb|model_spectrum| (see \verb|model_spectrum| for details).

For example, to generate a function which can compute the
line-spectrum of a single ion (with model continuum excluded), we
can do the following: In addition to the above \verb|Struct_Type|
parameter definitions, we first provide an appropriate hook
function:

\begin{verbatim}

% we want to look at Ne and Mg lines:
variable Ne_Lines = where (el_ion(Ne,10));
variable Mg_Lines = where (el_ion(Mg,12));
variable Contrib_Flag = MODEL_LINES;

define xaped_hook (id)
{
   variable f = mt_model_qualifier();
   f.contrib_flag = Contrib_Flag;

   if (id == 1) f.line_list = Ne_Lines;
   else if (id == 2) f.line_list = Mg_Lines;
   else f = NULL;

   return f;
}

create_aped_fun ("xaped", t, &xaped_hook);
\end{verbatim}

With this definition, \verb|xaped(1)| will compute the Ne~X line
spectrum and \verb|xaped(2)| will compute the Mg~XII line
spectrum.  Note that the global variable \verb|Contrib_Flag|
defined in this example provides a mechanism to alter the behavior
of both functions. without changing \verb|xaped_hook| or defining
a new function via \verb|create_aped_fun|.

EXAMPLE 5:

In some applications, it may be useful to modify selected line
emissivities according to a user-defined function. When this
user-defined function has adjustable parameters, it may be
useful to allow those parameters to vary during a fit.

For example, suppose we've defined a custom APED spectral model
as defined above:
\begin{verbatim}
  create_aped_fun ("xaped", template_struct);
\end{verbatim}

To adjust the emissivity of selected spectral lines, we can
write a \slang\ function of the form:
\begin{verbatim}
  define line_emis_modifier (params, line_id, state, emis)
  {
     variable info = line_info(line_id);
      %
      % ... modify the emissivity of selected emission lines ...
      %
     return emis;
  }
\end{verbatim}
This function accepts an array of parameters, an integer line
index, a structure containing plasma state information,
and the value of the line emissivity for the current plasma state.
The function should return a
new value for the line emissivity.
The plasma state structure has the form form:
\begin{verbatim}
   state = struct {temperature, ndensity}
\end{verbatim}
where \verb|temperature| is the Kelvin temperature and \verb|ndensity| is the
number density in \verb|cm^-3|. This function will be called while the
\verb|xaped| function is being computed and its adjustable parameters will be
included in the fit.

To enable this function to perform these tasks, we must register it as a
line-modifier function:
\begin{verbatim}
  create_aped_line_modifier ("modifier", &line_emis_modifier, ["a", "b", "c"]);
\end{verbatim}
Note that we have provided a name for the function and each of
its parameters.  These names will appear in the output of
\verb|list_par|.

To invoke this helper function, we specify a fit-function using
the syntax:
\begin{verbatim}
   fit_fun ("xaped(1, modifier(1))");
\end{verbatim}
This syntax is a generalization of the ``operator function''
syntax (see \verb|set_function_category|).  At run-time, the
helper function \verb|modifier(1)| is evaluated and returns
values that are interpreted by the \verb|xaped| model function.
With this model definition, the list of fit parameters looks
something like:
\begin{verbatim}
xaped (1, modifier(1))
 idx  param             tie-to  freeze   value     min     max
  1  modifier(1).a          0     0          0       0       0
  2  modifier(1).b          0     0          0       0       0
  3  modifier(1).c          0     0          0       0       0
  4  xaped(1).norm          0     1          1       0       0
  5  xaped(1).temperature   0     1      1e+07       0       0
  6  xaped(1).density       0     1          1       0       0
  7  xaped(1).vturb         0     1          0       0       0
  8  xaped(1).redshift      0     1          0       0       0
  9  xaped(1).metal_abund   0     1          1       0       0
\end{verbatim}

The \verb|modifier| function may require additional user-defined data to
perform the necessary computations. One solution to this problem is to store
the additional data in global variables, but this is sometimes inconvenient
because the implementation of the \verb|modifier| function then depends on
symbols with global scope.

An alternative is to have additional user-defined arguments passed to the
modifier function when it is called.  The advantage to this approach is that
the line modifier function can be defined without referring to global
variables.

For example, suppose we want to pass 2 additional arguments to the line
modifier function.  First, write a line modifier function that handles the
additional arguments:
\begin{verbatim}
  define my_mod (params, line_id, state, emis, extra1, extra2)
  {
     %... perform calculation...
     return emis;
  }
\end{verbatim}
Then, declare the number of extra arguments (2) in the call to
\verb|create_aped_line_modifier|:
\begin{verbatim}
 create_aped_line_modifier ("mod", &my_mod, ["X", "Y"], 2);
\end{verbatim}
Now, simply use the extra arguments in the fit-function
definition:
\begin{verbatim}
  fit_fun ("xaped (1, my_mod(1, Value1, Value2))");
\end{verbatim}
When this fit-function is evaluated, the extra arguments provided will be
passed to \verb|my_mod|.  In this case, \verb|my_mod| will be called with
\verb|extra1=Value1| and \verb|extra2=Value2|.

EXAMPLE 6:

In some applications, it may be useful to introduce a user-defined line
profile function. When this user-defined function has adjustable parameters,
it may be useful to allow those parameters to vary during a fit.

User-defined line profile functions can be introduced using a helper function
in a manner similar to that described in the previous example. Because line
profile functions are evaluated a large number of times and are not easily
vectorized, these functions are best implemented in a compiled language. A
user-defined line profile function can be compiled as a shared library and
imported at run-time using the function \verb|load_line_profile_function|.

To register the line profile function as a helper function, use
\begin{verbatim}
  fptr = load_line_profile_function ("example-profile.so", "square");
  create_aped_line_profile ("square_profile", &fptr, ["width"]);
\end{verbatim}
Note that we have provided a name for the function and each of its parameters.
These names will appear in the output of \verb|list_par|.

To invoke this helper function, we specify a fit-function using the syntax:
\begin{verbatim}
   fit_fun ("xaped(1, square_profile(1))");
\end{verbatim}
This syntax is a generalization of the ``operator function'' syntax (see
\verb|set_function_category|).  At run-time, the helper function
\verb|square_profile(1)| is evaluated and returns values that are interpreted
by the \verb|xaped| model function. With this model definition, the list of
fit parameters looks something like:
\begin{verbatim}
xaped (1, square_profile(1))
 idx  param                tie-to  freeze  value     min      max
  1  square_profile(1).width   0     0         0       0        0
  2  xaped(1).norm             0     1         1       0        0
  3  xaped(1).temperature      0     1     1e+07       0        0
  4  xaped(1).density          0     1         1       0        0
  5  xaped(1).vturb            0     1         0       0        0
  6  xaped(1).redshift         0     1         0       0        0
  7  xaped(1).metal_abund      0     1         1       0        0
\end{verbatim}

Note that multiple ``helper'' functions maybe used simultaneously by providing
a comma-separated list of helper functions in the model definition.  For
example:
\begin{verbatim}
fit_fun ("xaped(1, modifier(1), square_profile(1))");
\end{verbatim}

EXAMPLE 7:

In some applications, it may be useful to introduce a user-defined ionization
balance.  This can be achieved by using an ionization balance modifier
function (see \verb|create_aped_ionpop_modifier|). When this user-defined
function has adjustable parameters, it may be useful to allow those parameters
to vary during a fit.

User-defined ionization balance functions can be introduced using a helper
function in a manner similar to that described in the previous examples.
The help function should have the form:
\begin{verbatim}
    define ionpop_modifier (params, state, last_ionpop [, args])
    {
       variable n = _isis_max_proton_number+1;
       variable new_ionpop = Float_Type[n,n];

       return new_ionpop;
    }
\end{verbatim}
To register the ionization balance function as a helper function, use
\begin{verbatim}
  create_aped_ionpop_modifier ("ionpop", &ionpop_modifier, param_names
                    [,num_extra_args]);
\end{verbatim}
Note that we have provided a name for the function and each of its parameters.
These names will appear in the output of \verb|list_par|.

To invoke this helper function, we specify a fit-function using the syntax:
\begin{verbatim}
   fit_fun ("xaped(1, ionpop(1))");
\end{verbatim}
This syntax is a generalization of the ``operator function'' syntax (see
\verb|set_function_category|).  At run-time, the helper function
\verb|ionpop(1)| is evaluated and returns values that are interpreted by the
\verb|xaped| model function. With this model definition, the list of fit
parameters looks something like:
\begin{verbatim}
xaped (1, ionpop(1))
 idx  param                tie-to  freeze  value     min      max
  1  ionpop(1).time            0     0         0       0        0
  2  xaped(1).norm             0     1         1       0        0
  3  xaped(1).temperature      0     1     1e+07       0        0
  4  xaped(1).density          0     1         1       0        0
  5  xaped(1).vturb            0     1         0       0        0
  6  xaped(1).redshift         0     1         0       0        0
  7  xaped(1).metal_abund      0     1         1       0        0
\end{verbatim}

Note that multiple ``helper'' functions maybe used simultaneously by providing
a comma-separated list of helper functions in the model definition.  For
example:
\begin{verbatim}
fit_fun ("xaped(1, ionpop(1), line_profile(1))");
\end{verbatim}

EXAMPLE 8:

Models created by \verb|create_aped_fun| can also be evaluated using the
\verb|eval_fun2| interface, without using \verb|fit_fun| at all.  When one or
more ``helper'' functions are used, the \verb|eval_fun2| arguments associated
with each helper can be obtained by calling the corresponding
\verb|aped_|\$\{\verb|helper|\}\verb|_args| function.

For example, the model computed using
\begin{verbatim}
   fit_fun ("xaped (1, modifier(1))");
   () = eval_counts;
   f = get_model_flux(1).value;
\end{verbatim}
is identical to the model computed using:
\begin{verbatim}
  f = eval_fun2 ("xaped", lo, hi, xaped_pars,
                 aped_line_modifier_args ("modifier", modifier_pars))
\end{verbatim}
assuming matching wavelength grids, \verb|lo|, \verb|hi|, and
parameter arrays, \verb|xaped_pars| and \verb|modifier_pars|.
Any additional arguments to be passed to the modifier should
be supplied after the \verb|aped_line_modifier_args| call, e.g.:
\begin{verbatim}
  f = eval_fun2 ("xaped", lo, hi, xaped_pars,
                 aped_line_modifier_args ("modifier", modifier_pars),
                 mod_arg1, mod_arg2).
\end{verbatim}

Similarly, when the newly created function uses a ``hook'', as
described above, e.g.:
\begin{verbatim}
   create_aped_fun ("xaped", t, &xaped_hook);
\end{verbatim}
the \verb|eval_fun2| arguments associated with that hook can be
obtained by calling \verb|aped_hook_args|:
\begin{verbatim}
  f = eval_fun2 ("xaped", lo, hi, xaped_pars,
                 aped_hook_args (&xaped_hook, xaped_instance));
\end{verbatim}
where \verb|xaped_instance| is the integer argument expected
by \verb|xaped_hook|.

When multiple helper functions are used, all the associated
\verb|eval_fun2| arguments are provided in the obvious way. For
example, the model computed using:
\begin{verbatim}
   fit_fun ("xaped (1, modifier(1), square_profile(1))");
\end{verbatim}
is identical to the model computed using:
\begin{verbatim}
  f = eval_fun2 ("xaped", lo, hi, xaped_pars,
                 aped_line_modifier_args ("modifier", modifier_pars),
                 aped_line_profile_args ("square_profile", profile_pars),
                 aped_hook_args (&xaped_hook, xaped_instance));
\end{verbatim}
assuming \verb|xaped| was defined to take a hook argument and
assuming matching grids and function parameters in each case.

\end{isisfunction}

\begin{isisfunction}
{aped\_ionpop\_modifier\_args}% name
{Return extra arguments needed for {\tt eval\_fun2} call.}%
{args = aped\_ionpop\_modifier\_args (modifier\_name, modifier\_params[][, num\_extra\_args])}%
{create\_aped\_fun, create\_aped\_ionpop\_modifier, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{aped\_line\_modifier\_args}% name
{Return extra arguments needed for {\tt eval\_fun2} call.}%
{args = aped\_line\_modifier\_args (modifier\_name, modifier\_params[] [, num\_extra\_args])}%
{create\_aped\_fun, create\_aped\_line\_modifier, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{aped\_line\_profile\_args}% name
{Return extra arguments needed for {\tt eval\_fun2} call.}
{args = aped\_line\_profile\_args (profile\_name, profile\_params[])}
{create\_aped\_fun, create\_aped\_line\_profile, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{aped\_hook\_args}% name
{Return extra arguments needed for {\tt eval\_fun2} call.}
{args = aped\_hook\_args (Ref\_Type hook, Integer\_Type aped\_fun\_instance)}
{create\_aped\_fun, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{create\_aped\_ionpop\_modifier}%name
{Register an ionization balance modifer function as an APED model helper function} %purpose
{create\_aped\_ionpop\_modifier (name, Ref\_Type [, param\_name\_array [,num\_extra\_args]])} %usage
{aped\_line\_modifier\_args, create\_aped\_line\_profile, fit\_fun, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{create\_aped\_line\_modifier}%name
{Register a line-emissivity modifier function as an APED model helper function} %purpose
{create\_aped\_line\_modifier (name, Ref\_Type [, param\_name\_array [,num\_extra\_args]])} %usage
{aped\_line\_modifier\_args, create\_aped\_line\_profile, fit\_fun, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{create\_aped\_line\_profile} %name
{Register a line profile function as an APED model helper function} %purpose
{create\_aped\_line\_profile (name, Line\_Profile\_Type [, param\_name\_array])} %usage
{load\_line\_profile\_function, aped\_line\_profile\_args, create\_aped\_line\_modifier, fit\_fun, eval\_fun2}

See \verb|create_aped_fun| for details.

\end{isisfunction}

\begin{isisfunction}
{default\_plasma\_state} %name
{Return a structure describing the default CIE plasma state} %purpose
{Struct\_Type = default\_plasma\_state ()} %usage
{create\_aped\_fun}

This function is provided to simplify using the
\verb|define_spectrum| function by returning a template structure
describing the default plasma state.  The user can modify the
fields of the structure before using it, or an array of such
structures, as an argument to the \verb|define_spectrum| function.

The struct fields are defined as follows:
\begin{verbatim}
       norm = [1.0e-14/(4\pi D^2)] \int n_e n_H dV
              where D is the source distance [cm]
temperature = electron temperature (K)
    density = electron density [cm^(-3)]
metal_abund = metal abundance relative to solar
 elem_abund = (optional) array of elemental abundances relative to solar
       elem = (optional) list of element proton numbers;
              size must match the elem_abund array
      vturb = turbulent velocity component [km/s]
   redshift = the redshift
\end{verbatim}
To define the elemental abundances, the value of
\verb|metal_abund| is first applied to all of the elements
heavier than helium.  If present, the abundances in the
\verb|elem_abund| array are assigned to the corresponding
element listed in the \verb|elem| array.

For example:
\begin{verbatim}
isis> s=default_plasma_state();
isis> print(s);
    norm = 1
    temperature = 1e+07
    density = 1
    metal_abund = 1
    elem_abund = NULL
    elem = NULL
    vturb = 0
    redshift = 0
isis>
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{define\_model} %name
{Define a theoretical spectrum model using \slang\ arrays} %purpose
{define\_model (state[]);} %usage
{default\_plasma\_state, model\_spectrum, append\_model, mt\_def\_model, create\_aped\_fun}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

Analogous to \verb|load_model|, this function defines a
multi-component spectrum model using parameters stored in
an array of \slang\ structures, \verb|state[]|.

See \verb|default_plasma_state| for the structure field
definitions.

For example:
\begin{verbatim}
   % Choose the grid to match a data set
   d = get_data_counts (1);

   % Use the default plasma state except with
   % a different temperature, and metal abundance
   % [and with enhanced neon and low iron abundances]
   s = default_plasma_state ();

   s.metal_abund = 0.7;
   s.temperature = 2.4e7;
   s.elem = [Fe, Ne];
   s.elem_abund = [0.1, 3.0];

   define_model (s);
   flux = model_spectrum (d.bin_lo, d.bin_hi);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{edit\_model} %name
{edit current model parameters} %purpose
{edit\_model (["filename"]);} %usage
{load\_model}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

This function uses a text editor to simplify entering and modifying
parameters of a multi-component spectral model.  If no model is
currently specified, it starts the text editor with a blank form
containing only a header to indicate the parameter columns (see {\tt
load\_model} for a detailed description of the input format).  If a
model is already specified, the model parameters are presented for
editing in the format described.

As long as the specified format is adhered to, model components may be
added or removed by adding and deleting lines in the parameter file.

The text editor specified by the {\sc EDITOR} environment variable; if
the environment variable is not set, {\tt vi} is used. When using {\tt
emacs}, the {\tt emacsclient} feature (of {\tt emacs}) can be used to
avoid invoking a new {\tt emacs} process for each edit.

If a filename is specified, the model is saved in that file,
otherwise, a temporary file is generated and is deleted when editing
is finished. If the {\sc TMPDIR} environment variable is set, the
temporary file created for editing will be placed in the indicated
directory.  Otherwise, the temporary file will be placed in the
current directory.
\end{isisfunction}

\begin{isisfunction}
{list\_model} %name
{list parameters defining the current spectral model} %purpose
{list\_model} %usage
{edit\_model, save\_model, load\_model, mt\_list\_model}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

This function lists the parameters defining the current spectral
model using the format described in {\tt load\_model}.
\end{isisfunction}

\begin{isisfunction}
{load\_line\_profile\_function} %name
{load a user-defined line profile function} %purpose
{Line\_Profile\_Type = load\_line\_profile\_function ("library.so", "name")} %usage
{create\_aped\_line\_profile}
\index{User-defined!line profile function}

Here is an example implementation of a user-defined line profile
function that provides a square line profile:
\begin{verbatim}
#include <stdlib.h>
#include <math.h>

#include "isis.h"

/* gcc -shared -fPIC -o example-profile.so example-profile.c */

ISIS_LINE_PROFILE_MODULE(square,g,flux,wl,atomic_weight,mid,
                         params,num_params,options)
{
   double width, lo_edge, hi_edge, frac, xl, xh;
   double *lo, *hi, *val;
   int i, n;

   (void) atomic_weight; (void) num_params; (void) options;

   /* params[0] = \Delta\lambda/\lambda */
   width = params[0] * wl;
   if (width <= 0.0)
     return 0;

   lo_edge = wl - 0.5*width;
   hi_edge = wl + 0.5*width;

   lo = g->bin_lo;
   hi = g->bin_hi;
   val = g->val;
   n = g->nbins;

#define INCREMENT_BIN(i) do { \
        if ((hi_edge < lo[i]) || (hi[i] < lo_edge)) \
          break; \
        xl = (lo_edge < lo[i]  ) ? lo[i] : lo_edge; \
        xh = (  hi[i] < hi_edge) ? hi[i] : hi_edge; \
        frac = (xh - xl) / width; \
        val[i] += flux * frac; } while (0)

   for (i = mid; i >= 0; i--)
     {
        INCREMENT_BIN(i);
     }

   for (i = mid+1; i < n; i++)
     {
        INCREMENT_BIN(i);
     }

   return 0;
}
\end{verbatim}

The \verb|ISIS_LINE_PROFILE_MODULE| macro is used both to
ensure that the correct interface is implemented and to
provide a way for isis to check interface compatibility at
run-time.

\end{isisfunction}

\begin{isisfunction}
{load\_model} %name
{load model parameters from a file} %purpose
{load\_model ("file");} %usage
{edit\_model, save\_model, define\_model, mt\_def\_model, mt\_load\_model}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

For a collisional ionization equilibrium plasma, the file has
this format (numerical values given here are for illustration only):
\begin{verbatim}
  # id   Temp     Density    Abund    Norm    Vturb    redshift
  #      (K)      (cm^-3)                     (km/s)
    1    2.e6     1.e-3      1.0      1.0     200.0    0.0
  #
  # abundances for component 1:
       Si = 0.8   Na = 0.9   Fe = 0.3
  #
    2    3.e6     1.e00      0.4      1.5     150.0    0.0
  #
  # abundances for component 2:
        Si = 0.8   S = 0.9   Ca = 2.1
  #
    3    4.e6     1.e12      1.0      1.5     150.0    0.0
\end{verbatim}
where
\begin{verbatim}
    Temp = electron temperature [K]
 Density = electron density [cm^(-3)]
   Abund = metal abundance relative to solar
    Norm = [10^(-14)/(4\pi D^2)] \int n_e n_H dV
           where D is the source distance [cm]
   Vturb = turbulent velocity component [km/s]
redshift = the redshift
\end{verbatim}
Lines with a \# symbol in column 1 are ignored and may be used
for comments.  For a more precise definition of {\tt Vturb},
see {\tt use\_thermal\_profile}.

For each model component, any elemental abundances which differ from the
value given in the {\tt Abund} column may be listed separately on lines
immediately following the line defining the temperature and density.
Individual elements are specified using their 2 character chemical
abbreviation; unrecognized abbreviations are ignored.  For example, to set
the Iron abundance to 0.25 and all the other elements to 0.6, specify {\tt
Abund = 0.6} with {\tt Fe = 0.25} on the following input line.
\end{isisfunction}

\begin{isisfunction}
{model\_spectrum} %name
{generate a theoretical spectrum model on a given wavelength grid} %purpose
{flux = model\_spectrum (binlo, binhi [, contrib\_flag [, line\_list]]);} %usage
{load\_model, edit\_model, linear\_grid, use\_thermal\_profile, create\_aped\_fun, mt\_calc\_model}

% DONT DELETE THIS DOCUMENTATION
{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

If present, the \verb|contrib_flag| argument may have one of
the following values:
\begin{verbatim}
  ___Value________________Meaning________________________
  MODEL_LINES_AND_CONTINUUM  model includes lines and continuum
  MODEL_LINES                model includes line emission only
  MODEL_CONTIN               model includes continuum emission only
  MODEL_CONTIN_PSEUDO        model includes pseudo-continuum only
  MODEL_CONTIN_TRUE          model includes true continuum only
\end{verbatim}

If a \verb|line_list| is specified the computed spectrum
includes line emission only from the specified lines.

The model spectrum is generated by loading emissivity data from the
spectroscopy database, interpolating to the temperature-density
grid specified by the model (see {\tt load\_model} and {\tt
edit\_model}) and computing the emission-measure weighted sum.
More precisely, each bin $[\lambda_{\rm lo}, \lambda_{\rm hi})$
in the result has flux

\begin{eqnarray}
F(\lambda_{\rm lo}, \lambda_{\rm hi}) &=&
\sum_m  N_m \sum_Z X_m(Z) \sum_{q=0}^{Z-1} X_m(Z,q; T_m, n_m) \times\nonumber\\
& & \sum_k^{N(Z,q)}
\varepsilon_{Zqk}(\lambda_{\rm lo}, \lambda_{\rm hi}; T_m, n_m, z_m)
~{\rm photon}\ {\rm cm}^{-2} {\rm s}^{-1}
\end{eqnarray}

where

\begin{equation}
\varepsilon_{Zqk}(\lambda_{\rm lo}, \lambda_{\rm hi}; T, n, z) =
\varepsilon_{Zqk}(T,n) \int_{\lambda_{\rm lo}}^{\lambda_{\rm hi}}
\D\lambda~
\phi(\lambda - (1 + z)\lambda_{Zqk}).
\end{equation}

In the expression for the flux in each bin, we have summed over model
components $m$, each with normalization $N_m = \int n_e n_H~\D V /(4\pi D^2)$,
temperature $T_m$, density $n_m$, redshift $z_m$, elemental abundances
$X_m(Z)$ and ionization balance fraction $X_m(Z,q; T_m, n_m)$. Each ion $q$
of element $Z$ has $N(Z,q)$ emission lines $\lambda_{Zqk}$.  The
contribution of each emission line to a given spectral bin is determined by
integrating the appropriate (Doppler shifted) line profile function
$\phi(\lambda)$ over the width of the specified bin.  The emissivity values
$\varepsilon_{Zqk}(T,n)$ are computed by interpolating the emissivities
contained in the spectroscopy database files.

To save the computed spectrum to a file,
\begin{verbatim}
   flux = model_spectrum (lo, hi);
   writecol ("spectrum.out", lo, hi, flux);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{mt\_calc\_model} %name
{Compute the spectrum for a given {\tt Model\_Type}} %purpose
{emis[] = mt\_calc\_model (Model\_Type, lo, hi[, contrib\_flag [,line\_list]])} %usage
{mt\_def\_model, mt\_list\_model,mt\_load\_model, mt\_save\_model,create\_aped\_fun}
This function is almost identical to \verb|model_spectrum| except
that the model is specified by a \verb|Model_Type| instance
instead of the internal model component table.

See \verb|model_spectrum| for details.
\end{isisfunction}

\begin{isisfunction}
{mt\_create\_from\_struct} %name
{Create a {\tt Model\_Type} object from an appropriate {\tt Struct\_Type}} %purpose
{Model\_Type= mt\_create\_from\_struct (Struct\_Type)} %usage
{mt\_def\_model, mt\_list\_model,mt\_load\_model, mt\_save\_model, create\_aped\_fun}

This function is similar to \verb|mt_def_model| except that it
works with a single structure whose fields are arrays.

\end{isisfunction}

\begin{isisfunction}
{mt\_def\_model} %name
{Define a {\tt Model\_Type} using an array of structures} %purpose
{Model\_Type = mt\_def\_model (Struct\_Type[])} %usage
{mt\_create\_from\_struct, mt\_calc\_model, mt\_list\_model,mt\_load\_model, mt\_save\_model,create\_aped\_fun}

This function is almost identical to \verb|define_model| except
that the model definition creates a \verb|Model_Type| instance
instead of being stored in the internal model component table.

See \verb|define_model| for details.
\end{isisfunction}

\begin{isisfunction}
{mt\_list\_model} %name
{List components of a {\tt Model\_Type}} %purpose
{mt\_list\_model (Model\_Type)} %usage
{mt\_calc\_model, mt\_def\_model, mt\_load\_model, mt\_save\_model,create\_aped\_fun}

This function is almost identical to \verb|list_model| except
that the model is specified by a \verb|Model_Type| instance
instead of the internal model component table.

See \verb|list_model| for details.
\end{isisfunction}

\begin{isisfunction}
{mt\_load\_model} %name
{Load an ASCII model file into a {\tt Model\_Type}} %purpose
{Model\_Type = mt\_load\_model (file)} %usage
{mt\_calc\_model, mt\_def\_model, mt\_list\_model, mt\_save\_model, create\_aped\_fun}

This function is almost identical to \verb|load_model| except
that the model is loaded into a \verb|Model_Type| instance
instead of the internal model component table.

See \verb|load_model| for details.
\end{isisfunction}

\begin{isisfunction}
{mt\_save\_model} %name
{Save a {\tt Model\_Type} in an ASCII model file} %purpose
{mt\_save\_model (Model\_Type, file)} %usage
{mt\_calc\_model, mt\_def\_model, mt\_list\_model, mt\_load\_model, create\_aped\_fun}

This function is almost identical to \verb|save_model| except
that the model is specified by a \verb|Model_Type| instance
instead of the internal model component table.

See \verb|save_model| for details.
\end{isisfunction}

\begin{isisfunction}
{save\_model} %name
{save model parameters to a file} %purpose
{save\_model ("file");} %usage
{load\_model, mt\_save\_model}

{\it This interface is obsolete and is no longer supported.
A much more versatile interface is provided by
\verb|create_aped_fun|.}

The model is saved in an ASCII file using the format described in
{\tt load\_model}.
\end{isisfunction}

\begin{isisfunction}
{use\_delta\_profile} %name
{Use a delta-function line profile shape in the theoretical spectrum} %purpose
{use\_delta\_profile} %usage
{use\_thermal\_profile, create\_aped\_fun}

When a delta-function line profile shape is specified, all of the flux
from a spectral line centered at wavelength $\lambda_0$ is added to
the single spectral bin $k$ which contains $\lambda_0$ ($\lambda_{\rm
lo}^k \le \lambda_0 < \lambda_{\rm hi}^k$).

\end{isisfunction}

\begin{isisfunction}
{use\_thermal\_profile} %name
{Use a thermal line profile shape in the theoretical spectrum} %purpose
{use\_thermal\_profile} %usage
{use\_delta\_profile, create\_aped\_fun}
When a thermal line profile shape is specified, the contribution
to each spectral bin $[\lambda_{\rm lo}, \lambda_{\rm hi})$ from
a spectral line with intensity $I_0$ centered at wavelength
$\lambda_0$ is
\begin{equation}
{\rm I}(\lambda_{\rm lo},\lambda_{\rm hi}) = {I_0 \over \sigma \sqrt{2\pi}}
       \int_{\lambda_{\rm lo}}^{\lambda_{\rm hi}} \D\lambda~
       \exp\left[- { (\lambda-\lambda_0)^2 \over 2 \sigma^2} \right]
\end{equation}
where
\begin{equation}
\sigma \equiv {\lambda_0 \over c} \left( {1 \over 2}v_{\rm turb}^2 + {kT \over
m(Z)}\right)^{1/2}
\end{equation}
$T$ is the temperature and $m(Z)$ is the atomic mass of the emitting
ion (which has proton number $Z$).  $v_{\rm turb}$ is the RMS turbulent
velocity width in the emitting plasma.
\end{isisfunction}

\newpage
\section{Generic Plot Functions}
\label{sec:plot-functions}

\isisx provides common plotting functionality through intrinsic functions
which try to relieve some of the burden of selecting plot ranges,
colors, axis labeling, etc.  These intrinsic functions also provide
access to most selected plot customization features (colors, etc.)
with additional support to track details of multiple plots which may
be open simultaneously.

A plot device can be opened using {\tt open\_plot}, {\tt
rplot\_counts}, {\tt
multiplot} or one of the other {\tt *plot*} functions such as {\tt
plot\_data\_counts} or {\tt hplot}. Several plot devices are supported
(see the \pgplot\ documentation for details). The default plot
device may be specified using either the {\sc PGPLOT\_DEV}
environment variable or the {\tt plot\_device()} function. If no
default plot device is specified, the user will be prompted to
select a device.  Note that some plot devices have limited
functionality; some devices do not support color, others do not
support selective erasure of sub-regions of the plot window, etc.
See the \pgplot\ documentation for information on the supported
plot devices and their capabilities.

\isisx supports use of multiple, simultaneous plot windows and devices and
multiple panes per plot window.  If a plot window contains
multiple panes, the plot focus automatically moves to the next
pane each time a new plot is created.  Each plot window maintains
its own format parameters, initialized using generic default
values {\it once} when the plot device is opened. These format
parameters and some of the commands used to set them are:

\begin{verbatim}
______Function(s)__________________Purpose____________
     [xy]range, limits     Set axis ranges
            xlin, xlog     Set axis type (log or linear)
                 label     Set axis labels
                 title     Set plot title
 color, set_data_color     Set plot line color
             linestyle     Set line style (solid, dashed, etc)
            pointstyle     Set point style (dot, circle, etc)
        connect_points     Set point connect style
                           (points only or points + line)
             plot_unit     Select histogram plot x-axis units
             errorbars     Toggle plotting of histogram errorbars
     plot_bin_density,     Select histogram plot type
     plot_bin_integral
\end{verbatim}

{\it All format parameter values are retained for the life of
the associated plot window.}

Axis ranges in a given plot default to display the full range
of the first data set plotted. Axis ranges may be set explicitly
using the {\tt xrange} and {\tt yrange} functions; the {\tt
limits} command forces the next plot to display the full range of
the data.

The size and shape of the plot can be controlled either by using using
the {\tt resize} function or, in X-windows, by interactively resizing
the plot window as you would any other window. Plot annotations are
set using {\tt xylabel}.  Plot text appears in Roman font by default.
Within a text string, the font can be changed (temporarily) by using
the escape sequences $\backslash${\tt fn} (``normal''),
$\backslash${\tt fr} (roman), $\backslash${\tt fi} (italic), and
$\backslash${\tt fs} (script).  Additionally, plot annotations
may be written in a convenient \LaTeX-style format (see
\verb|latex2pg|)

Histogram data from the internal list of data-sets is plotted
using the functions {\tt [o]plot\_data\_*} and {\tt
[o]plot\_model\_*} described in \S\ref{sec:highres} (see also
\verb|rplot_counts|). By default, over-plots automatically change the
color or line-style. The user can over-ride this feature by
specifying the plot style explicitly or by disabling the feature
using {\tt plot\_auto\_color}. Data-sets can be plotted with or
without errorbars (see {\tt errorbars}.  {\tt [o]hplot} provides
an alternate interface for plotting histograms defined by a set of
\slang\ variables.

Arrays of points may be plotted with or without connecting lines and
with or without different symbols for individual data points (see {\tt
[o]plot} and {\tt connect\_points}).  Images may be plotted using
\verb|plot_image|.

For low-level plotting functionality not otherwise provided by
\isisx intrinsics, direct interactive access to most of the \pgplot\
subroutine library is available (see \S\ref{chap:pgplot-module}).

The default plot format may be controlled by modifying fields
of the intrinsic structure {\tt \_isis\_plot} defined in
Table \ref{defaultplot-tbl}:
\index{Plot!changing default format}
\index{changing default plot format}
\index{\_isis\_plot@{\tt \_isis\_plot}}
\begin{table}[ht] \caption{\isisx Default Plot Format}
\label{defaultplot-tbl}
\begin{tabular}{|l|c|p{3in}|}
\hline
Field Name & Default Value & Definition \\
\hline
 x\_unit & {\sc U\_ANGSTROM} & Energy or wavelength unit used for plotting spectra;
 supported values are {\sc U\_ANGSTROM}, {\sc U\_NANOMETER},
 {\sc U\_KEV}, {\sc U\_EV}, {\sc U\_HZ} \\
 use\_bin\_density & 0 & (boolean) 0/1 means spectra are plotted
 as bin-integral/bin-density values \\
 use\_errorbars & 0 & 0 means errorbars off, N means plot every Nth errorbar\\
 logx/logy    & 0 & (boolean) 0/1 means linear/log axis \\
 pointstyle   & -1 & pointstyle; see {\tt pointstyle()} \\
 linestyle    & 1 & line style; see {\tt linestyle()} \\
 color        & 1 & line color; see {\tt color()} \\
 char\_height & 1 & character height \\
 ebar\_term\_length & 0 & length of errorbar terminals \\
 \hline
\end{tabular}
\end{table}
For example, to change the plot defaults to have spectra plotted as
bin-density values in keV energy units, add the lines
\begin{verbatim}
  _isis_plot.use_bin_density = 1;
  _isis_plot.x_unit = U_KEV;
\end{verbatim}
to your \verb|.isisrc| file so that your selected plot format defaults
will be automatically applied when \isisx starts.

\begin{isisfunction}
{charsize} %name
{change the character size used in plot labels} %purpose
{charsize (size)} %usage
{color, label, xylabel}
\index{Plot!character size}
{\tt size} is the normalized character height (1.0 is the default).

Because of an apparent bug in the PGPLOT library, setting
the character size to a value significantly larger than 1.0
may cause the plot axis labels to fall off the edge of the plot.
To workaround this bug, adjust the plot viewport to create
wider plot borders:
\begin{verbatim}
    % The plot device should be open before the viewport
    % size is changed
    () = open_plot (device);

    % Make the viewport somewhat smaller than the default
    % The numbers give xmin, xmax, ymin, ymax in normalized
    % device coordinates which range from 0-1.
    variable v = get_outer_viewport();
    v.xmin = 0.2;
    v.xmax = 0.8;
    v.ymin = 0.2;
    v.ymax = 0.8;
    set_outer_viewport(v);

    % Now create a plot using larger characters:
    charsize(2);
    plot_data_counts(1);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{close\_plot} %name
{Close a plot window} %purpose
{close\_plot[(window\_id)]} %usage
{open\_plot, window}
The window index is the value returned when a new plot device is opened with
{\tt open\_plot}; also, in X-windows, each window frame is normally labeled
with the window index. If window\_id is absent, the currently active plot
window is closed. Note that when generating a Postscript file, the output
file must be explicitly closed in order to generate output, otherwise
an empty file may be generated.
\end{isisfunction}

\begin{isisfunction}
{color} %name
{change the plot color} %purpose
{color (color\_index)} %usage
{line\_or\_color}
\index{Plot!colors}
With the default 16-color configuration of \pgplot, the color indices
correspond to {\tt red=2, green=3, blue=4, light\_blue=5, purple=6,
yellow=7, orange=8, grey=15}.  This mapping may be redefined using functions
in the supplied \pgplot\ module; see the \pgplot\ documentation for further
details.
\end{isisfunction}

\begin{isisfunction}
{connect\_points} %name
{Specify whether or not data points are connected by a line} %purpose
{connect\_points (flag)} %usage
{pointstyle, linestyle}

By default, data points are connected by a line ({\tt flag} = 1; set {\tt
flag} = 0 to omit the connecting line; set {\tt flag} = -1 to
omit the points and draw the line only.  The default is a solid line; an
alternate line style may be selected using {\tt linestyle}.
\end{isisfunction}

\begin{isisfunction}
{cursor} %name
{read plot coordinates from the cursor} %purpose
{cursor( [ \&x, \&y [, \&ch]])} %usage
{xylabel}
With no arguments present, the cursor coordinates are
printed to the screen each time the mouse cursor
is clicked in the plot window.  Press 'q' to quit.

The cursor movement keys may be used for finer positioning control.

The coordinates of the first mouse click or keypress and may also be
returned in variables specified as function arguments. Because the
{\it addresses} of the variables x,y and ch are used, it is necessary
to declare the variables before using them with the {\tt cursor}
function, even in interactive mode.

Caveat: {\it This function does not work as expected if the plot window is
divided into sub-panes.}

\begin{verbatim}

       cursor;        % print cursor coordinates on each mouse-click

       variable x, y, ch;               % declare variables;
       cursor (&x, &y);                 % assign x, y the coordinates of
                                        %     each mouse-click.
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{cursor\_box} %name
{read corners of a box from plot cursor} %purpose
{(xmin, xmax, ymin, ymax) = cursor\_box ();} %usage
{cursor}
This function prompts the user to draw a box with the mouse cursor in a
currently open plot window.  The box is be oriented so that its sides are
parallel to the edges of the plot window.  The x-y coordinates of the box
corners are returned.
\end{isisfunction}

\begin{isisfunction}
{dup\_plot} %name
{open a new plot device using parameters copied from an existing plot} %purpose
{new\_id = dup\_plot (["device" [,window\_id]])} %usage
{open\_plot, window}
This function initializes a new plot device with formatting parameters taken
from an existing plot (e.g. number of plot panes, axis ranges, character size,
line style, etc.).  If no plot device is specified, a default device is used
or prompted for (see {\tt open\_plot} for details).  If no plot window is
specified ({\tt window\_id}) , the parameters of the current plot device are
duplicated.  This is sometimes useful in generating a hardcopy version of a
screen plot which required extensive formatting.
\end{isisfunction}

\begin{isisfunction}
{erase} %name
{erase a plot window} %purpose
{erase[(window\_id)]} %usage
{open\_plot, window}
\index{clear@{\tt clear}}
\index{clear the plot window|see{{\tt erase}}}
\index{Plot!clear the plot window}
\index{Plot!erase the plot window}
This function is also aliased to {\tt clear}.
The plot window to erase is specified by giving the integer index of the
plot window.  The window index is the value returned when a new plot device
is opened with {\tt open\_plot}; also, in X-windows, each window frame is
normally labeled with the window index. If window\_id is absent, the active
pane of the currently active plot window is erased.  If the current device
does not support selective erasure of a sub-pane, the entire window will
be erased (probably - it depends on the device).
\end{isisfunction}

\begin{isisfunction}
{errorbars} %name
{Specify the plotting of histogram errorbars} %purpose
{errorbars (N [,length])} %usage
{plot\_data\_counts}
Error bars are not plotted by default ({\tt N} = 0);
to plot every Nth errorbar, set \verb|N > 0|.
The optional second argument controls the length of errorbar
terminals.  The default is 0.0 (no terminals);  a value
of \verb|length=1.0| gives reasonably sized terminal bars.
Currently, error bars are available only on histogram plots;
the \pgplot\ module functions may be used to get error bars
on other kinds of plots.
\end{isisfunction}

\begin{isisfunction}
{get\_outer\_viewport} %name
{Get current viewport location} %purpose
{Struct\_Type = get\_outer\_viewport ()} %usage
{set\_outer\_viewport, multiplot}

Use this function to get the current location of the
outer viewport in normalized device coordinates.
See \verb|set_outer_viewport| for details.

\end{isisfunction}

\begin{isisfunction}
{get\_plot\_info} %name
{Get information about the current plot format} %purpose
{Struct\_Type = get\_plot\_info ()} %usage
{plot\_open, plot\_close, get\_plot\_options, set\_plot\_options}

This function returns a structure of the form
\begin{verbatim}
   variable p = struct
     {
        xmin, xmax, xlog,
        ymin, ymax, ylog,
        line_width,
        line_color
     };
\end{verbatim}
which provides the current plot limits (\verb|xmin, xmax|,
\verb|ymin, ymax|) and the current line width and line color.
The boolean values \verb|xlog| and \verb|ylog| are non-zero
if the corresponding axis is log-scale.

If no plot device is open, the function returns NULL.
\end{isisfunction}

\begin{isisfunction}
{get\_plot\_options} %name
{Get information about the current plot format} %purpose
{Struct\_Type = get\_plot\_options ()} %usage
{plot\_open, plot\_close, get\_plot\_info, set\_plot\_options}

Most plot options that are used internally by isis are returned
as fields of a structure.

\begin{verbatim}
isis> p = get_plot_options;
isis> print(p);
    xmin = -3.40282e+38         % axis ranges
    xmax = 3.40282e+38
    ymin = -3.40282e+38
    ymax = 3.40282e+38
    xlabel =                    % axis labels
    ylabel =
    tlabel =                    % title
    xopt = BCNST                % axis label styles
    yopt = BCNST
    logx = 0                    % boolean
    logy = 0
    color = 1
    line_style = 1
    line_width = 1
    frame_line_width = 1
    point_style = -1
    connect_points = 1         % boolean
    char_height = 1
    point_size = 1
    ebar_term_length = 0       % length of error-bar terminator
    use_errorbars = 0          % boolean
    use_bin_density = 0        % boolean
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{hplot} %name
{[o]plot a histogram defined by \slang\ arrays} %purpose
{[o]hplot (Struct\_Type | binlo, binhi, value [,line\_style])} %usage
{plot, plot\_data\_counts, window}
\index{ohplot@{\tt ohplot}}
\index{Plot!of arrays}
This function plots or over-plots a histogram described by
three 1-D \slang\ arrays of size N.
\begin{verbatim}
Example:
       edit_model;               % specify spectrum model parameters

       (lo, hi) = linear_grid (1.0, 20.0, 6000);       % generate a grid
       flux = model_spectrum (lo, hi);                 % compute bin values

       hplot (lo,hi,flux);                             % plot
\end{verbatim}

When a single \verb|Struct_Type| argument is given, it should
have fields \verb|bin_lo|, \verb|bin_hi|, \verb|value|.
For example:
\begin{verbatim}
     d = get_data_counts (1);
     hplot (d);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{label} %name
{label plot axes} %purpose
{label ("xlabel", "ylabel", "title")} %usage
{xlabel, ylabel, title, xylabel, latex2pg}
\index{Plot!axis labels}
Specifies text strings to be used for the plot title and axis labels.
To add a plot title only, use {\tt title}.
\end{isisfunction}

\begin{isisfunction}
{latex2pg} %name
{Translate strings from \LaTeX format to PGPLOT format} %purpose
{String\_Type = latex2pg (String\_Type)} %usage
{xylabel, xlabel, ylabel, title, label}
\index{Plot!\LaTeX strings}

This function simplifies creating plot annotations which contain
Greek symbols, superscripts and subscripts.  It translates strings
written in a convenient \LaTeX-style format into a format which is
understood by PGPLOT.  For example:
\begin{verbatim}
  ____LaTeX_format_____     ____PGPLOT_format____
   1.24 \\x 10^{-14}         1.24 \x 10\u-14\d
   \\A^{-1}                  \A\u-1\d
   2s~^2S_{1/2}              2s \u2\dS\d1/2\u
   e^{i\\pi} + 1 = 0         e\ui\gp\d + 1 = 0
\end{verbatim}
Note that two backslash `\verb|\|' symbols must be used to denote
font changes, Greek symbols and other special symbols.
\end{isisfunction}

\begin{isisfunction}
{limits} %name
{Use the plot data to determine axis limits for the next plot} %purpose
{limits} %usage
{xrange, yrange}
\index{Plot!axis ranges}
This function re-sets the current pane of the current plot window so that
the XY ranges of the next plot will cover the full-range of data.  This
function is equivalent to {\tt xrange; yrange;}
\end{isisfunction}

\begin{isisfunction}
{line\_or\_color} %name
{control interpretation of line style indices} %purpose
{line\_or\_color (choice)} %usage
{color, linestyle}

If {\tt choice =0}, line style indices indicate line {\it type} (e.g. solid,
dashed, dotted, etc.). If {\tt choice !=0}, line style indices indicate line
{\it color} (this is the default).
\end{isisfunction}

\begin{isisfunction}
{linestyle} %name
{change the plot linestyle} %purpose
{linestyle (linestyle\_index)} %usage
{line\_or\_color}
\index{Plot!line style}
The available line-style indices are (1) full line, (2) dashed,
(3) dot-dash,  (4) dotted, (5) dash-dot-dot-dot.
See the \pgplot\ documentation for more information.
\end{isisfunction}

\begin{isisfunction}
{multiplot} %name
{Subdivide the current plot-device window into horizontal panes} %purpose
{multiplot (relative\_sizes)} %usage
{open\_plot, mpane, window}
\index{Plot!subwindows}
This function supports subdividing a plot window into horizontal
panes which share a common X-axis. The argument to {\tt multiplot}
is an integer array which gives the relative sizes of the plot
panes in order, from top to bottom.

Example:
\begin{verbatim}
   multiplot ([3,1]);   % top pane is 3x as wide as the bottom pane
   multiplot (1);       % Restore subdivided plot to a single pane.
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{mpane} %name
{Select a specific pane in a multiplot} %purpose
{mpane (pid)} %usage
{multiplot}
\index{Plot!subwindows}
This function selects a specific pane within a multiplot (a set
of plot panes sharing a common X-axis).

Example:
\begin{verbatim}
   x=[1:100];
   multiplot ([1,1,2]);   % a 3-pane multiplot
   plot(x,x);             % plot in pane 1 (the top one)
   plot(x,x);             % plot in pane 2

   mpane(1);              % move back to the top pane
   oplot(x,x^2);          % over-plot in pane 1

   mpane(3);              % move to the bottom pane
   plot(x,x);
   oplot(x,x^2-x);
   multiplot(1);          % revert to a single pane format
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{open\_plot} %name
{open a new plot window} %purpose
{window\_id = open\_plot (["device" [, nxpanes, nypanes]])} %usage
{close\_plot, window, dup\_plot, plot, hplot, plot\_data, plot\_model, plot\_elev, multiplot}
\index{Plot!devices}
\index{Plot!postscript output}
\index{Plot!hardcopy}
\index{Plot!panes}

The first argument specifies the name of plot device.  If
device = "?" or is blank or absent, the user is prompted to
supply the device name.  The default device is that specified
by the \verb|PGPLOT_DEV| environment variable; if that
environment variable is not set, the default device is
\verb|NULL|.  See the description of the \pgplot\ command
\verb|pgopen| for full details on the device specification
string.

The remaining two optional arguments (\verb|nxpanes|,
\verb|nypanes|) give the number of X and Y subdivisions for the
window. The return value gives the integer index of plot device
just opened.

\vspace*{\baselineskip}
{\bf Postscript:~~}\\ A good way to generate postscript plots is to write a
\slang\ script using an {\tt open\_plot} command which specifies the output
postscript file name and the postscript device using the device string (see
the examples below).

\vspace*{\baselineskip}
{\bf GIF and other formats:~~}\\ If the appropriate drivers are included
when \pgplot\ is installed, plots may be generated in a wide range of
formats.  For example, to generate a GIF image, open the appropriate plot
device (e.g. {\tt open\_plot("plot.gif/gif")}), generate the plot as usual
and then close the plot device ({\tt close\_plot}).

\vspace*{\baselineskip}
{\bf X-windows:~~}\\
Under X-windows, the default initial size of the plot
window is controlled by the Xresource
\begin{verbatim}
     pgxwin.Win.geometry.
\end{verbatim}
If \isisx is run on a machine with a small screen, the default
plot window size should probably be set to something smaller than the
\pgplot\ default size of $867\times 669$ pixels.  Otherwise, when a plot
window is opened, it might fill the entire screen. To make the default
window half as large, insert the line
\begin{verbatim}
    pgxwin.Win.geometry:       432x333
\end{verbatim}
in \verb|~/.Xdefaults|, then use
\begin{verbatim}
    xrdb ~/.Xdefaults
\end{verbatim}
to have the X window manager read the modified .Xdefaults file. It may also
be necessary to kill and re-start the existing pgxwin server (e.g. by
re-opening the plot window) before the geometry change will take effect.

Another useful Xresource is {\tt pgxwin.Win.maxColors}. Because each plot
window reserves 100 colors, opening several plot windows may quickly exhaust
the available colors on the display, leading to color flashing or causing
the entire screen to turn black upon opening a plot window. This problem may
be alleviated by setting {\tt pgxwin.Win.maxColors} to a smaller value, e.g.
\index{color flashing}
\index{color flashing!black screen}
\begin{verbatim}
     pgxwin.Win.maxColors:  16
\end{verbatim}
See the \pgplot\ documentation for full details:
\begin{verbatim}
    http://astro.caltech.edu/~tjp/pgplot/xwdriv.html
\end{verbatim}
If the display turns black because it ran out of colors, one can usually
recover by moving the mouse cursor to a different window and perhaps
clicking the mouse in that window (if the X-window configuration uses
click-to-focus).  Another symptom of running out of colors is the notorious
color-flashing which occurs as the mouse cursor moves across window
boundaries.  These problems are sometimes less severe with newer systems
that have larger color-spaces (e.g. 24 bit monitors).

\begin{verbatim}
Examples:

% a single pane X-window
() = open_plot;              % assuming PGPLOT_DEV = "/xwin"

% a color postscript plot with 2 panes in a file "myfile.ps"
() = open_plot("myfile.ps/cps",2,1);

% a different style of plot with 2 sub-panes
% the top pane is 3X as wide as the bottom pane
() = open_plot ("/xw");
multiplot ([3,1])

% A function like this can be used to simplify plotting
% data and residuals in the XSPEC style:
% [the ISIS function rplot_counts() does this]

public define plot_count_residuals (h, dev)
{
   multiplot ([3,1]);

   errorbars (1);
   plot_data_counts (h);
   oplot_model_counts (h);

   errorbars (0);
   yrange;
   _rplot_counts(h);
}

%  e.g. To use this function to plot data set 1 in an X-window
%  (see the figure) type

   isis> plot_count_residuals (1, "/xw");

\end{verbatim}
\end{isisfunction}

\begin{figure}[ht]
\putfig{figures/residuals}
\caption{Example of plotting count data and fit-residuals.}
\label{fig:resid}
\end{figure}

\begin{isisfunction}
{plot} %name
{[o]plot x-array vs. y-array} %purpose
{[o]plot (x, y, [line\_style | symbol\_array])} %usage
{open\_plot, window, pointstyle, connect\_points}
\index{oplot@{\tt oplot}}
\index{Plot!of arrays}

Given two 1-D \slang\ arrays of size N, this function will plot
or over-plot x vs. y. The oplot function behaves like plot if
no plots have already been drawn.  If the third argument is a
single integer, it is interpreted as the the line-style {\tt
see line\_or\_color}.  If the third argument is an integer
array of length N, it is interpreted as a list of plot symbols,
one for each point.
\begin{verbatim}
% Example:           plot the line y=x for 1 <= x <= 10, labeling the points
%                    with the lower case letters 'a' through 'j'
      x = [1:10];
      y = x;
      sym = ['a':'j'];         % sym[0] = integer ASCII code for 'a', etc.
      plot (x,y,sym);
\end{verbatim}
\end{isisfunction}

\clearpage

\begin{isisfunction}
{plot\_auto\_color} %name
{Control automatic line-color/line-style changes} %purpose
{plot\_auto\_color (flag)} %usage
{set\_data\_color, line\_or\_color}
If {\tt flag} is non-zero, overplots automatically change line color or line
style, cycling through the available colors or styles (this is the default).
If {\tt flag} is zero, color or style changes must be specified explicitly.
\end{isisfunction}

\begin{isisfunction}
{plot\_bin\_density} %name
{Plot data values as a density in each bin} %purpose
{plot\_bin\_density} %usage
{plot\_bin\_integral}
This function alters the plotted values for histogram plots only. By default,
histograms are plotted as bin-integral quantities. This mode specifies that
the input data bin values should be divided by the bin width and
exposure time for plotting
(recall that the input data values are assumed to be bin-integral quantities)
\end{isisfunction}

\begin{isisfunction}
{plot\_bin\_integral} %name
{Plot data values integrated over each bin width} %purpose
{plot\_bin\_integral} %usage
{plot\_bin\_density}
This function alters the plotted values for histogram plots only.
If the format type is not specified, it is assumed to be
bin-integral.  Because the input data values are assumed to
be bin-integral quantities, this mode specifies that the input
data bin-values are to be plotted unchanged.
\end{isisfunction}

\begin{isisfunction}
{plot\_contour} %name
{display image contours} %purpose
{plot\_contour (img[] [, aspect [,x[], y[] [, c[] ]]])} %usage
{plot\_image, histogram2d}
\index{Plot!contours}
The image is a 2D array, \verb|img[y,x]|.
When the optional argument, \verb|aspect|, is non-zero,
the image dimensions determine the aspect-ratio of the plot.
Otherwise, the plot fills the plot window and the image
may be distorted.
The optional 1D array arguments \verb|x,y| provide
the coordinate grid for the X,Y axes.  The
remaining optional argument, \verb|c[]|,
provides the contour levels to be plotted.
\end{isisfunction}

\begin{isisfunction}
{plot\_device} %name
{specify default plot device} %purpose
{plot\_device (device\_string)} %usage
{open\_plot, window}
\index{Plot!default plot device}

This default over-rides the current value of the {\sc PGPLOT\_DEV}
environment variable; {\tt device\_string} can be any valid \pgplot\ device
string; the list of available devices is determined by the configuration of
the \pgplot\ installation. See the \pgplot\ documentation for details.
\end{isisfunction}

\begin{isisfunction}
{plot\_image} %name
{display an image} %purpose
{plot\_image (img[][, aspect [,x[], y[] [, amin, amax]]])} %usage
{plot\_contour, histogram2d, set\_palette, plot\_image\_ctrl}
\index{Plot!image}
The image is a 2D array, \verb|img[y,x]|.
When the optional argument, \verb|aspect|, is non-zero,
the image dimensions determine the aspect-ratio of the plot.
Otherwise, the plot fills the plot window and the image
may be distorted.
The optional 1D array arguments \verb|x,y| provide
the coordinate grid for the X,Y axes.  The
two remaining optional arguments, \verb|amin, amax|,
specify the range of array values to be mapped
onto the chosen color table.  Use \verb|set_palette()|
to select from a set of predefined color tables;
\verb|plot_image_ctrl| supports interactive control
over the color table, brightness and contrast.
\end{isisfunction}

\begin{isisfunction}
{plot\_image\_ctrl} %name
{Adjust image color table, brightness and contrast} %purpose
{plot\_image\_ctrl ()} %usage
{histogram2d, set\_palette, plot\_image}
\index{Plot!image brightness, contrast}
This function supports interactive control
over the color table, brightness and contrast
used to display an image on the current plot device.
\end{isisfunction}

\begin{isisfunction}
{plot\_quit} %name
{close all plot windows} %purpose
{plot\_quit} %usage
{open\_plot, close\_plot, window}
This function closes all currently open plot devices
\end{isisfunction}

\begin{isisfunction}
{plot\_unit} %name
{specify X-coordinate units for plotting data histograms} %purpose
{plot\_unit (x\_unit)} %usage
{plot\_data, plot\_bin\_density}

The default X-coordinate units are {\AA}ngstrom units. Supported
alternatives are selected by specifying one of the following strings
(case-insensitive):
\begin{verbatim}
  Angstrom, A, nm, mm, cm, m
  eV, keV, MeV, GeV, TeV,
  Hz, kHz, MHz, GHz
\end{verbatim}
Note that altering the X-coordinate of the plot will also
change the Y-values plotted if the Y-axis is in units of
bin-density (because those values are being divided by the
bin-width).  If plotting bin-integral values, the Y-axis values
are independent of the X-coordinate.
\end{isisfunction}

\begin{isisfunction}
{pointstyle} %name
{change the symbol used to plot data points} %purpose
{pointstyle (symbol)} %usage
{[o]plot}
\index{Plot!symbol}
\begin{verbatim}
 -1,-2     a single dot
 -3..-31   a regular polygon with abs(symbol)
           edges (style set by current fill style)
 0..31     standard marker symbols
 32..127   ASCII characters (in current font)
    >127   a Hershey symbol number
\end{verbatim}
For further details, including lists of the standard marker symbols and the
Hershey plot symbols, see the \pgplot\ documentation. Note that the ASCII
value of a character is easily obtained in \slang:
\begin{verbatim}
    ch = 'b';                             % set ch to the ASCII code for 'b'
    sym = Integer_Type [length(array)];   % make a symbol array
    sym[*] = 'Q';                         % and set all symbols to 'Q'
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{resize} %name
{resize the plot window} %purpose
{resize[ ([width\_in\_cm], [aspect\_ratio])]} %usage
{open\_plot, window}

The aspect\_ratio is defined as height/width.
aspect=1.000 gives a square plot\\
aspect=0.618 gives a horizontal rectangle\\
aspect=1.618 gives a vertical rectangle\\

If width=0.0, the window will assume the largest available view
surface consistent with the argument aspect\_ratio. If no
arguments are given, the result is equivalent to {\tt resize (0.0, 0.618)}.
Note that the resize takes effect only when something is plotted
in the specified window and not at the moment the resize function
is called.
\end{isisfunction}

\begin{isisfunction}
{set\_frame\_line\_width} %name
{Set line width for plot axes and axis grid labels} %purpose
{set\_frame\_line\_width (width)} %usage
{set\_line\_width}
\index{Plot!line width (frame)}

Use this function to set the line width used to
draw the plot axes, the tick-mark
labels, the axis labels and the plot title.
By default, \verb|width=1|.

\end{isisfunction}

\begin{isisfunction}
{set\_line\_width} %name
{Set line width} %purpose
{set\_line\_width (width)} %usage
{set\_frame\_line\_width}
\index{Plot!line width}

Use this function to set the line width used to
plot points, curves and error-bars.
By default, \verb|width=1|.

\end{isisfunction}

\begin{isisfunction}
{set\_outer\_viewport} %name
{Set viewport location} %purpose
{set\_outer\_viewport (Struct\_Type v)} %usage
{get\_outer\_viewport, multiplot}

Use this function to specify the outer viewport of the plot in
normalized device coordinates.  The coordinates are specified
using a structure of the form
\begin{verbatim}
   v = struct {xmin, xmax, ymin, ymax}
\end{verbatim}

For a simple plot, the ``outer viewport'' has the same meaning
as the viewport discussed in the PGPLOT documentation for e.g.
PGSVP.  For a multiplot containing several plot panels sharing
a common X-axis, the ``outer viewport'' is the outermost box
that contains all of the plot panels.

\end{isisfunction}

\begin{isisfunction}
{set\_palette} %name
{Select image color table} %purpose
{set\_palette (id)} %usage
{plot\_image, plot\_image\_ctrl}
\index{Plot!color table}

Use this function to choose from five predefined color tables:
\begin{verbatim}
    ___id______Color_Table___
        1       grey scale
        2       rainbow
        3       heat
        4       iraf
        5       aips
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_plot\_options} %name
{Modify the current plot format} %purpose
{set\_plot\_options (Struct\_Type)} %usage
{plot\_open, plot\_close, get\_plot\_info, get\_plot\_options}

\end{isisfunction}

\begin{isisfunction}
{title} %name
{Set plot title} %purpose
{title ("title string")} %usage
{xlabel, ylabel, label, xylabel, latex2pg}
\index{Plot!title}

Specifies a string to use as the plot title.  To
simultaneously label both axes and provide a title use the {\tt label}
function.
\end{isisfunction}

\begin{isisfunction}
{window} %name
{specify the active plot device} %purpose
{window (window\_id);} %usage
{open\_plot}
\index{Plot!windows}
Plotting commands refer to the active plot device. Use this function to
specify which device is active. This function is useful primarily during an
interactive session for switching between different plot windows within
X-windows.  This functionality is not necessarily available with all plot
devices or all combinations of plot devices.
\end{isisfunction}

\begin{isisfunction}
{xinterval} %name
{read endpoints of x-interval from plot cursor} %purpose
{(xmin, xmax) = xinterval ();} %usage
{cursor}

\index{yinterval@{\tt yinterval}}
This function is useful for selecting X-intervals from a plot in interactive
mode. \verb|yinterval| is the analogous command for the y-axis.
\end{isisfunction}

\begin{isisfunction}
{xlabel} %name
{Set plot x-axis label} %purpose
{xlabel ("string")} %usage
{ylabel, label, title, xylabel, latex2pg}
\index{ylabel@{\tt ylabel}}

Specifies a string to use as the X-axis label.  To simultaneously
label both axes and provide a title use the {\tt label} function.

\end{isisfunction}

\begin{isisfunction}
{xlin} %name
{Change the x-axis to linear scale} %purpose
{xlin} %usage
{xlog}
\index{Plot!axis scaling}
\index{ylin@{\tt ylin}}
{\tt ylin} is the analogous command for the y-axis
\end{isisfunction}

\begin{isisfunction}
{xlog} %name
{Change the x-axis to log scale} %purpose
{xlog} %usage
{xlin}
\index{Plot!axis scaling}
\index{ylog@{\tt ylog}}

{\tt ylog} is the analogous command for the y-axis
When log scale is specified for a given coordinate axis, points with
non-positive values of that coordinate are ignored when computing the full
range of the data.  For example, consider a function defined on the set of x
coordinates [-5, -3, -2, 0, 2, 4, 5, 10, 15].  When plotted using a log
x-axis, the full range of data is considered to extend from log10(2) to
log10(15); the non-positive coordinate points are ignored.  This command
affects the plot appearance only; it does {\it not} replace the internal
data values with their logarithms.
\end{isisfunction}

\begin{isisfunction}
{xrange} %name
{set the X-axis plot limits for the next plot} %purpose
{xrange[ ([xmin], [xmax])]} %usage
{xlin, xlog}
\index{Plot!axis ranges}
\index{yrange@{\tt yrange}}

If either argument is absent, the corresponding value will be
derived from the data when the next plot is generated.
\verb|yrange| is the analogous command for the Y-axis, except that
\verb|yrange| sets the Y-axis plot limits to the range of data
inside the current X-axis plot limits rather than the full range
of the entire data set.

\end{isisfunction}

\begin{isisfunction}
{xylabel} %name
{place a text label at an arbitrary x,y plot location} %purpose
{xylabel (x,y,label, [angle [,justify]])} %usage
{xlabel, ylabel, title, label, latex2pg, cursor}

The optional \verb|angle| argument gives the rotation angle in degrees
CCW [default = 0.0].  The optional \verb|justify| argument
positions the text relative to the cursor location;
\verb|justify|=0.0 for text to the right of the cursor [default],
\verb|justify|=0.5 for text centered on cursor,
\verb|justify|=1.0 for text to the left of the cursor.

In interactive mode, it may be helpful to read the
(x,y) coordinates with the mouse via the {\tt cursor} command.

\begin{verbatim}
Example:
    variable x,y;
    cursor (&x, &y);
    xylabel (x, y, "Fe XVII");
\end{verbatim}

A more general \slang\ script which uses the {\tt cursor} command to select
points and then writes appropriate {\tt xylabel()} commands to a file (with
explicit X-Y coordinates filled in) might greatly simplify some tedious plot
annotation tasks, such as labeling emission lines in an observed spectrum.
\end{isisfunction}

\newpage
\section{Fitting Functions to Data}
\label{sec:fitting-data}

To use high resolution spectral data to infer physical conditions
in an emitting plasma, measurements of the strength and shape of
observed features are often compared to theoretical predictions.
To facilitate measurement of the position, strength, size and
shape of spectral features, \isisx supports fitting models to
data.  A few simple functions such as Gaussians and polynomials
are provided by \isisx and many others are available from the
\xspec\ module (\S\ref{chap:xspec-module}).  \isisx also provides
the ability to automatically generate customized multi-component
spectral models using the spectroscopy database (see
\verb|create_aped_fun|). Multiple user-defined fit-functions are
also supported (see {\tt add\_compiled\_function}, {\tt
add\_slang\_function}). Furthermore, using the ISIS intrinsic
variable \verb|Isis_Active_Dataset|, one can write user-defined
functions which evaluate differently for different datasets. For
example, its possible to simulataneously fit a Gaussian to one
dataset and a Lorentzian to another.  For another way to do this,
see \verb|assign_model|.

Models may be fit to either flux-corrected data or count-data.
Extending the standard forward-folding fit algorithm used in \xspec,
the \isisx implementation supports the treatment of some classes of
non-linear instrument response (such as event pileup -- see
\S\ref{sec:pileup}) and also supports application of a user-defined
photon redistribution function (RMF) implmemented in software (see
{\tt load\_rmf} and, for an example implementation, see
\verb|src/rmf_delta.c| in the \isisx distribution).

The \isisx implementation of forward-folding ``solves'' equations
of the form
\begin{equation}
    C(h) = B(h) + t \int \D E~{\cal F}\Bigl(R(h,E),\ A(E),\ s(E)\Bigr)
\label{eq:model-counts}
\end{equation}
where $C(h)$ is the number of counts obtained in detector-bin $h$,
$t$ is the effective exposure time, $E$ is the incident photon energy, and
$s(E)$ is the incident source flux at energy $E$.  The instrument response
is represented by an effective-area function $A(E)$ (e.g. the ARF)
and a redistribution function $R(h, E)$ (e.g. the RMF).  The
instrumental background in detector-bin $h$ is given by $B(h)$.

All the functions on the right-hand side of equation
(\ref{eq:model-counts}) may be user-defined.  In particular, the
function ${\cal F}$ may be user-defined; for brevity, we refer to
this function as the {\it kernel}, although this usage is somewhat
inconsistent with standard mathematical terminology. In the
standard implementation of forward-folding,
\begin{equation}
   {\cal F}\left(R,\ A,\ s\right) = R(h,E)A(E)s(E).
\end{equation}
This is the form used in \xspec\  and is the default kernel used in
\isisx.  When multiple responses are assigned to a single data set (using
{\tt assign\_rsp}), \isisx uses
\begin{equation}
   {\cal F}\left(R,\ A,\ s\right) = \sum_i R_i(h,E)A_i(E)s(E),
\end{equation}
where the sum extends over all responses.  This latter form is
suitable for analysis of HRC/LETGS data, where multiple dispersion
orders are summed together in the data, but where responses for
individual dispersion orders are available.  This form is also
applicable to the analysis of CCD data where significant response
variation is present across the spectral extraction region (e.g.
for ACIS-I observations of extended sources); in this case, the
ARFs must be weighted according to the surface-brightness
distribution of the source. Davis (2001) showed that event pileup
in CCD detectors is a non-linear process which can be described by
a considerably more complex function ${\cal F}$. Davis's
implementation of this pileup kernel is available in \isisx and
may be accessed using the {\tt set\_kernel} and {\tt
print\_kernel} functions (see \S\ref{sec:pileup}).  Similarly,
user-defined fit-kernels may be accessed using the {\tt
load\_kernel} function.

{\tt ignore}, {\tt notice} and {\tt xnotice} are used to indicate
which data bins are to be included in the fit. {\tt ifit\_fun} or
{\tt fit\_fun} define and modify the form of the fit function.
{\tt list\_par} displays a list of current fit parameters.
Parameter values can be set using {\tt edit\_par}, {\tt set\_par}
or {\tt load\_par}; allowed ranges for each parameter value are
enforced during the fitting iteration. The {\tt renorm\_*}
functions simplify finding the initial parameter values by
automatically adjusting the normalization of the model. Parameters
may be fixed at known values or allowed to vary to improve the
model fit (see {\tt freeze, thaw}). Parameter values may also be
tied to together (see {\tt tie, untie}). Parameter values may even
be defined as functions of other parameters and, optionally, as
functions of user-defined functions (see \verb|set_par_fun|).

The {\tt eval\_*} functions evaluate the model using the current
parameter set. Once the fit data is specified and the model and
initial parameter values are defined, the {\tt fit\_*} functions
compute the best fit model parameters and {\tt save\_par} saves
the parameter values to an ASCII file. {\tt [o]plot\_model}
displays plots of the best fit model. Single parameter confidence
limits can be computed using {\tt [v]conf}.

{\tt get\_cfun} and {\tt get\_cfun2} evaluate the underlying
differential (unbinned) fit function at a specified set of
points; these values may then be plotted using {\tt [o]plot}
(See \S \ref{sec:plot-functions}).

While the bin coordinates in the input data may use any of several
supported physical units, all fit parameters are defined using
Angstrom bin coordinates and {\it all internal calculations are
done in Angstrom bin coordinates}.  Function values are
interpreted as the integral, over the bin width, of an underlying
``differential'' function.

The intrinsic variable {\tt Fit\_Verbose} controls the amount of
information printed to the screen during the fit iterations. In
verbose mode ({\tt Fit\_Verbose} $>$ 0), the fit routine prints out
the values of the variable parameters at each iteration along with
the current $\chi^2$ value and convergence tolerance. In silent
mode ({\tt Fit\_Verbose} $<$ 0), only fatal error messages are
printed. The default verbose level is {\tt Fit\_Verbose}=0, but
this may be set in the {\tt \$HOME/.isisrc} configuration file.
\index{Fit\_Verbose@{\tt Fit\_Verbose}}

By default, the instrumental response (RMF/ARF) is applied when fitting, if
these functions are available.

Functions may be fitted to ``scatter data'' [randomly ordered
sets of (X,Y) pairs] using the \verb|array_fit| function.

\begin{isisfunction}
{\_par} %name
{get the value of a fit parameter} %purpose
{par = \_par (idx)} %usage
{get\_par, set\_par, set\_par\_fun}

This function is identical to \verb|get_par| but is normally
used only when defining fit-parameters as functions of other
parameters.
\end{isisfunction}

\begin{isisfunction}
{add\_compiled\_function}
{Add a user-defined fit function}
{add\_compiled\_function (library\_name, function\_name [, option\_string])}
{del\_function, list\_functions, add\_slang\_function, set\_function\_category}
\index{User-defined!fit-function (compiled)}

{\it Note: this function is available only on systems with ELF
support.  } See the \verb|userfun| example from the \isisx web
page and the \verb|modules/xspec/src| directories in the \isisx
distribution for detailed examples of how to implement
user-defined fit functions in C; \slang\ fit-functions are also
supported (See {\tt add\_slang\_function}). An unlimited number
of user-defined functions are supported and fit functions may
have an unlimited number of parameters.

The first argument, \verb|library_name|, gives the name of the
shared library file (.so).  The section argument,
\verb|function_name|, gives the name of the subroutine that
evaluates the fit-function (string \verb|<31| characters).  The
optional third argument, \verb|option_string|, is a string
which is passed to the user-module initialization routine.
To avoid future problems,
parameter names should avoid using \slang\ special characters.

For example, suppose the user-defined fit-function is a power law ($f(x) =
Ax^p$) and is defined by a subroutine called {\tt plaw}, with parameters
{\tt norm} and {\tt power}). Further, suppose this subroutine is contained
in a dynamically linked library file called {\tt mylib.so}.

The {\tt plaw} function may be accessed at run-time using
\begin{verbatim}
    isis>  add_compiled_function ("mylib.so", "plaw");
\end{verbatim}
assuming that {\tt mylib.so} exists somewhere in the \isisx module search
path (see e.g. {\tt ISIS\_MODULE\_PATH}).

For user-defined operator models implemented in C, the
\verb|Isis_User_Source_t| structure should be initialized with
the \verb|category| field set to \verb|ISIS_FUN_OPERATOR|.
\end{isisfunction}

\begin{isisfunction}
{add\_slang\_function}
{Add a user-defined fit function}
{add\_slang\_function (name, par\_name\_array [, norm\_indexes])}
{del\_function, list\_functions, add\_compiled\_function, set\_function\_category, set\_param\_default\_hook}
\index{User-defined!fit-function (S-Lang)}
\index{Operator models!fit-function (S-Lang)}
\index{Convolution models!fit-function (S-Lang)}

The first argument, \verb|name|, is the name that will be used
in the expression supplied to \verb|fit_fun|; it should be
\verb|<= 31| characters long.  The corresponding \slang\
function name must have a suffix `\verb|_fit|' appended. The
second argument, \verb|par_name_array|, is an array of strings,
each \verb|<= 31| characters in length, containing the function
parameter names.  The optional third argument,
\verb|norm_indexes|, is an integer array specifying the
zero-based array indices of the parameters which should be
interpreted as normalization coefficients. Note that parameter
names should be valid \slang\ identifiers.

Physical units for each fit parameter may be specified by
appending the units to the parameter name string, enclosed in
square brackets (``\verb|[]|'').  For example,
\begin{verbatim}
  add_slang_function ("foo", ["kT [keV]", "Mdot [Msun/yr]"]);
\end{verbatim}
defines a function of two parameters, \verb|kT| measured in
units of keV and \verb|Mdot| measured in units of solar masses
per year.

Defining new fit-functions in \slang\ is simpler than in C but,
because the function evaluations are performed in an
interpreted language, the execution time may be noticeably
slower, depending on the implementation. Remember that, in the
interpreter, implicit array operations are {\it much} faster
than explicit loops over array indices.

For example, suppose the user-defined fit-function is a power
law ($f(x) = ax^b$) and is defined by a \slang\ function called
{\tt plaw\_fit}, with adjustable parameters {\tt norm} = "$a$"
= {\tt par[0]} and {\tt power} = "$b$" = {\tt par[1]}.  The
\slang\ function "{\tt plaw\_fit}" which computes the
bin-values might look like this:
\begin{verbatim}
define plaw_fit (lo, hi, par)
{
   variable norm, p, result;

   norm = par[0];
   p    = par[1] + 1;
   result = norm * (hi^p - lo^p) / p;       % integral over bin-width

   return result;
}
\end{verbatim}

All user-defined, additive and multiplicative \slang\
fit-functions must follow this basic form; the function
interface for operator models is slightly different (see
below). The three input array arguments may have any valid
variable names, but the arguments will be supplied in the order
indicated; bin lower-edge first, bin upper-edge second and
parameter array third.  The user-defined function must return a
single array providing the bin-integrated function value in
each bin. Note that, for clarity, error-checking has been
omitted from this example.

Thus defined, this {\tt plaw} function may be made available to
the fit-engine at run-time using
\begin{verbatim}
     add_slang_function ("plaw", ["norm","power"]);
\end{verbatim}
Parameter names must be listed in the order they appear in the parameter
array which is passed to the subroutine.  The \slang\ function
may also be specified using a reference:
\begin{verbatim}
    add_slang_function ("plaw", &plaw_fit, ["norm","power"]);
\end{verbatim}
In this case, the function may have any name.  To provide
a differential version of the same function (as opposed to
the usual binned version), provide an array of two function
references:
\begin{verbatim}
    add_slang_function ("plaw", [&plaw_binned, &plaw_diff], ["norm","power"]);
\end{verbatim}
The differential version should have an interface of the form
\begin{verbatim}
    define plaw_diff (x, p)
    {
        % compute the differential value f(x)
        return f;
    }
\end{verbatim}

To use this new \slang\ function in fitting data, one should use
the fit invocation-name with the usual syntax: here, one might
use
\begin{verbatim}
   isis>  fit_fun ("plaw(1) + plaw(2)");
\end{verbatim}
to sum two instances of the {\tt plaw} function.

When one of the parameters is called {\tt "norm"}
(case-insensitive), it will be treated as the only
normalization parameter.  Alternatively, the zero-based array
indicies of those parameters to be treated as normalizing
coefficients should be listed using the optional third
parameter {\tt norm\_indexes}. If no parameter is called {\tt
"norm"} and no list is given, none of the function parameters
will be adjusted by {\tt renorm\_*}.

Default parameter values and ranges may be specified using a
separate \slang\ function (see \verb|set_param_default_hook|).

User-defined fit-functions may also access global data, allowing
one to write functions which require a significant amount of data
to generate the desired result.  In particular, one might load a
table model from a file, and then use those data to compute model
values. For example, consider a file containing the following
S-Lang code:

\begin{verbatim}
require ("xspec");
static variable X_lo, X_hi, Value;

define fast_wabs_init (x)
{
   x = _A(x);
   X_lo = x[[:-2]];
   X_hi = x[[1:]];
   variable y = eval_fun2 (&wabs, X_lo, X_hi, 1.0);

   % rebin assumes bin-integrated quantities
   Value = y * (X_hi - X_lo);
}

fast_wabs_init ( 10.0^[-3:1.3:0.001] );

define fast_wabs_fit (lo, hi, par)
{
   variable y = rebin (lo, hi, X_lo, X_hi, Value);
   y /= hi - lo;

   return y^(par[0]);
}

add_slang_function ("fast_wabs", ["NH_22"]);

provide ("fast_wabs");
\end{verbatim}

When this file is loaded, it evaluates the XSPEC absorption model
\verb|wabs| for a unit absorbing column and a fixed standard grid,
storing the result in the global variables \verb|X_lo|,
\verb|X_hi| and \verb|Value|.  It also defines a new fit-function
called \verb|fast_wabs|.  When called, this fit-function
interpolates the saved \verb|wabs| values onto the specified grid
and rescales the result to match the current value of absorbing
column. This is considerably faster than the current XSPEC default
implementation which repeatedly recomputes the optical depth
contribution from each element, even though the abundances of the
absorbing gas remain fixed.

Operator models differ from additive and multiplicative models
in that they operate on the result of another function. For
example, the Gaussian smoothing operator \verb|gsmooth|, can be
invoked using the syntax
\begin{verbatim}
  fit_fun ("gsmooth (1, mekal(1))");
\end{verbatim}
This example computes a spectrum using the \verb|mekal| model
and then convolves it with a Gaussian using the \verb|gsmooth|
operator. Although isis fit-functions can take an arbitrary
number of additional arguments of any type, ``operator'' models
represent an important special case because they correspond
closely to the ``convolution'' models long provided by XSPEC.
For historical reasons, \isis\ handles operator models in a
rather special way.

To implement an operator model in S-Lang, the S-Lang function
should be defined with an interface of the form
\begin{verbatim}
  define my_operator_fit (lo, hi, par, fun_value)
\end{verbatim}
where the first three arguments are the same as for additive
and multiplicative functions and the last argument
\verb|fun_value| is a S-Lang array containing the computed
function to which the operator will be applied. Before use,
operator models implemented in S-Lang must be labeled as
operator models by calling the \verb|set_function_category|
function:
\begin{verbatim}
  add_slang_function ("my_operator", ["a", "b"]);
  set_function_category ("my_operator", ISIS_FUN_OPERATOR);
\end{verbatim}

In general, \isis\ fit-functions may take an arbitrary number
of parameters.  This feature makes it possible to encode quite
complicated functional relationships into one or more suitably
defined ISIS fit-functions that work cooperatively. The
usefulness of this feature is perhaps best illustrated by a
concrete example.

This example corresponds closely to the design of the
nonthermal spectral models for \isis
\footnote{{\tt
http://space.mit.edu/home/houck/software/slang/modules/nonthermal/}}.
In that module, the goal is to compute a variety of nonthermal
photon emission spectra that arise from a given nonthermal
particle distribution function. Several
parameterizations of the particle distribution function are
available and each photon emission process carries additional
process-specific parameterizations.  A natural way to express
this relationship is to specify a \verb|pdf| as an argument
to each spectral model:
\begin{verbatim}
    sync (1, pdf(1))
    invc (1, pdf(1))
    ntbrem (1, pdf(1))
\end{verbatim}
This syntax means that the \verb|sync| function will be
computed for the distribution function specified by \verb|pdf|,
and so on.

The implementation is complicated by the fact that, for
performance reasons, the particle distribution function is best
implemented in a compiled language such as C.  Without getting
into the details of the implementation, the important point is
that one can select the appropriate C subroutine to compute the
PDF by creating a \slang\ function \verb|pdf| that returns the
name of the PDF that is to be evaluated, along with the
parameters for that PDF.

To make this connection, the fit-function \verb|pdf| should
return two objects -- a string specifying the name of the
particle distribution function plus the associated parameter
vector:
\begin{verbatim}
private define pdf (l,h,p)
{
   return ("pdf", p);
}
add_slang_function ("pdf", &pdf, ["a", "b", "c"]);
\end{verbatim}
Note that the wrapper function does nothing with the spectral
grid arrays \verb|(l,h)|.  The only purpose of this model is
to enable passing a parameter array on to the named PDF.
Each different particle distribution should have a similar
wrapper that returns the relevant model name and list of
parameter values.

The \verb|sync| function can then be defined to make use of
these additional parameters:
\begin{verbatim}
private define sync (l,h,p)
{
   variable pdf_name, pdf_pars;
   (pdf_name, pdf_pars) = ();
   return compute_sync (l, h, p, pdf_name, pdf_pars);
}
add_slang_function ("sync", &sync, ["norm", "B"]);
\end{verbatim}
Note that the \verb|sync| function could also be defined
like so:
\begin{verbatim}
   define sync (pdf_name, pdf_pars, l, h,p)
   {
     ...
   }
\end{verbatim}
This definition is functionally identical to the previous one.

For a similar example, see {\it e.g.} \verb|create_aped_line_profile|
and \verb|create_aped_line_modifier|.
\end{isisfunction}

\begin{isisfunction}
{add\_slang\_statistic} %name
{Add a user-defined S-Lang fit-statistic} %purpose
{add\_slang\_statistic (name, \&stat, \&report [; <qualifiers>])} %usage
{set\_fit\_statistic, load\_fit\_statistic}
\index{User-defined!fit-statistic (S-Lang)}

The first argument is the name of the fit-statistic. The next
two arguments are addresses of \slang\ functions to compute the
fit-statistic and to print the statistic value, respectively.

\begin{verbatim}
Qualifiers:
  delta_is_chisqr    If present, indicates that the delta-statistic
                     is chi-square distributed (e.g. so that the
                     statistic may be used by `conf')
\end{verbatim}

The function which computes the fit-statistic named \verb|"stat"|
should be named \verb|stat_function| and should have the
interface
\begin{verbatim}
    (vec, stat) = stat_function (data, model, weights)
\end{verbatim}
where \verb|data| and \verb|model| and arrays of equal length
containing the data and model values and where \verb|weights|
is an array of the same size containing the statistical weight
of each data point.  If $\sigma$ is the uncertainty in the
$i^{th}$ data point, the weight is usually $1/\sigma^2$.
The function returns the value of the fit-statistic, \verb|stat|,
as well as a vector, (\verb|vec|), containing the contribution to the statistic
from each bin.

The function which prints the fit-statistic named \verb|"stat"|
should be named \verb|stat_report| and should have the
interface
\begin{verbatim}
    report_string = stat_report (stat, npts, nvpars)
\end{verbatim}
where \verb|stat| is the value of the fit-statistic,
\verb|npts| is the number of data points being fitted, and
\verb|nvpars| is the number of variable fit-parameters.
The function returns a string which will be printed at
the appropriate time.  Note that this string may contain
newline characters (\verb|\n|) allowing it to span multiple
lines of output.

\begin{verbatim}
For example:

% First, define the two functions:
static define mychi_function (y, fx, w)
{
   variable v = (y - fx)^2 * w;
   return (v, sum (v));
}

static define mychi_report (stat, npts, nvpars)
{
   variable s = sprintf ("  My Chisqr = %0.4g\n", stat);
   return s;
}

% Add the statistic to the internal list:
add_slang_statistic ("mychi", &mychi_function, &mychi_report);

% Tell ISIS to use the new fit statistic:
set_fit_statistic ("mychi");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{alias\_fun}%name
{Derive a new fit-function from an existing one}%purpose
{alias\_fun (name, new\_name [; \_\_qualifiers])}%usage
{add\_slang\_function, cache\_fun}%
\index{Rename a fit-function}
\index{Rename function parameters}
\index{Change parameter defaults}

To derive a new fit-function with the same properties as an
existing fit-function, but with a different name, just do
\begin{verbatim}
    alias_fun (old_name, new_name);
\end{verbatim}

Several qualifiers support changing the parameter names
or their default settings:
\begin{verbatim}
 names = array of parameter name strings
values = array of default parameter values
freeze = array of integer flags indicating the default freeze state
   min = array of default minimum values
   max = array of default maximum values
params = array of {name, value, freeze, min, max} lists
\end{verbatim}

\begin{verbatim}
EXAMPLE:
  alias_fun ("egauss", "FeKa";
              names= ["area [ph/s/cm^2]", "E [keV]", "sigma [keV]"],
              values=[ 0.01,               6.4,       0.5         ],
              freeze=[ 0,                  1,         0           ],
              min=   [ 0,                  5.8,       1e-6        ],
              max=   [ 1,                  7,         2           ]);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{array\_fit} %name
{Fit a function y=F(x) to data consisting of (X,Y) pairs} %purpose
{(pars, stat) = array\_fit (x, y, wt, pars, par\_min, par\_max, \&fun)} %usage
{set\_fit\_method, set\_fit\_statistic, fit\_counts, fit\_flux}

Use this function to fit a function y = F(x) to data consisting of
(X,Y) pairs.
\begin{verbatim}
   __Input_Parameters__  __Definition___
      x, y               Input data arrays of equal length.

      wt                 Optional weights for the input Y values;
                         If wt = NULL, all Y values receive wt=1.

      pars               Input array of initial parameter values

      par_min, par_max   Input arrays of allowed parameter ranges.
                         If either value is NULL, the corresponding
                         bound extends to infinity.

      fun_ref            Reference to a S-Lang function with
                         interface  y = f(x, pars)

\end{verbatim}

If the fit succeeds, the function returns an array (\verb|pars|)
best-fit parameter values and the corresponding value of the fit-statistic
(\verb|stat|).  If the fit fails, the return values are
\verb|pars=NULL| and \verb|stat=0|.

For example, to fit a line to scatter data using equal weights
on the data points and with unlimited ranges for the fit-parameters:
\begin{verbatim}
%  supply a linear fit-function
define fun (x, pars)
{
   return pars[0] + x * pars[1];
}

% fit the data (providing initial parameter values in `pars')
(best, stat) = array_fit (x, y, NULL, pars, NULL, NULL, &fun);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{assign\_model}
{Assign a model to an specific dataset}
{assign\_model (id[], model\_ref [, arg1 [, arg2, ...]]);}
{fit\_fun, Isis\_Active\_Dataset}

This function may be used to associate a model with a particular dataset,
overriding any model that may have been defined using \verb|fit_fun|.

The \verb|model_ref| argument may be defined in one of two ways:
\begin{verbatim}
   * a String_Type containing a valid model expression
          e.g. "phabs(1) * (mekal(1) + powerlaw(1))"
   * a Ref_Type that refers to a S-Lang function:
          e.g. &some_function
\end{verbatim}

When the model is defined using a \verb|Ref_Type|, any additional arguments
provided to \verb|assign_model| will be passed along to the referenced
function when it is evaluated. For example, the following setup:
\begin{verbatim}
      define example_model (i1, i2)
      {
          return phabs(i1) * (mekal(i2) + powerlaw(1));
      }

      assign_model (2, &example_model, 1, 2);
\end{verbatim}
is equivalent to:
\begin{verbatim}
      assign_model (2, "phabs(1) * (mekal(2) + powerlaw(1))");
\end{verbatim}

To unassign a dataset's model, use \verb|model_ref=NULL|:
\begin{verbatim}
     assign_model (id, NULL);
\end{verbatim}

Note that if every dataset has a model specified by \verb|assign_model|, then
a default model specified by \verb|fit_fun| will not be evaluated during a
fit, even though the parameters of the \verb|fit_fun| model still appear in
the \verb|list_par| output and, for the purposes of optimization, may still be
treated as variable parameters.  In this situation, it may be advisable to use
\verb|fit_fun ("null")| to eliminate the extraneous parameters.

\end{isisfunction}

\begin{isisfunction}
{bin\_center} %name
{Bin-center utility fit-function} %purpose
{bin\_center(id)} %usage
{bin\_center\_en, bin\_width, gauss, Lorentz, poly, delta}

Utility fit-function which evaluates to the wavelength [{\AA}ngstrom] at bin-center.

\end{isisfunction}

\begin{isisfunction}
{bin\_center\_en} %name
{Bin-center utility fit-function} %purpose
{bin\_center\_en(id)} %usage
{bin\_center, gauss, Lorentz, poly, delta}

Utility fit-function which evaluates to the energy [keV] at bin-center.

\end{isisfunction}

\begin{isisfunction}
{bin\_width} %name
{Bin-width utility fit-function} %purpose
{bin\_width(id)} %usage
{bin\_width\_en, bin\_center, gauss, Lorentz, poly, delta}

Utility fit-function which evaluates to the bin-width in {\AA}ngstrom.

\end{isisfunction}

\begin{isisfunction}
{bin\_width\_en} %name
{Bin-width utility fit-function} %purpose
{bin\_width\_en(id)} %usage
{bin\_width, bin\_center, gauss, Lorentz, poly, delta}

Utility fit-function which evaluates to the bin-width in keV.

\end{isisfunction}

\begin{isisfunction}
{blackbody} %name
{Blackbody fit-function} %purpose
{blackbody(id)} %usage
{gauss, Lorentz, poly, delta}

The blackbody function has two variable parameters, the
temperature ($kT$) in keV and the normalization ($N$).

\begin{equation}
  B (E_i^{\rm lo}, E_i^{\rm hi}) = 8.0525~
  {N \over \left(kT\right)^4}~
  \int_{E_i^{\rm lo}}^{E_i^{\rm hi}}\D E~{E^2 \over e^{E/kT} - 1}
\end{equation}

The normalization is the same as that used by \xspec, with $N =
L_{39}/D_{10}^2$ where $L_{39}$ is the source luminosity in units
of $10^{39}$ erg~s${}^{-1}$ and $D_{10}$ is the source distance in
units of 10 kpc.

\end{isisfunction}

\begin{isisfunction}
{cache\_fun}%name
{Create a caching fit-function}%purpose
{caching\_name = cache\_fun (name, lo, hi [; \_\_qualifiers]);}%usage
{add\_slang\_function, alias\_fun}%
\index{Optimization!caching fit-function values}
\index{Caching fit-function values}

In some fitting applications (e.g confidence limit searches),
computationally expensive model components may be repeatedly
evaluated for a single set of parameters.  In these
circumstances, it may be more efficient to temporarily cache
the most recent model result to avoid the expense of
re-computing it.

Use the \verb|cache_fun| intrinsic to create a caching version
of any fit-function that has at least one parameter.  The
caching version computes the associated function on the
provided wavelength grid and saves the result until the next
time a parameter value changes.  When the cacheing version is
called N times with the same parameters, the underlying
function will be evaluated only once, on the first call -- the
next N-1 calls will be handled by rebinning the cached result.

Note that the caching version will not extrapolate the model
beyond the bounds of the specified wavelength grid; any attempt
to do so will generate an error or a warning.

\begin{verbatim}
Qualifiers:
   suffix=STR   Identifier string for the caching model
                (to label different instances).
   mult         Use this qualifier when caching multiplicative
                models.  It ensures that the bin-averaged model
                value is used.  Without this qualifier, the
                rebinned model is bin-integrated.
   warn_grid    Print a warning message when the model is evaluated
                on a grid that extends beyond the cached grid;
                (the default behavior is to throw an exception).
\end{verbatim}

\begin{verbatim}
EXAMPLE:

isis> (lo,hi) = linear_grid(1,20,2000);
isis> variable caching_tbabs_name = cache_fun ("tbabs", lo, hi; mult);
isis> fit_fun ("$caching_tbabs_name(1) * mekal(1)"$);
isis> list_par;
tbabs_cache(1) * mekal(1)
 idx  param          tie-to  freeze   value         min         max
  1  tbabs_cache(1).nH   0     0          1           0      100000
  2  mekal(1).norm       0     0          1           0       1e+10
  3  mekal(1).kT         0     0          1      0.0808        79.9  keV
  4  mekal(1).nH         0     1          1       1e-05       1e+19  cm-3
  5  mekal(1).Abundanc   0     1          1           0        1000
  6  mekal(1).redshift   0     1          0           0          10
  7  mekal(1).switch     0     1          1           0           1
isis>
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{conf} %name
{Compute single-parameter confidence limits} %purpose
{(low, high) = conf(param\_index [, level [, tolerance]])} %usage
{fconf, vconf, conf\_loop, fit\_counts, fit\_flux, conf\_joint}
\index{Confidence Limits!single parameter}

By default, 90\% confidence limits are computed. The optional
second argument may be used to specify the confidence level. It
may be set to one of the values 0, 1 or 2 indicating 68\%, 90\% or
99\% confidence levels respectively.  Use \verb|fconf| to specify
a particular value of $\Delta\chi^2$.

The tolerance parameter may be used to control how precisely the
confidence limit is to be determined; the search for the parameter
value at the specified confidence limit will continue until
\begin{equation}
  \chi^2(x_{\rm limit}) - (\chi^2(x_{\rm best-fit}) + \delta\chi^2_{\rm
limit}) < {\rm tolerance} * \delta\chi^2_{\rm limit}
\end{equation}
where $\delta\chi^2_{\rm limit}$ is the change in $\chi^2$ corresponding
to the specified confidence limit.  The default \verb|tolerance| is
$10^{-3}$.

If an improved fit is found during the confidence limit search,
the function updates the internal parameters with the new best-fit
parameter values and returns {\tt low = high}.  Otherwise the
internal parameter table is not modified.

One can also refer to parameters by name:
\begin{verbatim}
  (lo, hi) = conf ("gauss(2).area");
\end{verbatim}

If it has been defined, the function
\verb|isis_fit_improved_hook| is called immediately before each
fit during the confidence limit search.  This function must be
of the form
\begin{verbatim}
   Integer_Type status = isis_fit_improved_hook ();
\end{verbatim}
A non-zero return value causes the algorithm to behave as
though a new best-fit parameter value has been detected.  If
the return value is zero, the algorithm proceeds normally. This
hook was added to support distributed computation of
single-parameter confidence limits.  It provides a mechanism to
signal slave processes that the confidence limit search should
be re-started from the beginning using a new initial set of
parameters.

\begin{verbatim}
Qualifiers:
   response     Specify responses to be used, if any.
                (default = Assigned_ARFRMF)
                Ideal_ARF | Ideal_RMF | Ideal_ARFRMF
                Assigned_ARF | Assigned_RMF | Assigned_ARFRMF

   flux        If present, use flux-corrected data
               If absent, use counts data
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{conf\_grid} %name
{Generate a parameter grid for computing confidence contours} %purpose
{Struct\_Type = conf\_grid (index, min, max, num)} %usage
{conf\_map\_counts, conf\_map\_flux, plot\_conf, save\_conf, load\_conf}
\index{Confidence Limits!parameter grid}

For example:
\begin{verbatim}
   px = conf_grid ("gauss(1).center", 11.43, 12.95, 64);
   py = conf_grid ("gauss(1).sigma", 0.01, 0.04, 64);
   s = conf_map_counts (px, py);
\end{verbatim}
or, using parameter indices:
\begin{verbatim}
   px = conf_grid (2, 11.43, 12.95, 64);
   py = conf_grid (3, 0.01, 0.04, 64);
   s = conf_map_counts (px, py);
\end{verbatim}

The parameter grid points then correspond to the array of values
\verb|[min:max:#num]|.

\end{isisfunction}

\begin{isisfunction}
{conf\_joint} %name
{Compute two-parameter joint confidence limits} %purpose
{Struct\_Type = conf\_joint (Struct\_Type[, delta\_chisqr])} %usage
{conf\_map\_counts, conf\_map\_flux, plot\_conf, save\_conf, load\_conf}
\index{Confidence Limits!joint}

By default, this routine extracts 68\% joint confidence limits
for two degrees of freedom, corresponding to a chi-square
difference of 2.30.  Use the optional argument to supply an
alternate delta-chisqr value.

The confidence limits are extracted by interpolating values from
the 2D chi-square map generated by \verb|conf_map_counts| or
\verb|conf_map_flux|. Therefore, a
finer chi-square map grid will usually allow extracting more
accurate confidence limit values. The documentation for
\verb|conf_map_counts| specifies the form of the input structures.

The return value is a structure which contains the X and Y
parameter ranges corresponding to the specified joint
confidence limit.

\begin{verbatim}
Example:
        s = conf_map_counts (px, py);
        jlim = conf_joint (s);

        => jlim = struct {xmin, xmax, ymin, ymax}
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{conf\_loop} %name
{Generate single-parameter confidence limits for specified parameters} %purpose
{(min[], max[]) = conf\_loop (params[] [, level [, tolerance]][; qualifiers])} %usage
{conf, parallel}

This function calls \verb|conf| to determine single parameter
confidence limits for a specified list of fit parameters; for
convenience, \verb|params=NULL| indicates that the loop should
include all free parameters. If a new best-fit solution during
the search for the confidence limits, a new confidence limit
search is begun, starting at the new best-fit solution.

\begin{verbatim}
Qualifier      Default        Meaning
---------      -------        -------
cl_verbose          0         Control verbosity; values < 0 are quieter.
max_param_retries   0         The number of times a slave process
                              should restart its assigned confidence
                              limit search after finding a new best-fit.
prefix         <empty>        Prefix for output files generated by
                              the save option.  If the specified
                              prefix has the form DIR/string,
                              then a subdirectory named DIR will
                              be created to receive output files
                              prefixed with `string'.
save                          If present, save intermediate results
                              and generate a parameter file containing
                              the computed confidence limits.
serial                        If present, perform computations on
                              a single CPU.
\end{verbatim}

See \verb|parallel| for more details on controlling parallel processes.

For example, this:
\begin{verbatim}
   (pmin, pmax) = conf_loop ([2,3,6,7] ; save,
                             prefix="/tmp/conf_loop/pars");
\end{verbatim}
will compute single-parameter confidence limits for 4
parameters, saving output in the specified directory.
\end{isisfunction}

\begin{isisfunction}
{conf\_map\_counts} %name
{Generate a 2D chi-square map for counts data} %purpose
{Struct\_Type = conf\_map\_counts (Struct\_Type x, Struct\_Type y [, info])} %usage
{conf\_grid, plot\_conf, save\_conf, load\_conf, conf\_map\_flux, parallel}
\index{Confidence Limits!2D maps}
\index{Confidence Limits!2D maps, log axes}

This function maps the chi-square space by stepping two
fit-parameters over a specified range.  In combination
with \verb|set_par_fun|, one can also generate confidence
contour plots which include fairly arbitrary coordinate
transformations (e.g. contours drawn vs. the log of the
parameter rather than the parameter value itself).

By default, the computations are done in parallel; use the
\verb|serial| qualifier to force the computations to be
performed on a single CPU. See \verb|parallel| for more
details on controlling parallel processes.

The parameter indices and an associated uniform grid of values
should be specified using a structure of the form:
\begin{verbatim}
   Struct_Type = struct {index, min, max, num};
\end{verbatim}
where \verb|index| gives the parameter index and the remaining
three fields specify the grid.  The simplest way to generate
this struct is to use \verb|conf_grid|.

The optional third argument is a structure whose fields provide
references to functions which can be used during confidence
contour calculation to customize recovery from failed fit
attempts, save parameters in a custom format and to mask out
parameter regions to avoid during the calculation.
This argument may have the form
\begin{verbatim}
  info = struct {fail, save, mask}
\end{verbatim}
Note that the struct need only include those fields
which are actually used.

The return value is a structure containing a 2D array of
chi-square values and other information.  It has the form:
\begin{verbatim}
  s = struct {chisqr, px, py, best, px_best, py_best};
\end{verbatim}

\begin{verbatim}
Qualifiers:
----------
   flood        If present, visit the map pixels by expanding
                outward from the best-fit, taking the initial
                parameters from the nearest completed fit.

   num_xsub     Number of sub-arrays into which the 2D array
   num_ysub     should be partitioned for parallel computations.
                By default, num_xsub=1, num_ysub=num_slaves.
                The optimal partitioning scheme depends on the
                problem at hand and the number of available CPUs.

   response     Specify responses to be used, if any.
                (default = Assigned_ARFRMF)
                Ideal_ARF | Ideal_RMF | Ideal_ARFRMF
                Assigned_ARF | Assigned_RMF | Assigned_ARFRMF

  try_global    If present, and if the the `flood' qualifier is
                also present, fit each pixel using two different
                sets of initial parameters, one from the nearest
                completed fit and one from the global best-fit.
                Keep the result that gives the lowest fit-statistic.
\end{verbatim}

Because confidence maps can be quite cpu-intensive to compute, it
may be useful to save the resulting map to a FITS file using
\verb|save_conf|.  It can then be reloaded later using
\verb|load_conf|.

Use \verb|[o]plot_conf| to plot and over-plot the confidence
contour map.

\begin{verbatim}
Example:

   px = conf_grid (2, 11.96, 12.04, 64);
   py = conf_grid (3, 0.015, 0.035, 64);
   s = conf_map_counts (px, py);

% This yields:

print(s);
    chisqr = Double_Type[64,64]
    px = Struct_Type
    py = Struct_Type
    best = 11.0525
    px_best = 12.0046
    py_best = 0.0216003
\end{verbatim}

To customize the computation of the confidence contour map,
perhaps by writing out additional information for each map
element, one can provide a definition for the \verb|save|
field of the \verb|info| structure mentioned above.
The save hook should be a function of the form
\begin{verbatim}
   define save_hook (p)
\end{verbatim}
where the \verb|p| argument passed to this function is the
information structure returned by the corresponding fit-function,
e.g. \verb|fit_counts| or \verb|fit_flux|. The hook will be called
once each time a new chi-square value is saved in the confidence
contour map. For example, to write out an ASCII table containing
the chi-square value at every map element plus all the fit
parameters, one could do the following:
\begin{verbatim}

% First, open the output file, saving the file pointer
% in a global variable

variable fp = fopen ("contour_info.txt", "w");
if (fp == NULL)
  exit(1);

%  Define the hook function so that it writes out the
%  current value of the fit-statistic and all the fit-parameters:
define save_hook (p)
{
   variable pars = get_params();

   () = fprintf (fp, "%15.6e", p.statistic);
   foreach (pars)
     {
        variable x = ();
        () = fprintf (fp, "  %15.6e", x.value);
     }
   () = fputs ("\n", fp);
}

% set the save hook to point to your function:
variable info = struct {fail, save, mask}
info.save = &save_hook;

% compute the confidence map, simultaneously generating
% the ASCII file opened above
variable map = conf_map_counts (px, py, info);

%  close the ASCII file
() = fclose(fp);
\end{verbatim}

In mapping out the behavior of chi-square it may happen that the
chosen fit algorithm fails to converge at some points in the
parameter space.  Sometimes this is merely a reflection of the
fact that the chi-square space is complex and finding the minimum
at any given point may be difficult. Unfortunately, such
convergence failures may cause the routine to take an inordinately
long time to map out the behavior of chi-square and may also
degrade the quality of the resulting map.

To provide a way to recover from these convergence failures
without restarting the chi-square mapping process, ISIS provides
a failure recovery hook via \verb|info.fail|, analogous
to the above \verb|save_hook| example.
The \verb|fail| field should provide a reference to
a function of the form
\begin{verbatim}
  define fail_hook (p1, p2, best_pars, try_pars, fit_info);
\end{verbatim}
where
\begin{verbatim}
      p1, p2 = the indices of the 2 parameters being mapped
   best_pars = an array of parameter-info structures
               defining the current best-fit parameter set.
               (see get_par_info() for details)
    try_pars = an array of parameter-info structures
               defining where a fit failed to converge.
               (see get_par_info() for details)
    fit_info = the fit_info structure returned
               by the failed call to fit_counts() or fit_flux().
\end{verbatim}
The referenced function will be called whenever \verb|fit_counts| or
\verb|fit_flux| fails.  This function should attempt to determine
the best fit given the array \verb|try_pars| as the initial
parameter state.  On return, it should update the \verb|statistic|
field of the \verb|fit_info| structure.

For example, in using the pileup model, it often happens that, the
\verb|minim| algorithm is good at getting close to the best fit
even when given a relatively poor initial guess, but is relatively
slow to improve on a ``close'' solution. In contrast, although
\verb|marquardt| may require a relatively good initial guess, it
excels at efficiently optimizing a good initial guess. To use the
strengths of both methods, one might use \verb|minim| as the
primary algorithm when mapping the chi-square space, but use
\verb|marquardt| to recover if \verb|minim| fails.

To do that, one could use a failure-recovery hook like this:
\begin{verbatim}
   define fail_hook (p1, p2, best_pars, try_pars, fit_info)
   {
        variable save_method = get_fit_method ();

        set_fit_method ("marquardt");
        () = fit_counts (&fit_info);

        set_fit_method (save_method);
   }

  info.fail = &fail_hook;
\end{verbatim}

One way to speed computation of confidence contour maps
using computationally expensive models is to mask out
regions of the parameter space which can be ignored.
The \verb|mask| hook provides this capability by providing
a reference to a function of the form
\begin{verbatim}
   define mask_hook (p1, p2)
\end{verbatim}
As arguments, this function should take the coordinates
of a point in the parameter space of interest.  If
a fit should be done at this point, the function should
return a non-zero value.  If a fit should not be done,
the function should return zero.

To compute confidence contours for one or more derived quantities,
one can use \verb|set_par_fun| to define the appropriate
transformation.  Here is an unrealistic example which serves to
illustrate the idea.

To compute confidence contours on a log-log plot, we
introduce a function to supply the coordinate transformation:
\begin{verbatim}
  define transform_fit (l,h,p)
  {
     return 1;
  }
  add_slang_function ("transform", ["log_norm", "log_kT"]);

  fit_fun ("mekal(1)*transform(1)");

  set_par("transform(1).log_norm", -3.0);
  set_par("transform(1).log_kT", 0.5);
  set_par_fun ("mekal(1).norm", "10^transform(1).log_norm)");
  set_par_fun ("mekal(2).kT", "10^transform(1).log_kT");
\end{verbatim}
The fit-parameter table is then:
\begin{verbatim}
mekal(1)*transform(1)
 idx  param               tie-to  freeze    value     min    max
  1  mekal(1).norm            0     1        0.001       0  1e+10
#=>  10^transform(1).log_norm
  2  mekal(1).kT              0     1     3.162278  0.0808   79.9
#=>  10^transform(1).log_kT
  3  mekal(1).nH              0     1            1   1e-05  1e+19
  4  mekal(1).Abundanc        0     1            1       0   1000
  5  mekal(1).Redshift        0     1            0       0     10
  6  mekal(1).Switch          0     1            1       0      1
  7  transform(1).log_norm    0     0           -3       0      0
  8  transform(1).log_kT      0     0          0.5       0      0
\end{verbatim}

With this definition, one can now compute confidence contours
using the logarithmic parameters (of \verb|transform|)
rather than the linear parameters (of \verb|mekal|).

\end{isisfunction}

\begin{isisfunction}
{conf\_map\_flux} %name
{Generate a 2D chi-square map for flux-corrected data} %purpose
{Struct\_Type = conf\_map\_flux (Struct\_Type x, Struct\_Type y [, info])} %usage
{conf\_grid, plot\_conf, save\_conf, load\_conf}
\index{Confidence Limits!2D maps}

This function is identical to \verb|conf_map_counts| except that it
applies to flux-corrected data.  See \verb|conf_map_counts| for
details.
\end{isisfunction}

\begin{isisfunction}
{vconf} %name
{Compute single-parameter confidence limits} %purpose
{(low, high) = vconf(param\_index [, level, [, tolerance]])} %usage
{conf, fconf, fit\_counts, fit\_flux, conf\_joint}
\index{Confidence Limits!single parameter}

This is the verbose form of {\tt conf}: on each iteration
it prints the current parameter value, chi-square and the change in
chi-square away from the initial value.
\end{isisfunction}

\begin{isisfunction}
{vfconf} %name
{Compute single-parameter confidence limits} %purpose
{(low, high) = fconf(param\_index [, dchisqr, [, tolerance]])} %usage
{conf, fconf, fit\_counts, fit\_flux, conf\_joint}
\index{Confidence Limits!single parameter}
This is the verbose form of {\tt fconf}: on each iteration
it prints the current parameter value, chi-square and the change in
chi-square away from the initial value.
\end{isisfunction}

\begin{isisfunction}
{del\_function}
{Delete a user-defined fit function}
{del\_function ("function")}
{add\_compiled\_function,  add\_slang\_function,list\_functions}
{\it Note:  this function is available only on systems with ELF support.  }
Only user-defined functions may be deleted.
\end{isisfunction}

\begin{isisfunction}
{delta} %name
{Delta-function line profile (for fitting)} %purpose
{delta(id)} %usage
{gauss, Lorentz, poly, bin\_center, bin\_width }

This fit-function corresponds to a delta-function in that it
contributes flux only to the single spectral bin which contains
the specified wavelength.

\end{isisfunction}

\begin{isisfunction}
{edit\_par} %name
{edit fit parameters} %purpose
{edit\_par (["filename"])} %usage
{load\_par}

This function allows the user to edit the current set of fit
parameters in a text editor. The text editor is specified by the {\sc
EDITOR} environment variable; if the environment variable is not set,
{\tt vi} is used. When using {\tt emacs}, the {\tt emacsclient}
feature (of {\tt emacs}) may be used to avoid invoking a new {\tt
emacs} process for each edit.

If a filename is specified, the model is saved in that file,
otherwise, a temporary file is generated and is deleted when editing
is finished.  If the {\sc TMPDIR} environment variable is set, the
temporary file created for editing will be placed in the indicated
directory. Otherwise, the temporary file will be placed in the current
directory.
\end{isisfunction}

\begin{isisfunction}
{diffevol} %name
{Differential Evolution optimization algorithm} %purpose
{set\_fit\_method ("diffevol")} %usage
{optimization, set\_fit\_method}

Differential Evolution is a very simple population based,
stochastic function minimizer.  For details, see
\verb|http://www.icsi.berkeley.edu/~storn/code.html|.

For help, use:
\begin{verbatim}
set_fit_method ("diffevol;help");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{egauss} %name
{Gaussian line profile function [energy grid]} %purpose
{egauss(id)} %usage
{gauss}

Because multiple Gaussians are allowed in a single fit, the {\tt id}
parameter is used as a label to distinguish multiple instances of a
particular function type. The function value assigned to each bin is the
area under the Gaussian curve which lies inside the bin:

\begin{equation}
{\rm gauss}(E_a,E_b) = {A \over \sigma \sqrt{2\pi}}
       \int_{E_a}^{E_b} \D E~
       \exp\left[-{ (E-E_0)^2 \over 2\sigma^2} \right]
\end{equation}
where $A$ is the total area (e.g. photons/s/cm${}^2$) under the Gaussian centered
at $E_0$ with width $\sigma$.
\end{isisfunction}

\begin{isisfunction}
{eval\_counts} %name
{evaluate the fit-model using the current parameters} %purpose
{s = eval\_counts([\&info\_struct])} %usage
{fit\_counts, renorm\_counts, ignore, notice, rebin, [un]assign\_arf, [un]assign\_rmf, eval\_stat\_counts}

This function evaluates the fit-model and compares it with the
counts data to compute the fit-statistic.  This is often useful
for checking the accuracy of initial parameter values before
searching for the best fit values.

See {\tt fit\_counts} for details.

\end{isisfunction}

\begin{isisfunction}
{eval\_flux} %name
{evaluate the fit-model using the current parameters} %purpose
{s = eval\_flux([\&info\_struct])} %usage
{fit\_flux, factor\_rsp, renorm\_flux, ignore, notice, rebin, [un]assign\_arf, [un]assign\_rmf}

Analogous to {\tt eval\_counts} except that the model is compared
with the flux-corrected histogram (see \verb|flux_corr|).  See
{\tt fit\_flux} for details.

\end{isisfunction}

\begin{isisfunction}
{eval\_fun} %name
{Evaluate the fit-function on a user-defined grid} %purpose
{y = eval\_fun (lo, hi)} %usage
{get\_cfun, get\_cfun2, fit\_fun, eval\_fun2, assign\_model}

This function evaluates the current fit-function on the specified
histogram grid \verb|(lo, hi)|.
\begin{verbatim}
Example:
          (lo, hi) = linear_grid (1,20,2000);   % define a grid
          y = eval_fun (lo, hi);                % get function values
\end{verbatim}
Note that \verb|eval_fun| returns the fit-function integrated over
the width of the specified bins.

If the current fit-function evaluates differently for different
datasets, it is necessary to specify the dataset index to use when
evaluating the fit-function.  Do this by setting the
\verb|Isis_Active_Dataset| index before calling \verb|eval_fun|.
For another way to do this, see \verb|assign_model|.
\end{isisfunction}

\begin{isisfunction}
{eval\_fun2} %name
{Evaluate a fit-function on a user-defined grid} %purpose
{y = eval\_fun2 (handle, lo, hi [, params [, args...]])} %usage
{get\_cfun, fit\_fun, eval\_fun, fitfun\_handle, list\_par}

Use \verb|eval_fun2| to evalute a particular fit-function on a
given histogram grid \verb|(lo, hi)| using a given vector of
function parameters.  The fit-function to be evaluated may be
specified by name (\verb|"gauss"|), by reference
(\verb|&gauss|) or by giving the handle returned by
\verb|fitfun_handle|.
\begin{verbatim}
Example:
          (lo, hi) = linear_grid (1,20,2000);   % define a grid

          % define parameters [area, center, sigma]
          pars = [100.0, 12.0, 0.025];

          % evaluate the function giving its name
          y = eval_fun2 ("gauss", lo, hi, pars);

          % evaluate the function giving a reference
          y = eval_fun2 (&gauss, lo, hi, pars);

          % evaluate the function giving a reference
          handle = fitfun_handle ("gauss");
          y = eval_fun2 (handle, lo, hi, pars);
\end{verbatim}
For repetitive function evaluations it is somewhat more
efficient to refer to the function using a handle.

The function parameters should be given in the order in which
they are listed by \verb|list_par|.  If the specified
fit-function has no parameters, the fourth argument may be
omitted or may be either \verb|NULL| or an array of length
zero.

Any additional arguments will be passed on to the fit-function.
For example, if the specified fit-function is an operator
function the operator will be applied to the vector given in
the last argument.
\begin{verbatim}
Example:
      y = eval_fun2 ("gsmooth", lo, hi, pars, arg);
\end{verbatim}

Note that \verb|eval_fun2| returns the fit-function integrated
over the width of the specified bins.
\end{isisfunction}

\begin{isisfunction}
{eval\_stat\_counts} %name
{Evaluate the (counts) fit-statistic using the current parameters} %purpose
{Struct\_Type = eval\_stat\_counts()} %usage
{eval\_stat\_flux, fit\_counts}

This function recomputes the fit-statistic for the counts data
without re-evaluating the current model.

This necessarily assumes that the model has already been
computed on the correct grid.  Note that the model stored
internally will be inconsistent if the data have been modified
since the last model evaluation (e.g. if the data were rebinned
or if different data bins have been ignored or noticed).  If
the stored model is inconsistent, the computed statistic value
will also be inconsistent.

\end{isisfunction}

\begin{isisfunction}
{eval\_stat\_flux} %name
{Evaluate the (flux) fit-statistic using the current parameters} %purpose
{Struct\_Type = eval\_stat\_flux()} %usage
{eval\_stat\_counts, fit\_counts}

This function recomputes the fit-statistic for the
flux-corrected data without re-evaluating the current model.

This necessarily assumes that the model has already been
computed on the correct grid.  Note that the model stored
internally will be inconsistent if the data have been modified
since the last model evaluation (e.g. if the data were rebinned
or if different data bins have been ignored or noticed).  If
the stored model is inconsistent, the computed statistic value
will also be inconsistent.

\end{isisfunction}

\begin{isisfunction}
{exclude} %name
{Exclude datasets from the fit} %purpose
{exclude (data\_list)} %usage
{include, ignore, notice}

This function is similar to \verb|ignore| except that it
allows one to exclude a dataset from a fit without changing
which bins are currently noticed.

For example, suppose you want to fit a narrow wavelength
range in 3 datasets simultaneously.  After noticing those
wavelength ranges and ignoring everything else, you might
want to try excluding one or more datasets from the fit,
but you don't want to lose the noticed wavelength ranges.
This interaction would look something like
\begin{verbatim}
   % ... try fitting all 3 at once ...
   xnotice ([1:3], 12.4, 13.5);

   %  -- now fit dataset 2 alone --
   exclude (1,3);

   % -- re-include dataset 1, with 12.4-13.5 angstroms
   %    still noticed, etc.
   include (1);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{fconf} %name
{Compute single-parameter confidence limits} %purpose
{(low, high) = fconf(param\_index [, dchisqr, [, tolerance]])} %usage
{conf, fconf, fit\_counts, fit\_flux, conf\_joint}

This form of \verb|conf| allows specifying a particular value
of $\Delta\chi^2$ appropriate for the desired confidence limit.
By default, \verb|dchisqr = 2.71|, and 90\% confidence limits are
computed.

One can also refer to parameters by name:
\begin{verbatim}
  (lo, hi) = fconf ("gauss(2).area");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{fit\_counts} %name
{search for best fit parameters} %purpose
{s = fit\_counts ([\&info\_struct])} %usage
{eval\_counts, renorm\_counts, ignore, notice, freeze, thaw,
rebin, [un]assign\_arf, [un]assign\_rmf, fit\_flux, fit\_search, set\_post\_model\_hook}

By default, this function fits the current model to the counts
data by folding the model through the instrument response. If no
instrument response has been assigned, an ideal instrument is
assumed.  If no errors occurred during the fit, the return status
is zero, otherwise the return value is -1.

The optional \verb|Struct_Type| argument should provide the address of
a structure:
\begin{verbatim}
 variable info_struct = struct {statistic, num_variable_params, num_bins}
\end{verbatim}
On return, the struct fields contain the value of the $\chi^2$
fit-statistic ({\tt statistic}), the number of variable fit
parameters ({\tt num\_variable\_params}) and the number of data
bins ({\tt num\_bins}).

The {\tt response} qualifier specifies what instrument
responses should be applied.  Supported qualifier values are
\verb|Ideal_ARF|, \verb|Ideal_RMF|, \verb|Ideal_ARFRMF|,
\verb|Ideal_RMFARF|, \verb|Assigned_RMF|,
\verb|Assigned_ARFRMF|, \verb|Assigned_RMFARF|.
As indicated above, the default qualifier value is
\verb|Assigned_RMFARF|.

When folding models through the instrument response, the spectral
model will be computed on the ARF grid. Furthermore, the model
will normally be evaluated only over those wavelength ranges that
can contribute to a noticed data bin, as determined by the
available RMF (user-defined fit-kernels may change this behavior).
For example, consider the case of a dispersed spectrum produced by
a diffraction grating. If a single small wavelength range in the
data is noticed for fitting, higher order contributions from
outside this range will also be included in the predicted counts
as long as the RMF includes the higher order contributions. Note
that this means that the spectral model will be computed for all
wavelength ranges which contribute to higher-order contamination,
even if those wavelength ranges correspond to regions of the data
that are currently being ignored for purposes of finding the best
fitting model.

Several minimization algorithms are available -- see {\tt
optimization}. Aside from cases where the fit-function
evaluation itself might fail, it is possible for the fitting
algorithm to fail either because a minimum fit-statistic was
not found within a reasonable number of iterations (see
Bevington \& Robinson (1992) for more details).  If the fit
algorithm fails, make sure that the initial parameter values
are reasonably close to a good fit and that the current
parameter values haven't run into the specified upper/lower
range limits. Then, try repeating the fit with fewer variable
parameters (see {\tt freeze}, {\tt thaw}). See also {\tt
Fit\_Verbose}.

When the S-Lang function \verb|isis_prefit_hook| is defined in
the Global namespace, isis will execute this function
immediately before the fit-function is evaluated for the
noticed datasets. For example, one might use this hook together
with \verb|set_eval_grid_method| to specify a default method
for constructing the grid upon which the model will be
evaluated:
\begin{verbatim}
  public define isis_prefit_hook ()
  {
     message ("called prefit hook");
     set_eval_grid_method (MERGED_GRID, all_data);
  }
\end{verbatim}
With this definition of the hook, the \verb|MERGED_GRID|
method will be used whenever multiple datasets are fitted
simultaneously. See \verb|set_eval_grid_method| for
more details.

Use the \verb|fit_verbose| qualifier to provide a verbose
level that overides the current setting of the
intrinsic variable \verb|Fit_Verbose|.

\end{isisfunction}

\begin{isisfunction}
{fit\_flux} %name
{search for best fit parameters} %purpose
{s = fit\_flux ([\&info\_struct])} %usage
{eval\_flux, renorm\_flux, factor\_rsp, ignore, notice, freeze, thaw, rebin, [un]assign\_arf, [un]assign\_rmf, fit\_counts, fit\_search}

Analogous to \verb|fit_counts| except that the model is
compared with the flux-corrected histogram (see
\verb|flux_corr|) using the current fit-statistic. By
definition, the model for the flux-corrected histogram is
\begin{equation}
  F(h) = \int dE R(h,E) s(E),
\end{equation}
where $E$ is the incident photon energy, $s(E)$ is the model
spectrum, $R(h,E)$ is the redistribution function or RMF and
$h$ is the detector channel. Note that this definition is
independent of the assigned fit-kernel.  When a fit-kernel
supports flux-correction, that operation should be consistent
with this definition for $F(h)$.

When the assigned redistribution function includes the effective
area, an error will be generated.  Use \verb|factor_rsp| to
factor such a response matrix, $R(h,E)$ into an effective area
function, $a(E)$ and a normalized redistribution function,
$r(h,E)$ satisfying $R(h,E) = r(h,E)a(E)$. If an effective area
function, $A(E)$ has also been assigned, it may be modified to
include the $a(E)$ factor so that the product, $R(h,E)A(E)$ is
preserved. For example:
\begin{verbatim}
    A = load_arf ("arf.fits");    % arf.fits provides A(E)
    R = load_rmf ("rsp.fits");    % RMF includes additional area factor `a'
    a = factor_rsp (R);           % factor R(h,E) -> r(h,E)*a(E)

 % To preserve the product, A*R = (A*a)*r = A'*r
 % replace A with A' = A*a:

    A_struct = get_arf(A);
    a_struct = get_arf(a);
    A_struct.value *= a_struct.value;
    put_arf (A, A_struct);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{fit\_fun} %name
{define a fit function without prompting for parameters} %purpose
{fit\_fun("function\_string")} %usage
{assign\_model, get\_fit\_fun, ifit\_fun, Lorentz, gauss, load\_par, set\_par, set\_par\_fun}

The function definition string must be a valid \slang\
expression.  For example, to fit a sum of two Gaussians
use
\begin{verbatim}
     isis> fit_fun("gauss(1) + gauss(2)");
\end{verbatim}
The integer indices specify different instances of the Gaussian
fit-function.  By default, a single fit-function is applied
to all currently noticed bins in all loaded datasets.

Fit-function parameters may be defined as functions of other
fit-parameters (see \verb|set_par_fun|).

Fit-functions may take additional arguments (see
\verb|add_slang_function|), and may even return additional
arguments, with the restriction that the model string must
ultimately evaluate to a \verb|Double_Type| array.

A fit-function which evaluates differently for different datasets may be
defined using the \isisx intrinsic variable \verb|Isis_Active_Dataset| or by
using \verb|assign_model|.

As an example of how to use \verb|Isis_Active_Dataset|,
consider the following:
\begin{verbatim}
   public define my_complicated_function ()
   {
      if (Isis_Active_Dataset == 1)
        {
           return gauss(1) + gauss(2);
        }
      else if (Isis_Active_Dataset == 2)
        {
           return Lorentz(1) + Lorentz(2);
        }
   }

   fit_fun ("my_complicated_function()");
\end{verbatim}
When \verb|my_complicated_function()| is evaluated for dataset 1,
it will return a sum of Gaussians; when evaluated for dataset 2,
it will return a sum of Lorentzians. In effect, each dataset has
been assigned a different fit-function. Here, we have assumed that
exactly two datasets are loaded and are listed as dataset 1 and
dataset 2 in the internal table (see \verb|list_data|).

The ability to retain parameter values from previous fits is a useful
feature which may help minimize re-entering parameter values.  For example,
suppose the initial fit-model is defined as the sum of two Lorentzians:
\begin{verbatim}
     isis> fit_fun("Lorentz(1) + Lorentz(2)");
\end{verbatim}
After seeing the resulting fit, one might decide to try a Lorentzian
plus a Gaussian,
\begin{verbatim}
     isis> fit_fun("Lorentz(1) + gauss(2)");
\end{verbatim}
Seeing that result, one might decide the first fit was better;
on returning to that fit-function:
\begin{verbatim}
     isis> fit_fun("Lorentz(1) + Lorentz(2)");
\end{verbatim}
the coefficients for Lorentz(2) will have retained their
values from the first attempt.  This feature can simplify trying
different combinations of functions to produce an
acceptable model fit.

It is important to remember that, because the fit-function value
is interpreted as the value of an integral over the width of each bin, some
syntactically correct combinations of intrinsic fit-functions
are not analytically consistent.  For example, the function definition
\begin{verbatim}
"Lorentz(1) * Lorentz(2) + 4.0 * poly(1)",
\end{verbatim}
is syntactically correct, but analytically inconsistent because
\begin{eqnarray*}
\text{"Lorentz(1) * Lorentz(2)"} &\equiv&
\left(\int_{\lambda_{\rm lo}}^{\lambda_{\rm hi}} L(1)~\D\lambda\right) \times
\left(\int_{\lambda_{\rm lo}}^{\lambda_{\rm hi}} L(2)~\D\lambda'\right) \nonumber\\
&\not=& \int_{\lambda_{\rm lo}}^{\lambda_{\rm hi}} L(1) L(2)~\D\lambda
\end{eqnarray*}

Utility functions {\tt bin\_width} and {\tt bin\_center} are
available to support fitting and evaluating bin-averaged and
bin-centered functions.

If the model string is either \verb|NULL| or the empty string,
then the current model definition, if any, is deleted.

\end{isisfunction}

\begin{isisfunction}
{fitfun\_handle} %name
{Obtain a handle for a given fit-function} %purpose
{handle = fitfun\_handle ("name")} %usage
{eval\_fun2}

See \verb|eval_fun2| for a usage example.

\end{isisfunction}

\begin{isisfunction}
{fit\_search} %name
{Search the fit-parameter space} %purpose
{best = fit\_search (num, \&ref [; qualifiers])} %usage
{fit\_counts, eval\_counts, fit\_flux, eval\_flux, save\_par, fit\_search\_info, parallel}

Use this function to automate the process of exploring the
fit-parameter space. The first argument specifies the number of
Monte-Carlo trials. The second argument provides a reference to
a function which will be used to test each randomly generated
parameter set. This function may simply evaluate the model for
that parameter set (e.g. \verb|&eval_counts|) or it may search
for the best fit given that starting point (e.g.
\verb|&fit_counts|).

For each Monte-Carlo trial, random parameter values are selected
from within the [\verb|min|, \verb|max|) range for each parameter.
The test function, \verb|ref|, is then applied using those
parameter values.

Intermediate results of the search may be saved in a
subdirectory specified by the \verb|dir| qualifier.  If the
qualifier \verb|save_all| is present, a parameter file will be
saved for every trial.  Otherwise, a parameter file will be
saved each time a new best-fit is encountered.

Each saved parameter file will include a comment line giving
the associated fit-statistic. Additional output information may
recorded in a user-defined format by defining an
\verb|isis_save_par_hook| which uses the \verb|fit_search_info|
function (See \verb|save_par| and \verb|fit_search_info| for
more information).

For example, to carry out 100 Monte-Carlo trials fitting counts
data, saving each successive best-fit in a sub-directory called
"trials":
\begin{verbatim}
   stat = fit_search (100, &fit_counts; dir="trials");
\end{verbatim}
Each improved parameter set will be saved in files named
\begin{verbatim}
   trials/best.$pid.0
   trials/best.$pid.1
   trials/best.$pid.2
   etc.
\end{verbatim}
where \verb|$pid| is the process id.

To carry out 50 Monte-Carlo trials simply evaluating
flux-corrected data (not attempting to find the best fit for each
trial), and without saving any parameter files to disk:
\begin{verbatim}
   stat = fit_search (50, &eval_counts);
\end{verbatim}

On multi-core computers, this function runs in parallel on all
available compute cores. To force serial execution, use the
\verb|serial| qualifier. See \verb|parallel| for more details
on controlling parallel processes.

\end{isisfunction}

\begin{isisfunction}
{fit\_search\_info} %name
{Retrieve results of the most recent fit} %purpose
{Struct\_Type = fit\_search\_info ()} %usage
{save\_par, fit\_search, fit\_counts}

As \verb|fit_search| continues, the info structure
for the most recent fit is saved internally.
This structure may be retrieved by calling \verb|fit_search_info|.
This function is primarily intended for use in conjunction
with \verb|isis_save_par_hook|.  See \verb|save_par|
for more information.

\end{isisfunction}

\begin{isisfunction}
{fit\_verbose\_info\_hook} %name
{Print verbose status information during a fit} %purpose
{fit\_verbose\_info\_hook (statistic, params[], param\_names[])} %usage
{set\_post\_model\_hook, fit\_counts}

When \verb|Fit_Verbose| is positive, the \slang\ functions
\verb|open_fit_verbose_hook|, \verb|fit_verbose_info_hook| and
\verb|close_fit_verbose_hook| are called.  No arguments are
passed to \verb|open_fit_verbose_hook| and
\verb|close_fit_verbose_hook| and none are returned from either
function.  Before the first function evaluation,
\verb|open_fit_verbose_hook| is called to perform any required
initializations (such as opening an output file).  After each
function evaluation, \verb|fit_verbose_info_hook| is called
with the names and values of all the parameters and the value
of the fit-statistic.

By default, the fit statistic and the parameter names and
values are printed to \verb|stdout|.

Users may provide alternate definitions of these functions in
the \verb|Global| namespace to print the parameter values to a
file or to perform any other suitable task.

For example, to print the parameter values into a file, one
could provide the following function definitions (which, for
brevity, omit all error checking):

\begin{verbatim}
% Use a private, file-global variable to hold the file pointer.
private variable Fp = NULL;

public define open_fit_verbose_hook ()
{
   Fp = fopen ("fit_verbose_log.txt", "a");
}

public define close_fit_verbose_hook ()
{
   () = fclose (Fp);
}

define write_par (name, value)
{
   () = fprintf (Fp, "%15.8e = %s\n", value, name);
}

public define fit_verbose_info_hook (stat, values, names)
{
   () = fprintf (Fp, "%11.4e = %s\n", stat, Fit_Statistic);
   array_map (Void_Type, &write_par, names, values);
}
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{freeze} %name
{freeze one or more fit parameters} %purpose
{freeze (par\_list)} %usage
{thaw, tie, untie}
\index{Fitting!freezing parameters}

{\tt par\_list} may be either a single parameter index or an
integer array of indices.
\begin{verbatim}
    freeze(3);           % freeze param 3
    freeze([1:4]);       % freeze params 1,2,3,4
\end{verbatim}

One can also refer to parameters by name:
\begin{verbatim}
 freeze ("gauss(2).area");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{gainshift} %name
{Kernel for introducing a gain shift} %purpose
{set\_kernel (data\_index, "gainshift")} %usage
{set\_kernel, fit\_fun}

This kernel applies a linear transformation of the form
\begin{verbatim}
   E'(c) = E(c)/slope - intercept
\end{verbatim}
to the energy grid of the model counts spectrum, \verb|E(c)|, i.e. the energy
of channel c from the original EBOUNDS array.  The parameters of the linear
transformation are fittable. Aside from the energy grid transformation, this
kernel performs the same forward-fold computation as the standard fit kernel.
The energy grid of any associated background spectrum is not modified; the
background associated which each detector channel remains fixed.
Flux-correction is not supported.

\end{isisfunction}

\begin{isisfunction}
{gauss} %name
{Gaussian line profile function [wavelength grid]} %purpose
{gauss(id)} %usage
{Lorentz, voigt, poly, delta, bin\_width, bin\_center}

Because multiple Gaussians are allowed in a single fit, the {\tt id}
parameter is used as a label to distinguish multiple instances of a
particular function type. The function value assigned to each bin is the
area under the Gaussian curve which lies inside the bin:

\begin{equation}
{\rm gauss}(\lambda_a,\lambda_b) = {A \over \sigma \sqrt{2\pi}}
       \int_{\lambda_a}^{\lambda_b} \D\lambda~
       \exp\left[-{ (\lambda-\lambda_0)^2 \over 2\sigma^2} \right]
\end{equation}
where $A$ is the total area (e.g. photons/s/cm${}^2$) under the Gaussian centered
at $\lambda_0$ with width $\sigma$.
\end{isisfunction}

\begin{isisfunction}
{get\_convolved\_model\_flux} %name
{load convolved model values into a \slang\ structure} %purpose
{Struct\_Type =~get\_convolved\_model\_flux~(hist\_index)} %usage
{get\_model\_flux, get\_data\_flux, factor\_rsp}

This function returns a structure with three array fields,
{\tt bin\_lo}, {\tt bin\_hi} and {\tt value}:
\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [photons/sec/cm^2]
\end{verbatim}
Use this function to load the convolved model flux for data set
{\tt hist\_index} into \slang\ array variables.

The value returned by \verb|get_convolved_model_flux| is
\begin{equation}
    F(h) = \int dE R(h,E) S(E)
\end{equation}
where the integral extends over the full energy range, ensuring
that the instrumental redistribution is fully accounted for.

Keep in mind that, when the RMF is not unit-normalized, the
value computed by \verb|eval_flux| may not be directly
comparable with the integral of $S(E)$ over the bin-width. In
such cases, one may wish to consider using \verb|factor_rsp| to
factor the RMF into a unit-normalized redistribution function
and a wavelength-dependent normalization factor.  This
normalization factor might then be shifted into the ARF.

For example:
\begin{verbatim}
        rmf = load_rmf ("un_normalized_rmf.fits");
        arf = load_arf ("arf.fits");

        % factor out a normalized RMF:
        new_arf_index = factor_rsp (rmf);

        % shift the norm factor into the ARF:
        factor = get_arf (new_arf_index);
        arf_struct = get_arf (arf);
        arf_struct.value *= factor.value;
        put_arf (arf, arf_struct);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_cfun} %name
{get the y-values of the differential fit-function} %purpose
{y = get\_cfun (x\_array)} %usage
{eval\_fun, fit\_fun, assign\_model}

Given an array of x-coordinate values {\tt x\_array}, this function returns
an array containing the corresponding (unbinned) values of the currently
defined fit-function. See also {\tt [o]plot}
\begin{verbatim}
Example:
          x = [8.5 : 10.2 : 0.001];      % define an x-grid
          y = get_cfun (x);              % get function values

          oplot(x, get_cfun(x));         % another usage example
\end{verbatim}

Note that, if the current fit-function evaluates differently for
different datasets, it is necessary to specify the dataset index
to use when evaluating the fit-function.  Do this by setting the
\verb|Isis_Active_Dataset| index before calling \verb|eval_fun|.
For another way to do this, see \verb|assign_model|.
\end{isisfunction}

\begin{isisfunction}
{get\_cfun2} %name
{Evaluate a differential fit-function on a user-defined grid} %purpose
{y = get\_cfun2 (handle, x, [, params])} %usage
{get\_cfun, fit\_fun, eval\_fun2, fitfun\_handle, list\_par}

Use \verb|get_cfun2| to evalute a particular fit-function on
a particular wavelength grid using a given vector of
function parameters.  The fit-function to be evaluated may be
specified by name (\verb|"voigt"|), by reference
(\verb|&voigt|) or by giving the handle returned by
\verb|fitfun_handle|.
\begin{verbatim}
Example:
          e = [0.9:1.1:1.e-3];   % define a grid

          % define parameters [norm, energy, fwhm, vtherm]
          pars = [1.0, 1.0, 0.02, 1.e3];

          % evaluate the function giving its name
          y = get_cfun2 ("voigt", _A(e), pars);

          plot(e, reverse(y));
\end{verbatim}
For repetitive function evaluations it is somewhat more
efficient to refer to the function using a handle
(e.g. see \verb|eval_fun2|).

The function parameters should be given in the order in which
they are listed by \verb|list_par|.  If the specified
fit-function has no parameters, the corresponding argument may be
omitted or may be either \verb|NULL| or an array of length
zero.
\end{isisfunction}

\begin{isisfunction}
{get\_fit\_fun} %name
{Get the current fit-function definition} %purpose
{s = get\_fit\_fun ()} %usage
{fit\_fun, get\_par\_info, get\_par, get\_params, get\_fun\_components}

If no fit-function has been defined, this function returns NULL.

\begin{verbatim}
For example:

   isis> get_fit_fun;
   NULL
   isis> fit_fun ("gauss(1) + poly(1)");
   isis> s = get_fit_fun();
   isis> print(s);
   gauss(1) + poly(1)
   isis>
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_fun\_components} %name
{Get the names of the components of the current fit-function} %purpose
{names[] = get\_fun\_components ()} %usage
{get\_fit\_fun, fit\_fun, get\_par\_info, get\_par, get\_params, get\_fun\_params}

If no fit-function has been defined, this function returns NULL.
For example:
\begin{verbatim}
   isis> fit_fun ("gauss(1) + wabs(1)*mekal(1) + gauss(1)");
   isis> s=get_fun_components();
   isis> print(s);
   "gauss(1)"
   "mekal(1)"
   "wabs(1)"
\end{verbatim}

This function can be used in scripts together with other other
information retrieval functions to automatically access all
details about the current fit function. Continuing the example,
one might do something like:

\begin{verbatim}
   isis> p = get_params (get_fun_params(s[0]));
   isis> p;
   Struct_Type[3]
   isis> print(p[0]);
    name = gauss(1).area
    index = 1
    value = 1
    min = -1.79769e+308
    max = 1.79769e+308
    freeze = 0
    tie = 0
    is_a_norm = 1
    fun = NULL
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_fun\_params} %name
{get the parameter indices for a given fit-function} %purpose
{y = get\_fun\_params ("gauss(1)")} %usage
{fit\_fun, get\_params, set\_params}

For example:
\begin{verbatim}
   fit_fun ("gauss(1) + poly(1)");
   isis> p = get_fun_params ("poly(1)");
   isis> print(p);
   4
   5
   6
   isis> v = get_params(p);
   isis> print(v[0]);
       name = poly(1).a0
       index = 4
       value = 1
       min = -1.79769e+308
       max = 1.79769e+308
       freeze = 0
       tie = 0
       is_a_norm = 1
       fun = NULL
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_kernel} %name
{Determine the fit-kernel assigned to a dataset} %purpose
{s = get\_kernel (hist\_index)} %usage
{load\_kernel, print\_kernel,set\_kernel, list\_kernels}

Note that the value returned by this function is accurate only
after the kernel has been assigned and the current fit-function
has been evaluated at least once.

If the fit-kernel is uninitialized, an error will be generated. If
the fit-kernel has been initialized, but has been changed since
the last time the fit-function was evaluated, the value returned
by this function will not reflect the change.
\end{isisfunction}

\begin{isisfunction}
{get\_model\_counts} %name
{load binned model values into a \slang\ structure} %purpose
{Struct\_Type = get\_model\_counts(hist\_index)} %usage
{get\_data\_counts}

This function returns a structure with three array fields,
{\tt bin\_lo}, {\tt bin\_hi} and {\tt value}:
\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [counts]
\end{verbatim}
Use this function to load the binned model counts for data set
{\tt hist\_index} into \slang\ array variables.

The model counts are computed using
\begin{equation}
   C(h) = B(h) + t \int dE {\cal F}\left(R(h,E),A(E),S(E)\right)
\end{equation}
where $B(h)$ is the background spectrum, $t$ is the exposure
time, ${\cal F}$ is the fit-kernel, $R(h,E)$ is the RMF, $A(E)$
is the ARF and $S(E)$ is the model for the incident photon
spectrum. Note that the model includes any background
contribution which has been assigned.
\end{isisfunction}

\begin{isisfunction}
{get\_model\_flux} %name
{load binned model values into a \slang\ structure} %purpose
{Struct\_Type =~get\_model\_flux~(hist\_index)} %usage
{get\_data\_flux, factor\_rsp}

This function returns a structure with three array fields,
{\tt bin\_lo}, {\tt bin\_hi} and {\tt value}:
\begin{verbatim}
hist_index = integer index of spectrum in internal list
  s.bin_lo = bin left edge [Angstrom]
  s.bin_hi = bin right edge [Angstrom]
   s.value = bin value [photons/sec/cm^2]
\end{verbatim}
Use this function to load the binned model flux for data set
{\tt hist\_index} into \slang\ array variables.

The value returned by \verb|get_model_flux| is
\begin{equation}
    F(h) = \int dE S(E)
\end{equation}
where the integral extends over the energy width of bin $h$.

\end{isisfunction}

\begin{isisfunction}
{get\_num\_pars} %name
{get the number of parameters in the current fit model} %purpose
{n = get\_num\_pars ()} %usage
{get\_par, set\_par, list\_par, save\_par, get\_num\_pars, get\_par\_info}
This function is useful in scripts which may need to loop over
all parameters of the current model.
For example, to print information for each fit parameter, use:
\begin{verbatim}
   variable n, i;

   n = get_num_pars ();
   _for (1, n, 1)
      {
          i = ();
          print(get_par_info (i));
      }
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{get\_par} %name
{get the value of a fit parameter} %purpose
{par = get\_par (idx)} %usage
{set\_par, list\_par, save\_par, , get\_num\_pars, get\_par\_info, get\_fit\_fun}
Given the index ({\tt idx}) of a fit parameter, one can retrieve its
value in a \slang\ variable.  The indices of current fit parameters
may be determined using {\tt list\_par}.

One can also refer to parameters by name:
\begin{verbatim}
  x = get_par ("gauss(1).area");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{get\_params} %name
{Copy fit-parameter information into an array of structs} %purpose
{Struct\_Type[] = get\_params ([list])} %usage
{set\_params, set\_par, get\_fit\_fun}

This function returns an array of structs:
\begin{verbatim}
isis> fit_fun ("gauss(1)");
isis> list_par;
gauss(1)
 idx  param        tie-to  freeze     value      min       max
  1  gauss(1).area     0     0             1        0        0
  2  gauss(1).center   0     0            12        0        0
  3  gauss(1).sigma    0     0         0.025        0        0
isis> x=get_params;
isis> print(x[2]);
    name = gauss(1).sigma
    index = 3
    value = 0.025
    min = -1.79769e+308
    max = 1.79769e+308
    freeze = 0
    tie = 0
    is_a_norm = 0
    fun = NULL
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{get\_par\_info} %name
{get all information on a fit parameter} %purpose
{s = get\_par\_info (idx)} %usage
{get\_num\_pars, get\_par, set\_par, list\_par, save\_par, get\_fit\_fun}
Given the index ({\tt idx}) of a fit parameter, one can retrieve
the associated information from the internal parameter table;  this
information is returned as fields of a \slang\ structure.
The indices of current fit parameters
may be determined using {\tt list\_par}.
For example:
\begin{verbatim}
isis> s=get_par_info(2);
isis> print(s);
{name="gauss(1).center",
 index=2,
 value=12.0,
 min=-1.7976931348623157e+308,
 max=1.7976931348623157e+308,
 hard_min=-inf,
 hard_max=inf,
 step=0.0,
 relstep=0.0,
 freeze=0,
 tie=NULL,
 units="A",
 is_a_norm=0,
 fun=NULL}
\end{verbatim}
If non-NULL, the \verb|fun| parameter contains the expression string specified
by \verb|set_par_fun|.

One can also refer to parameters by name:
\begin{verbatim}
  x = get_par_info ("gauss(1).area");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{ifit\_fun} %name
{define a fit function with interactive prompting for parameters} %purpose
{ifit\_fun ("function\_string")} %usage
{fit\_fun, plot\_bin\_density, get\_cfun}

This function reads cursor positions from an existing bin-{\it density} plot
of a data-set and uses those coordinates to compute initial guesses for
parameters of the specified function.
\begin{verbatim}
Example:
      plot_bin_density;            % MUST plot bin-density to use ifit_fun
      ignore ([1:12]);             % ignore all data, then next step will
                                   % notice a single region for fitting
      xnotice(1, 6,7);             % select the data interval for fitting
      xrange(6,7);                 % set the plot x-limits to the same interval
      yrange(y1,y2);               % set the plot y-limits appropriately
      plot_data_flux (1);
                                  % point and click to define fit params
      ifit_fun("Lorentz(1) + Lorentz(2) + poly(1)");

      eval_flux;                  % evaluate the model using those params
      oplot_convolved_model_flux(1);        % over-plot the model
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{ignore} %name
{Ignore a wavelength range when fitting} %purpose
{ignore (hist\_index\_list [, lambda\_lo, lambda\_hi])} %usage
{ignore\_en, notice,  xnotice, exclude, include}

{\tt hist\_index\_list} may be either a single histogram index or an integer
array of indices. All data bins are noticed by default.  If either of the
wavelength range arguments are missing, the limiting value is taken from the
input data.  Therefore, omitting both range arguments ignores the entire
wavelength range.

\begin{verbatim}
Example:
      ignore ([1:4]);               % ignore data sets 1,2,3,4
      ignore ([2:4], 10, 11);       % ignore 10 <= lambda < 11 for
                                    % data sets 2,3 and 4.
      ignore ([ [1:4], [6:8] ]);    % ignore data sets 1-4 and 6-8
\end{verbatim}

Note that when fitting data using an ARF and RMF the RMF is used
to determine which model bins contribute to the noticed data bins.
Use \verb|ignore_en| to ignore an energy range in keV.

\end{isisfunction}

\begin{isisfunction}
{ignore\_en} %name
{Ignore an energy range when fitting} %purpose
{ignore\_en (hist\_index\_list [, E\_lo, E\_hi])} %usage
{ignore, notice\_en,  xnotice\_en, exclude, include}

This is an alternate form of the \verb|ignore| function that
takes an energy range in keV instead of a wavelength range.
See \verb|ignore| for details.

\end{isisfunction}

\begin{isisfunction}
{ignore\_list} %name
{Ignore a list of bins when fitting} %purpose
{ignore\_list (datasets[], list)}   %usage
{ignore, notice\_list, xnotice, exclude, include}

This is an alternate form of the \verb|ignore| function that
takes a list of bin indices instead of a wavelength range.
For example:
\begin{verbatim}
   % to ignore bins with < 10 counts
   d = get_data_counts(1);
   ignore_list (1, where(d.value < 10.0));
\end{verbatim}
Note that the list of bin indices refers to the internal
data which is stored in increasing wavelength order.

See \verb|ignore| for details.

\end{isisfunction}

\begin{isisfunction}
{ignore\_values} %name
{Ignore bins with values exceeding a threshold} %purpose
{ignore\_values (datasets[], lo1, hi1 [,lo2, hi2...] ; qualifiers)}   %usage
{ignore, ignore\_list, notice, notice\_values, notice\_list, xnotice, exclude, include}

Ignore bins in specific wavelength or energy intervals that
also meet criteria specified by the supported qualifiers. If
multiple datasets are specified, their spectral grids should
match exactly.

\begin{verbatim}
Qualifier    Default     Meaning
---------    -------     -------
unit          Angstrom   physical units of (lo, hi)
min_sum       NULL       if defined, ignore only bins for which
                            (sum over datasets) >= min_sum
min_val       NULL       if defined, ignore only bins for which
                            (value in every dataset) >= min_val
\end{verbatim}

For example,
\begin{verbatim}
   ignore_values ([2,4,5], 1.0, 1.5 ; min_sum=20, min_val=5, unit="kev");
\end{verbatim}
will ignore bins falling entirely within the range 1-1.5 keV
and which also have more than 20 counts when summed over
datasets 2,4 and 5 and which have at least 5 counts in
each of those datasets.

\end{isisfunction}

\begin{isisfunction}
{include} %name
{Include a list of datasets in the fit} %purpose
{include (data\_list)} %usage
{exclude, ignore, notice\_en,  xnotice\_en}

See \verb|exclude| for details.

\end{isisfunction}

\begin{isisfunction}
{list\_fit\_methods}
{List the currently defined fit methods}
{list\_fit\_methods}
{load\_fit\_method, load\_fit\_statistic, add\_slang\_statistic}

\end{isisfunction}

\begin{isisfunction}
{list\_free}
{List all free parameters}
{list\_free ([arg])}
{list\_par, set\_par, get\_par}

The optional argument is used to redirect the output.  If
\verb|arg| is omitted, the output goes to \verb|stdout|.  If
\verb|arg| is of type \verb|Ref_Type|, it the output string is
stored in the referenced variable.  If \verb|arg| is a file name,
the output is stored in that file.  If \verb|arg| is a file
pointer (\verb|File_Type|) the output is written to the
corresponding file.

This function lists all free fit parameters; it is equivalent
to \verb|list_par(1)|.  See \verb|list_par| for details.

\end{isisfunction}

\begin{isisfunction}
{list\_functions}
{List the currently defined fit functions}
{list\_functions}
{add\_compiled\_function, add\_slang\_function, del\_function}

The generated listing gives the name of each function.

\begin{verbatim}
Example:
isis> list_functions;
Lorentz         bin_width       egauss          pileup
Powerlaw        blackbody       gauss           poly
isis>
\end{verbatim}

See \S\ref{chap:xspec-module}) for information on accessing
\xspec\ source models.
\end{isisfunction}

\begin{isisfunction}
{list\_kernels} %name
{list the available fit-kernels} %purpose
{list\_kernels} %usage
{set\_kernel, get\_kernel, load\_kernel}

\begin{verbatim}
Example:
isis> list_kernels;
"pileup"
"std"
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{list\_par} %name
{list current fit function and parameters} %purpose
{list\_par ([arg])} %usage
{list\_free, edit\_par, set\_par, get\_par, save\_par, set\_par\_fun}

The optional argument is used to redirect the output.  If
\verb|arg| is omitted, the output goes to \verb|stdout|.  If
\verb|arg| is of type \verb|Ref_Type|, it the output string is
stored in the referenced variable.  If \verb|arg| is a file name,
the output is stored in that file.  If \verb|arg| is a file
pointer (\verb|File_Type|) the output is written to the
corresponding file.

The parameter listing looks like this:
\begin{verbatim}
gauss(1) + poly(1)
 idx  param        tie-to  freeze    value      min          max
  1  gauss(1).area     0     0       103.6        0            0
  2  gauss(1).center   0     0        12.1       10           13
  3  gauss(1).sigma    0     0       0.022    0.001          0.1
  4  poly(1).a0        0     0       1.2e4        0            0
  5  poly(1).a1        0     1           0        0            0
  6  poly(1).a2        0     1           0        0            0
\end{verbatim}

The first line defines the form of the fit-function. The parameter index
{\tt idx} may be used to refer to individual fit parameters (see {\tt
set\_par}).  {\tt freeze = 1 (0)} indicates that the corresponding parameter
value is frozen (variable).  If two parameter values are tied together, the
connection is indicated in the {\tt tie-to} column.  For example, if
parameter 1 has {\tt tie-to = 5}, that means the value of parameter 1 is
tied to the value of parameter 5; if parameter 5 changes, parameter 1 will
follow the change exactly.  If {\tt min=max=0}, the corresponding parameter
value is unconstrained.

In input parameter files (see \verb|load_par|), lines beginning
with a `\verb|#|' are mostly ignored and may be used to include
comments.  Exceptions to this rule are ``special'' comment
lines which are used to support additional functionality such
as, e.g. writing some parameters as functions of other
parameters (see \verb|set_par_fun|).  Note that, aside from
these special cases, comment lines are not loaded by
\verb|load_par| and will not be preserved if file is later
overwritten by \verb|save_par|.

\end{isisfunction}

\begin{isisfunction}
{lmdif} %name
{Variant of Levenberg-Marquardt minimization algorithm} %purpose
{set\_fit\_method ("lmdif")} %usage
{optimization, set\_fit\_method, mpfit}

This interface invokes \verb|mpfit| with a limited set of options and is
provided primarily for backward compatibility with isis versions 1.5 and
earlier.  See \verb|mpfit| for details.

For help on lmdif options, use:
\begin{verbatim}
set_fit_method ("lmdif;help");
\end{verbatim}

The \verb|lmdif| \verb|tol| option defines both the \verb|ftol|
and \verb|xtol| parameters of \verb|mpfit|.

\end{isisfunction}

\begin{isisfunction}
{load\_conf} %name
{Load a 2D chi-square map from a FITS file} %purpose
{Struct\_Type = load\_conf (file)} %usage
{conf\_map\_counts, save\_conf, plot\_conf}
\index{Confidence Limits!loading 2D Maps}

This function reads a 2D confidence map from a FITS file
previously created by \verb|save_conf|.

For example,
\begin{verbatim}
  % Create and save a confidence map:
     map = conf_map_counts (px, py);
     save_conf (map, "map.fits");
  % reload the map:
     copy = load_conf ("map.fits");
\end{verbatim}
See \verb|conf_map_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{load\_fit\_method} %name
{load a user-defined fit-method} %purpose
{status = load\_fit\_method ("library.so", "name")} %usage
{register\_slang\_optimizer, set\_fit\_method, add\_to\_isis\_module\_path}
\index{User-defined!minimization algorithm}

See \verb|math/marq.c| in the \isisx distribution for an
example of how to implement a user-defined fit-method.
To add a new method called {\tt newfit} which has been
compiled into a shared library (e.g. {\tt libnewfit.so}),
use
\begin{verbatim}
     ret = load_fit_method ("libnewfit.so", "newfit");
\end{verbatim}

The return value is (0/-1) to indicate success/failure.
\end{isisfunction}

\begin{isisfunction}
{load\_fit\_statistic} %name
{load a user-defined fit-statistic} %purpose
{status = load\_fit\_statistic ("library.so", "name")} %usage
{set\_fit\_statistic, add\_to\_isis\_module\_path, add\_slang\_statistic}
\index{User-defined!fit-statistic (compiled)}

To add a new method called {\tt newstat} which has been
compiled into a shared library (e.g. {\tt libnewstat.so}),
use
\begin{verbatim}
     ret = load_fit_statistic ("libnewstat.so", "newstat");
\end{verbatim}

The return value is (0/-1) to indicate success/failure.
\end{isisfunction}

\begin{isisfunction}
{load\_kernel} %name
{load a user-defined fit-kernel} %purpose
{ret = load\_kernel ("library\_name", "init\_name" [, "init\_args"])} %usage
{set\_kernel, print\_kernel, list\_kernels, add\_to\_isis\_module\_path}
\index{User-defined!fit-kernel}

See \verb|src/pileup_kernel.c| in the \isisx distribution for an
example of how to implement a user-defined fit-kernel.
Assuming such a fit-kernel has been implemented with an
initialization function called {\tt my\_kernel\_init} and
compiled into a shared library (e.g. {\tt libmy\_fit\_kernel.so}),
the user-defined fit-kernel may be dynamically linked to \isisx
by using

\begin{verbatim}
     ret = load_kernel ("libmy_fit_kernel.so", "my_kernel_init");
\end{verbatim}

The return value is (0/-1) to indicate success/failure. The
optional string argument provides a mechanism to supply parameters
which may be required at the time of the kernel's initialization.
\end{isisfunction}

\begin{isisfunction}
{load\_par} %name
{load fit function and parameters from a file} %purpose
{load\_par ("filename")} %usage
{list\_par, save\_par, edit\_par, set\_par, get\_par}
Use this function to define a fit-function and its parameter values
by reading an ASCII file.  See {\tt list\_par} for file format details.
\end{isisfunction}

\begin{isisfunction}
{Lorentz} %name
{Lorentzian line profile function} %purpose
{Lorentz(id)} %usage
{gauss, voigt, poly, delta, bin\_width, bin\_center}

The {\tt id} parameter identifies a particular instance of a Lorentzian
profile; multiple instances are allowed in a single fit. The function value
assigned to each bin is the area under the Lorentzian curve which lies
inside the bin:
\begin{equation}
{\rm Lorentz}(x_a,x_b) = {A \over \pi}
       \int_{x_a}^{x_b} \D x~
        { {\Gamma/2} \over { \left(x - x_0\right)^2 +
                 \left(\Gamma/2\right)^2 } }
\end{equation}
where $A$ is the total area (e.g. photons/s/cm${}^2$) under the Lorentzian centered
at $x_0$ with full-width at half-maximum $\Gamma$.
\end{isisfunction}

\begin{isisfunction}
{marquardt} %name
{Levenberg-Marquardt minimization algorithm} %purpose
{set\_fit\_method ("marquardt")} %usage
{optimization, set\_fit\_method}

This is an alternate implementation of the Levenberg-Marquardt
algorithm.  This algorithm was derived under the assumption
that the function to be minimized is the Chi-square
fit-statistic.  For details on the derivation, see e.g.
Bevington and Robinson (1992).

The algorithm supports several optional parameters:
\begin{verbatim}
 __Option__ __Default__  __Purpose__
  max_loops  50          Max number of iterations
        tol  1.e-4       Fractional chisqr acceptance tolerance
      delta  1.e-6       Initial numerical derivative step size
jump_factor  10.0        Lambda adjustment factor
\end{verbatim}

To see a list of optional parameters, use
\begin{verbatim}
  set_fit_method ("marquardt;help");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{mpfit} %name
{Variant of Levenberg-Marquardt minimization algorithm} %purpose
{set\_fit\_method ("mpfit")} %usage
{optimization, set\_fit\_method}

The \verb|mpfit| Levenberg-Marquardt algorithm is the default
minimization algorithm used in fitting models to data.  This
algorithm was derived under the assumption that the function to
be minimized is the Chi-square fit-statistic.  For details on
the derivation, see e.g. Bevington and Robinson (1992).

For help, use:
\begin{verbatim}
set_fit_method ("mpfit;help");
\end{verbatim}

\verb|mpfit| computes numerical derivatives of the chi-square function with
respect to each free parameter.  Computation of these derivatives requires
choosing a step size for each parameter.  This step size may be specified
using either an absolute measure, \verb|step|, or a relative measure,
\verb|relstep| (see \verb|set_par|).  The numerical derivative step size,
\verb|h|, is determined by the following algorithm:
\begin{verbatim}
    eps = sqrt(max([epsfcn, machine_epsilon]));
    h = eps * abs(param);
    if (step > 0) h = step;
    if (relstep > 0) h = relstep * abs(param);
    if (h == 0) h = eps;
\end{verbatim}
where \verb|param| is the parameter value, \verb|epsfcn| is a parameter
of the method, and \verb|machine_epsilon=2.2204460e-16|.

\end{isisfunction}

\begin{isisfunction}
{optimization} %name
{Optimization methods provided with isis} %purpose
{-} %usage
{set\_fit\_method, list\_fit\_methods}

Isis provides a variety of optimization methods suitable for
wide variety of fitting applications. Each method has its own
strengths and weaknesses.  Because no single method works well
on every problem, it is often necessary to give some thought to
which optimization method is likely to be effective for a given
problem.

When the problem of interest is well behaved (e.g. the
statistic is a smoothly varying function of a small number of
uncorrelated parameters and has a unique minimum whose location
can be guessed with reasonable accuracy), a local optimization
method such as Levenberg-Marquardt is most likely to perform
well, in the sense of accurately locating the minimum after a
relatively small number of model evaluations (see \verb|mpfit|,
\verb|marquardt|, \verb|plm|).  The Powell method may also work
well in such cases (see \verb|powell|).

For more difficult problems, the simplex method (see
\verb|simplex|, \verb|subplex|) or Powell method (see
\verb|powell|) may be more effective, although significantly
more model evaluations may be required. Global methods such as
differential evolution (\verb|diffevol|) or simulated annealing
(\verb|simann|) may produce results even when other methods
make little or no progress.  However, the large number of model
evaluations sometimes required by these methods means they
can be very CPU intensive.

\end{isisfunction}

\begin{isisfunction}
{plm} %name
{Parallel Levenberg-Marquardt optimization method} %purpose
{set\_fit\_method ("plm")} %usage
{optimization, set\_fit\_method, parallel}

This is a parallelized version of the Levenberg-Marquardt
optimization method. The basic algorithm was derived under the
assumption that the function to be minimized is the Chi-square
fit-statistic.  For details on the derivation, see e.g.
Bevington and Robinson (1992).

The algorithm supports several optional parameters, with
default values shown in parentheses:
\begin{verbatim}
          tol (1.e-4)  Chi-square (X) has converged when dX/X <= tol
       lambda (0.1)    Levenberg-Marquardt parameter
  grow_factor (10)     lambda increases by lambda *= grow_factor
shrink_factor (0.1)    lambda decreases by lambda *= shrink_factor
    max_loops (100)    Maximum number of trials
        delta (1.e-4)  param delta for numerical derivative is
                          (|p| + sqrt(delta))*sqrt(delta)
\end{verbatim}

The number of compute slaves may be specified using the
\verb|num_slaves| option.  For example:
\begin{verbatim}
  set_fit_method ("plm;num_slaves=4;max_loops=200");
\end{verbatim}
See \verb|parallel| for more details on controlling parallel processes.

To see a list of optional parameters, use
\begin{verbatim}
  set_fit_method ("plm;help");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{simann} %name
{Variant of Simulated Annealing minimization algorithm} %purpose
{set\_fit\_method ("simann")} %usage
{optimization, set\_fit\_method}

To see a list of optional parameters, use
\begin{verbatim}
  set_fit_method ("simann;help");
\end{verbatim}

The following description is an excerpt from the documentation
included with the code.

This routine implements the continuous simulated annealing global
optimization algorithm described in Corana et al.'s article
{\it Minimizing Multimodal Functions of Continuous Variables with the
Simulated Annealing Algorithm} in the September 1987 (vol. 13,
no. 3, pp. 262-280) issue of the ACM Transactions on Mathematical
Software.

A very quick (perhaps too quick) overview of SA:
   SA tries to find the global optimum of an N dimensional function.
It moves both up and downhill and as the optimization process
proceeds, it focuses on the most promising area.

   To start, it randomly chooses a trial point within the step length
VM (a vector of length N) of the user selected starting point. The
function is evaluated at this trial point and its value is compared
to its value at the initial point.

   In a maximization problem, all uphill moves are accepted and the
algorithm continues from that trial point. Downhill moves may be
accepted; the decision is made by the Metropolis criteria. It uses T
(temperature) and the size of the downhill move in a probabilistic
manner. The smaller T and the size of the downhill move are, the more
likely that move will be accepted. If the trial is accepted, the
algorithm moves on from that point. If it is rejected, another point
is chosen instead for a trial evaluation.

   Each element of VM periodically adjusted so that half of all
function evaluations in that direction are accepted.

   A fall in T is imposed upon the system with the RT variable by
T(i+1) = RT*T(i) where i is the ith iteration. Thus, as T declines,
downhill moves are less likely to be accepted and the percentage of
rejections rise. Given the scheme for the selection for VM, VM falls.
Thus, as T declines, VM falls and SA focuses upon the most promising
area for optimization.

The importance of the parameter T:
   The parameter T is crucial in using SA successfully. It influences
VM, the step length over which the algorithm searches for optima. For
a small intial T, the step length may be too small; thus not enough
of the function might be evaluated to find the global optima. The user
should carefully examine VM in the intermediate output (set IPRINT =
1) to make sure that VM is appropriate. The relationship between the
initial temperature and the resulting step length is function
dependent.

   To determine the starting temperature that is consistent with
optimizing a function, it is worthwhile to run a trial run first. Set
RT = 1.5 and T = 1.0. With RT $>$ 1.0, the temperature increases and VM
rises as well. Then select the T that produces a large enough VM.

For modifications to the algorithm and many details on its
use, (particularly for econometric applications) see Goffe, Ferrier
and Rogers, ``Global Optimization of Statistical Functions
with Simulated Annealing,'' Journal of Econometrics, vol. 60, no.
1/2, Jan./Feb. 1994, pp. 65-100.

\end{isisfunction}

\begin{isisfunction}
{Minimum\_Stat\_Err}
{Defines the minimum valid uncertainty for counts data}
{(intrinsic global variable)}
{load\_data, define\_counts, define\_flux, fit\_counts, fit\_flux}

When input data values are to be treated as counts, isis
attempts to validate the uncertainty values, requiring them all
to be greater than or equal to \verb|Minimum_Stat_Err|, where
\verb|Minimum_Stat_Err| has a default value of 1.

For example, defining a single-bin counts dataset with has
bin value \verb|1.e-5| and uncertainty \verb|1.e-8|:
\begin{verbatim}
isis> define_counts (1.0, 2.0, 1.e-5, 1.e-8);
1
isis> print(get_data_counts(1).err);
1
\end{verbatim}
Note that isis replaced the \verb|1.e-8| uncertainty value
because it was inconsistent with default expectations for this
kind of data.

To force isis to retain positive counts-uncertainty values
smaller than unity, define a minimum (positive) allowable uncertainty
value using \verb|Minimum_Stat_Err|:
\begin{verbatim}
isis> Minimum_Stat_Err=1.e-20;
isis> define_counts (1.0, 2.0, 1.e-5, 1.e-8);
2
isis> print(get_data_counts(2).err);
1e-08
\end{verbatim}
Here, isis kept the \verb|1.e-8| uncertainty value.

When input data is to be treated as flux, this kind of
filtering does not take place:
\begin{verbatim}
isis> define_flux (1, 2, 1.e-5, 1.e-8);
1
isis> print(get_data_flux(1).err);
1e-08
\end{verbatim}
Uncertainties for flux values must be positive.

\index{Warn\_Invalid\_Uncertainties@{\tt Warn\_Invalid\_Uncertainties}}
To shut off warnings about invalid uncertainties being
replaced, set \verb|Warn_Invalid_Uncertainties=0|.

\end{isisfunction}

\begin{isisfunction}
{notice} %name
{Notice a wavelength range when fitting} %purpose
{notice (hist\_index\_list [, lambda\_lo, lambda\_hi])} %usage
{notice\_en, ignore, xnotice, exclude, include}

Because all data bins in all data sets are noticed by default,
this function is most useful when some datasets or wavelength
ranges have been previously {\tt ignore}ed.  One can notice a
particular wavelength range and simultaneously ignore wavelengths
outside that range using {\tt xnotice} (for ``exclusive-notice'').
If either of the wavelength range arguments are missing, the
limiting value is taken from the input data; therefore, omitting
both range values is equivalent to noticing the entire wavelength
range.

Note that when fitting data using an ARF and RMF, the RMF is used to
determine which model bins contribute to the noticed data bins.
\end{isisfunction}

\begin{isisfunction}
{notice\_en} %name
{Notice an energy range when fitting} %purpose
{notice\_en (hist\_index\_list [, E\_lo, E\_hi])} %usage
{notice, ignore\_en,  xnotice\_en, exclude, include}

This is an alternate form of the \verb|notice| function that
takes an energy range in keV instead of a wavelength range.
See \verb|notice| for details.
\end{isisfunction}

\begin{isisfunction}
{notice\_list} %name
{Notice a list of bins when fitting} %purpose
{notice\_list (datasets[], list)}   %usage
{notice, ignore\_list, xnotice, exclude, include}

This is an alternate form of the \verb|notice| function that
takes a list of bin indices instead of a wavelength range.
For example:
\begin{verbatim}
   % to notice bins with > 10 counts
   d = get_data_counts(1);
   ignore(1);
   notice_list (1, where(d.value > 10.0));
\end{verbatim}
Note that the list of bin indices refers to the internal
data which is stored in increasing wavelength order.

See \verb|notice| for details.

\end{isisfunction}

\begin{isisfunction}
{notice\_values} %name
{Notice bins with values exceeding a threshold} %purpose
{notice\_values (datasets[], lo1, hi1 [,lo2, hi2...] ; qualifiers)}   %usage
{ignore\_values, ignore, ignore\_list, notice, notice\_list, xnotice, exclude, include}

Exclusively notice bins in specific wavelength or energy
intervals that also meet criteria specified by the supported
qualifiers. If multiple datasets are specified, their spectral
grids should match exactly.

\begin{verbatim}
Qualifier    Default     Meaning
---------    -------     -------
unit          Angstrom   physical units of (lo, hi)
min_sum       NULL       if defined, notice only bins for which
                            (sum over datasets) >= min_sum
min_val       NULL       if defined, notice only bins for which
                            (value in every dataset) >= min_val
\end{verbatim}

For example,
\begin{verbatim}
   notice_values ([2,4,5], 1.0, 1.5 ; min_sum=20, min_val=5, unit="kev");
\end{verbatim}
will exclusively notice bins falling entirely within the range
1-1.5 keV and which also have more than 20 counts when summed
over datasets 2, 4 and 5 and which have at least 5 counts
in each of those datasets.

\end{isisfunction}

\begin{isisfunction}
{open\_fit} %name
{Open fit object} %purpose
{Struct\_Type = open\_fit ([qualifiers])} %usage
{register\_slang\_optimizer, fit\_fun, load\_data, set\_par, set\_kernel}

This function is primarily useful for implementing optimization
methods in \slang.  It returns a structure of the form
\begin{verbatim}
     s = struct
     {
        object, close, eval_statistic,
        status, statistic, num_vary, num_points,
        response_type, data_type
     };
\end{verbatim}
Two qualifiers are recognized.  If present, the `\verb|flux|'
qualifier indicates that the fit statistic should be computed
for flux-corrected data, otherwise the statistic will be computed
for counts data.  The `\verb|response|' qualifier may be used
to control which instrument response is applied to the spectral
model;  valid values are:
\begin{verbatim}
   response=Ideal_ARF
            Ideal_RMF
            Ideal_ARF | Ideal_RMF
            Ideal_ARFRMF
            Assigned_ARFRMF
\end{verbatim}
The values of the `\verb|flux|' and `\verb|response|' qualifiers
are stored in the \verb|data_type| and \verb|response_type|
fields of the fit object structure.

The \verb|object| field of this structure is an opaque
\verb|Fit_Object_Type| pointer to an internal data structure
that represents the current state of the fit engine, including
the current fit-function and all noticed datasets.  To generate
this opaque object pointer, isis performs all the
initialization normally associated with each call to
\verb|eval_counts| or \verb|eval_flux|.

The \verb|eval_statistic| field provides a function that may be
used to compute the current fit statistic for a given vector of
free parameters.  For example:
\begin{verbatim}
    s = open_fit ();
    stat = s.eval_statistic (pars);
\end{verbatim}
Performing this statistic computation using the fit object is
more efficient than performing the same computation using
\verb|eval_counts| or \verb|eval_flux| because the
initialization associated with the \verb|Fit_Object_Type|
pointer in the \verb|object| field has already been performed.
If the \verb|eval_statistic| method is called with the
\verb|nocopy| qualifier, some internal copying of computed
model values will be omitted.  While skipping this internal
copying provides a useful optimization during the intermediate
steps of a fit, the final statistic computation should be
performed without the qualifier so that the final computed
model spectra are saved internally.

The remaining fields of the fit object structure are scalar
values containing results of the fit statistic computation. The
\verb|statistic| field contains the value of the fit statistic.
The \verb|num_vary| field contains the number of variable fit
parameters.  The \verb|num_points| field contains the number of
data points involved in the statistic computation.  The
\verb|status| field is negative if any error occurred, and zero
otherwise.

\end{isisfunction}

\label{pileup-help}
\begin{isisfunction}
{pileup} %name
{Pileup kernel used to model photon pileup in CCDs} %purpose
{set\_kernel (data\_index, "pileup[;option=value;...]")} %usage
{set\_kernel, fit\_fun}

The pileup kernel includes the effects due to event pileup within
a single CCD frame-time and is described in detail in Davis
(2001).

Valid options for the pileup kernel include:
\begin{verbatim}
    nterms=value     Max number of piled photons
  fracexpo=value     Fraction exposure for ARF
   verbose=value     verbose level
\end{verbatim}

See the printed manual for a brief usage example.

The pileup kernel provides an implementation of the
\verb|print_kernel| function to provide statistics on the nature
of the pileup fit.
\begin{verbatim}
For example:

    isis> print_kernel(1);
    1: 0.211913     0.929297
    2: 0.029725     0.0673295
    3: 0.00277968   0.00325211
    4: 0.000194952  0.000117811
    5: 1.09384e-05  3.41426e-06
    *** pileup fraction: 0.0707029

\end{verbatim}

This says that 21\% of the frames contained a single photon in the
pileup region, 3 percent were contained 2 photons, etc.  The 3rd
column indicates that 93 percent of the events were single photon
events, 7 percent were due to 2 photons, etc.

The ACIS frame time in seconds is determined as follows.  If
the \verb|EXPTIME| keyword is present in the spectrum file
header, its value is taken as the frame time; otherwise, if the
\verb|TIMEDEL| keyword is present, the frame time is taken as
\verb|TIMEDEL-0.04104|. If neither of these keywords is
present, the frame time is assumed to be 3.2 sec.  Use
\verb|set\_frame\_time| to specify the frame time explicitly.

The most computationally expensive aspect of the pileup model
involves convolution of real-valued sequences using the FFT. By
default, \isis\ uses an FFT algorithm which is very general but
not particularly fast.  If you plan to make heavy use of the
pileup kernel, you may wish to obtain the specialized and
highly optimized FFT library, \verb|djbfft|, available from
\verb|http://cr.yp.to/djbfft.html|. To use this library, first
download and install it, then install \isis\ using the
\verb|--with-djbfft| configure option to supply the path to the
\verb|djbfft| library.  Informal benchmarks on an AMD Athlon
cpu show that the pileup model using the \verb|djbfft| library
runs about five times faster than with the default FFT.

\end{isisfunction}

\begin{isisfunction}
{poly} %name
{polynomial fit function} %purpose
{poly(id)} %usage
{gauss, Lorentz, delta, bin\_width, bin\_center}

The {\tt id} parameter identifies a particular instance of a polynomial;
multiple instances are allowed in a single fit. The function value assigned
to each bin is the area under the polynomial curve (of order $\le$ 2) which
lies inside the bin:
\begin{eqnarray}
{\rm poly}(x_a,x_b) &=& \int_{x_a}^{x_b} \D x~
             \left( a_0 + a_1 x + a_2 x^2\right)  \nonumber\\
&=& \delta x \left[ a_0 + {a_1 \over 2} \left(x_b + x_a\right)
               + {a_2 \over 3} \left(x_b^2 + x_b x_a + x_a^2\right) \right]
\end{eqnarray}
where $\delta x \equiv x_b - x_a$.  Notice that poly($x_a,x_b$) has units of
area (e.g. photons/s/cm${}^2/bin$), consistent with the definition of the other fit
functions {\tt gauss} and {\tt Lorentz}), so that $a_0$ has units of a
density (e.g. photons/s/cm${}^2$/\AA).  By setting the coefficients appropriately, this
function can also serve as both a linear function and a constant.
\end{isisfunction}

\begin{isisfunction}
{powell} %name
{Powell minimization algorithm} %purpose
{set\_fit\_method ("powell")} %usage
{optimization, set\_fit\_method, set\_fit\_constraint}

The powell algorithm is an implementation of Powell's direction
set method described in the paper: ``An efficient method for
finding the minimum of a function of several variables without
calculating derivatives'', The Computer Journal 1964.  This
implementation also makes use of modifications suggested by
W.I. Zangwill, ``Minimizing a function without derivatives'',
Computer Journal 1967

For help, use:
\begin{verbatim}
set_fit_method ("powell;help");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{Powerlaw} %name
{power-law fit function} %purpose
{Powerlaw (id)} %usage
{gauss, Lorentz, add\_slang\_function, add\_compiled\_function}

The {\tt id} parameter identifies a particular instance of a power-law;
multiple instances are allowed in a single fit. The function value assigned
to each bin is the area under the power-law curve which
lies inside the bin:
\begin{equation}
{\rm Powerlaw}(E_1,E_2) = \int_{E_1}^{E_2} \D e~A e^\alpha
\end{equation}
for $e$ in keV. Notice that Powerlaw($E_1,E_2$) has units of
area (e.g. photons/s/cm${}^2$/bin), consistent with the
definition of the other fit functions {\tt gauss} and {\tt
Lorentz}).
\end{isisfunction}

\begin{isisfunction}
{plot\_conf} %name
{Plot 2D chi-square confidence contours} %purpose
{[o]plot\_conf (Struct\_Type[, line[, dchisqr\_array]])} %usage
{save\_conf, load\_conf, conf\_map\_counts, conf\_map\_flux}
\index{Confidence Limits!contour plots}

By default, this function plots contours at $\delta \chi^2=$
2.30, 4.61 and 9.21, corresponding to 1-sigma (68.3\%
confidence), 90\% confidence, and 3-sigma (99\% confidence)
respectively.  To plot different contours, supply their
delta-chisqr values using the optional array argument. The
first argument is the return value of \verb|conf_map_counts| or
\verb|conf_map_flux|. If not otherwise specified, the axis
limits of these confidence contour plots are determined by the
\verb|Struct_Type| arguments used to generate the confidence
map. The current implementation does not support plotting
sub-regions of confidence maps.

The first optional argument is a structure which specifies the
line style and has the form
\begin{verbatim}
   line = struct {width, type, color};
\end{verbatim}
where each struct field may be either a scalar or an array of
length equal to the number of plot contours; the contours are
in order from lowest to highest confidence. See the
\verb|linestyle| for a list of supported values of
\verb|line.type|.

To overlay contours on an existing confidence contour plot,
use \verb|oplot_conf|.

\begin{verbatim}
Example:
     % generate conf. contours for dataset 1
     s1 = conf_map_counts (px, py);

     % generate conf. contours for dataset 2
     s2 = conf_map_counts (px2, py2);

     % provide X-Y ranges big enough to span both sets
     % of contours
     xrange (xmn, xmx);
     yrange (ymn, ymx);

     % overlay conf. contours:
     plot_conf (s1);
     oplot_conf (s2);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{print\_kernel} %name
{Print kernel parameters} %purpose
{print\_kernel (hist\_index\_list)} %usage
{load\_kernel, set\_kernel}

This function prints the current value of parameters associated with
the fit-kernel for each data-set in {\tt hist\_index\_list}.
Although the standard fit-kernel has no parameters, the
pileup-kernel does have a number of parameters.
User-defined fit kernels may provide this functionality as well --
see \verb|src/pileup_kernel.c| in the \isisx distribution for an
implementation example.  See also \S\ref{sec:pileup}.
\end{isisfunction}

\begin{isisfunction}
{randomize} %name
{Randomize variable fit-parameters} %purpose
{randomize ([params])} %usage
{set\_par, get\_par, fit\_counts, fit\_flux, fit\_search}

For each variable fit-parameter, this function randomly selects
a new value from within the specified \verb|[min, max)| range.
Note that if no parameter range has been specified, the
parameter is unconstrained and a random value will be selected
within the range $(-\infty,+\infty)$ -- this is probably not
what you want.

\end{isisfunction}

\begin{isisfunction}
{register\_slang\_optimizer} %name
{Register an optimization method implemented in S-Lang} %purpose
{register\_slang\_optimizer (name, \&method [;qualifiers])} %usage
{load\_fit\_method}

Use this function to register an optimization method implemented
in S-Lang.  For example:
\begin{verbatim}
  private variable Qualfiers;
  define set_options (options)
  {
     Qualfiers = options;
  }

  define some_function (obj, params, params_min, params_max)
  {
     %... search for optimal parameters...
          statistic = __eval_stat (obj, pars);
     %...
     return new_params;
  }

  register_slang_optimizer ("name", &some_function;
                                     set_options=&set_options);

  set_fit_method ("name; option1; option2=2.4;  option3=astring");
\end{verbatim}

The first argument to \verb|register_slang_optimizer| provides
a name for the optimization method.  The second argument provides
a reference to the S-Lang function implementing the method.

Two qualifiers are supported.  The `\verb|stat_name|' qualifier
gives the name of the fit statistic that will be used by default.
If not specified, the default fit-statistic is \verb|chisqr|.

If present, the `\verb|set_options|' qualifier should provide a
reference to a function that takes one argument, which is a
\verb|Struct_Type| containing options from the
\verb|set_fit_method| call.  In the above example, the options
struct will have the form
\begin{verbatim}
   options = struct {option1, option2=2.4, option3="astring"};
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{renorm\_counts} %name
{Automatically adjust fit normalization} %purpose
{s = renorm\_counts ()} %usage
{renorm\_flux}

This function automatically adjusts the normalization of the model
to improve the fit to the counts data.  See {\tt fit\_counts} for
details.

\end{isisfunction}

\begin{isisfunction}
{renorm\_flux} %name
{Automatically adjust fit normalization} %purpose
{s = renorm\_flux ()} %usage
{renorm\_counts}

This function automatically adjusts the normalization of the model
to improve the fit to the flux-corrected data.  See {\tt fit\_flux} for
details.

\end{isisfunction}

\begin{isisfunction}
{save\_conf} %name
{Save a 2D chi-square map as a FITS image} %purpose
{status = save\_conf (Struct\_Type, file)} %usage
{conf\_map\_counts, load\_conf, plot\_conf}
\index{Confidence Limits!saving 2D Maps}

This function saves a 2D confidence map as a FITS image
with WCS coordinates defined using the corresponding
grid of fit-parameter values.  The return value is 0
for success, $<0$ for failure.

For example,
\begin{verbatim}
  % Create and save a confidence map:
     map = conf_map_counts (px, py);
     status = save_conf (map, "map.fits");
\end{verbatim}
See \verb|conf_map_counts| for details.

\end{isisfunction}

\begin{isisfunction}
{save\_par} %name
{save fit function and parameters to a file} %purpose
{save\_par ("filename")} %usage
{load\_par, list\_par, edit\_par, set\_par, get\_par, fit\_search}

The current fit function and parameter values may be saved in an ASCII file.
The allowed fit-ranges, and freeze/thaw/tie state is also saved. See {\tt
list\_par} for format details.  {\tt load\_par} may be used to re-load the
file.

If the function \verb|isis_save_par_hook| is defined in the
Global namespace, it will be called after the parameters have
been written out, but before the file is closed.  The name of
the parameter file will be passed to \verb|isis_save_par_hook|,
which should return a string.  If non-empty, this string will
be appended to the parameter file.

This trivial example would record time of day in the parameter file:
\begin{verbatim}
  public define isis_save_par_hook (filename)
  {
      return time();
  }
\end{verbatim}

\verb|isis_save_par_hook| is probably most useful in conjunction
with \verb|fit_search| and \verb|fit_search_info|.  In that case,
it might be used to automatically collect fit results into a table
with a custom format.

For example:
\begin{verbatim}
define value_string (p)
{
   return sprintf ("%13.6e", p.value);
}

define param_values_string ()
{
   variable p, s;

   p = get_params ();
   if (p == NULL) return "";

   s = array_map (String_Type, &value_string, p);

   return strjoin (s, " ");
}

public define isis_save_par_hook (fname)
{
   variable s, fp, info, stat = 0.0;

   % retrieve info on current best fit.

   info = fit_search_info();
   if (info != NULL)
     stat = info.statistic;

   % generate a string 's'

   variable v = param_values_string ();
   s = sprintf ("%s %12.4e  %s\n", fname, stat, v);

   % append 's' to a log file
   variable dir = path_dirname (fname);

   fp = fopen (dir + "/save_par.log", "a");
   if (fp == NULL) return NULL;
   () = fputs (s, fp);
   () = fclose (fp);

   % the returned string will be appended to the param file.

   return "";
}
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_fit\_constraint} %name
{Impose a fit-constraint} %purpose
{set\_fit\_constraint (\&ref [, param\_names[])} %usage
{set\_fit\_method, set\_fit\_statistic, fit\_fun}

In order to impose constraints on a fit in addition to the
usual bound-constraints on the fit-parameters (e.g. to impose
Lagrange multiplier constraints), one can provide a function
that modifies the fit-statistic computed during the fit.  This
function may depend upon the fit statistic, any of the data
values, model parameters, or computed model values and may also
depend upon additional fit-parameters associated with the
constraint function itself.

Use \verb|set_fit_constraint| to provide a reference to the
constraint function and, if necessary, to provide an array of
strings giving the names of fit-parameters that are associated
with the constraint function.  The parameters named in this
array will appear as fit-parameters of the form
\verb|constraint(1).name|.

The constraint function itself should accept two parameters and
should return a scalar-valued penalty. The first input
parameter is the scalar-valued fit statistic.  The second input
parameter is an array of parameter values. If the constraint
function has no parameters, the second input parameter will be
set to \verb|NULL|.

For example:
\begin{verbatim}
   define a_constraint (stat, pars)
   {
       variable lam1, lam2, penalty;

       lam1 = par[0];
       lam2 = par[1];

       penalty = lam1 * fcn1() + lam2 * fcn2();

       return stat + penalty;
   }
   set_fit_constraint (&a_constraint, ["lambda1", "lambda2"]);
\end{verbatim}

Note that, if the constraint function is defined in the
\verb|Global| namespace or in the \verb|isis| namespace, it may
not have the name `\verb|constraint|'. The name
`\verb|constraint|' may be used only if the function is
declared to be private:
\begin{verbatim}
  private define constraint (stat, pars)
  {
     % ... compute the penalty ...
     return stat + penalty;
  }
\end{verbatim}

To remove the fit-constraint use
\begin{verbatim}
   set_fit_constraint (NULL);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_fit\_method} %name
{select a fit-method} %purpose
{set\_fit\_method ("name[;options]")} %usage
{load\_fit\_method, register\_slang\_optimizer,
set\_fit\_statistic, set\_fit\_constraint, randomize, optimization}

The \isisx distribution includes a number of optimization
methods (see \verb|optimization|).  Control
parameters associated with the fit methods (such as convergence
tolerances) may be adjusted by supplying qualifers in the
method name string.  For example, one might set the maximum
number of function evaluations performed by {\tt subplex} by
setting the {\tt maxnfe} option using
\begin{verbatim}
  set_fit_method ("subplex;maxnfe=1000");
\end{verbatim}
Similarly, one can limit the maximum number of iterations
performed by {\tt marquardt} using
\begin{verbatim}
  set_fit_method ("marquardt;max_loops=100");
\end{verbatim}
For a given fit method, the list of available control
parameters may be obtained using the {\tt help} qualifier:
\begin{verbatim}
  set_fit_method ("marquardt;help");
\end{verbatim}
Default parameter values may be restored using the {\tt
default} qualifier:
\begin{verbatim}
  set_fit_method ("minim;default");
\end{verbatim}

Given a reasonably good initial guess and a
reasonably smooth $\chi^2$ space, {\tt mpfit} generally
converges to the best fit fairly quickly. In the ideal case, its
convergence is quadratic.  In cases where the $\chi^2$ parameter
space is relatively complex (e.g. pileup), with many local minima,
{\tt subplex} may be helpful because it is somewhat less likely to
become stuck in a local minimum.  One possible strategy may
be to use {\tt subplex} to find the neighborhood of the global
minimum and then use {\tt mpfit} to quickly find the best fit.

In general, it is a good idea to thoroughly search the parameter
space to find the best fit.  The {\tt randomize} function may be
helpful as part of a scripted Monte-Carlo search of the likely
parameter space (see also \verb|fit_search|).

\end{isisfunction}

\begin{isisfunction}
{set\_fit\_range\_hook} %name
{Control allowed fit-parameter value range} %purpose
{set\_fit\_range\_hook (\&function)} %usage
{set\_fit\_method, set\_fit\_constraint}

When fitting models to data, fit-parameters may be constrained to
fall within a specified range.  Each fit-method may supply its own
algorithm for enforcing these parameter ranges. To supply an
alternative algorithm, one can supply a S-Lang ``range-hook''
function of the form
\begin{verbatim}
  (new_par, new_min, new_max) = range_hook (par, min, max, idx)
\end{verbatim}
The arguments \verb|par|, \verb|min| and \verb|max| give
the parameter values and min/max ranges while the last
argument, \verb|idx|, gives the index of each parameter
as shown by \verb|list_par|.  The \verb|idx| argument
is necessary because the range-hook is passed only those
parameters which are allowed to vary during the fit.
Frozen and tied parameters are not passed.

To switch to the new range function, use e.g.
\begin{verbatim}
   set_fit_range_hook (&range_hook);
\end{verbatim}
to revert to the default fit-range algorithm, use
\begin{verbatim}
   set_fit_range_hook (NULL);
\end{verbatim}
Note that the range-hook function can also adjust the allowed
parameter value range (as well as the parameter value itself)
during the fit iteration.

For example, the following function enforces the allowed
parameter range by setting out-of-range parameters to a randomly
chosen value from within the allowed range:
\begin{verbatim}
define enforce_ranges (p, pmin, pmax, idx)
{
   variable i, out_of_range;
   out_of_range = where (p < pmin or pmax < p);

   foreach (out_of_range)
   {
       i = ();
       p[i] = pmin[i] + urand() * (pmax[i] - pmin[i]);
   }

   return (p, pmin, pmax);
}

set_fit_range_hook (&enforce_ranges);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_fit\_statistic} %name
{select a fit-statistic} %purpose
{set\_fit\_statistic ("name")} %usage
{load\_fit\_statistic, set\_fit\_constraint, set\_fit\_method}

\isisx includes three built-in fit statistics, {\tt chisqr}, {\tt cash}
and {\tt ml}.
User-defined fit-statistics are also supported and may be
implemented in {\tt C} or \slang.  Control parameters associated
with the fit statistics (such as the chi-square weighting) may be
adjusted by supplying qualifers in the method name string.  For a
given fit statistic, the list of available control parameters may
be obtained using the {\tt help} qualifier:
\begin{verbatim}
  set_fit_statistic ("chisqr;help");
\end{verbatim}
For example, one might set the variance used with the chi-square
statistic {\tt chisqr} by setting the {\tt sigma} option using
\begin{verbatim}
  set_fit_statistic ("chisqr;sigma=gehrels");
\end{verbatim}
Given data values $C_i \pm \sigma_i$ and model values $M_i$,
the chi-square statistic is defined to be
\begin{equation}
   \chi^2 = \sum (C_i - M_i)^2 / \sigma_i^2
\end{equation}
where the definition of $\sigma_i$ is one of the following:
\begin{verbatim}
    data    \sigma_i [default]
 gehrels    1 + \sqrt(C_i + 0.75)
   model    \sqrt(M_i)
     lsq    1
\end{verbatim}
The Cash statistic is defined to be
\begin{equation}
 S_{\rm cash} \equiv 2\sum_i (M_i - C_i)
         + C_i \ln \left({C_i\over M_i}\right).
\end{equation}
See Cash (ApJ 228, 939) and the XSPEC manual for details.
The max-likelihood (ML) statistic is defined to be
\begin{equation}
 S_{\rm ml} \equiv \sum_i \left(M_i + \ln \Gamma (M_i+1) - C_i \ln M_i\right)
\end{equation}
\end{isisfunction}

\begin{isisfunction}
{set\_function\_category} %name
{Specify the category to which a fit-function belongs} %purpose
{set\_function\_category (name, category)} %usage
{add\_slang\_function, add\_compiled\_function}

Two categories of fit-functions are currently supported:
\begin{verbatim}
  ___Category____       __Definition__
   ISIS_FUN_ADDMUL      additive and multiplicative models
   ISIS_FUN_OPERATOR    operator or ``convolution'' models
\end{verbatim}
The default category is \verb|ISIS_FUN_ADDMUL|.

See \verb|add_slang_function| and \verb|add_compiled_function|
for details on how to define the various types of
fit-functions.
\end{isisfunction}

\begin{isisfunction}
{set\_kernel} %name
{Specify fit-kernel to use in forward-folding} %purpose
{set\_kernel (hist\_index\_list, "kernel\_name[;option=value;..]")} %usage
{load\_kernel, print\_kernel, get\_kernel, list\_kernels}

The default fit kernel, equivalent to applying the ARF and RMF
in the usual way, is called "std". If the ARF and RMF are
unavailable, the response defaults to an identity matrix. The
pileup kernel, which includes the effects due to event pileup
within a single CCD frame-time and described in detail in Davis
(2001), is called "pileup" (See also \S\ref{sec:pileup}).

The first argument, \verb|hist_index_list|, is a list of data
set indices which should use this kernel. The second argument,
\verb|kernel_name|, is the name of the kernel, which should be
\verb|<= 31| characters. This argument may also contain
values for kernel-specific options;  for example:
\begin{verbatim}
  set_kernel (3, "pileup;nterms=20;fracexpo=0.9");
\end{verbatim}

To determine what kernel options are supported, use the
\verb|help| option.  For example:
\begin{verbatim}
  isis> set_kernel (1, "pileup;help");
  Valid options for subsystem "pileup" include:
      nterms=value     Max number of piled photons
    fracexpo=value     Fraction exposure for ARF
     verbose=value     verbose level
  isis>
\end{verbatim}

Alternate fit-kernels may be defined by the user by creating a
shared library (.so file) with the necessary interface.  This
shared library may be loaded using the {\tt load\_kernel}
function.

\begin{verbatim}
Example:
   % use the pileup kernel for data sets 4-6:
   set_kernel ([4,5,6], "pileup");

   % revert to the standard kernel for data set 5
   set_kernel (5, "std");
   set_kernel (5, NULL);     % this form is also valid
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{\_\_set\_fitfun\_post\_hook}
{Set a hook to be called after evaluating a model component}
{\_\_set\_fitfun\_post\_hook (String\_Type fitfun\_name, Ref\_Type hook)}%
{\_\_set\_fitfun\_trace\_hook}
\begin{verbatim}
Example:
   __set_fitfun_post_hook ("warmabs", &post_hook);
\end{verbatim}
The hook function must be of the form:
\begin{verbatim}
  define post_hook (fitfun_name, id)
  {
  }
\end{verbatim}
where \verb|fun_name| is the name of the fit-function just evaluated
and \verb|id| is the instance of that fit-function.  For example,
if the hook is called after \verb|warmabs(2)| is evaluated, then
\verb|fun_name| will have the value \verb|"warmabs"| and \verb|id|
will have the value \verb|2|.
\end{isisfunction}

\begin{isisfunction}
{\_\_set\_fitfun\_trace\_hook}
{Set a hook to be called before evaluating a model component}
{\_\_set\_fitfun\_trace\_hook (String\_Type fitfun\_name, Ref\_Type hook)}%
{\_\_set\_fitfun\_post\_hook}
\begin{verbatim}
Example:
   __set_fitfun_trace_hook ("warmabs", &trace_hook);
\end{verbatim}
The hook function must be of the form:
\begin{verbatim}
  define trace_hook (id, params)
  {
  }
\end{verbatim}
where \verb|id| is the instance of the fit-function that is about to be
called. For example, if the hook is called before \verb|warmabs(2)| is
evaluated, then \verb|id| will have the value \verb|2| and \verb|params| will
contain a \verb|Double_Type| array of all the parameters being passed to the
function.
\end{isisfunction}

\begin{isisfunction}
{\_\_set\_hard\_limits}
{Adjust the hard limits constraining a fit parameter's value}
{\_\_set\_hard\_limits (fun\_name, par\_name, hard\_min, hard\_max)\\
    \_\_set\_hard\_limits (index, hard\_min, hard\_max)}%
{set\_par}

Because hard limits of a parameter are intended to provide a way for the
author of a model to define the full range of parameter values for which the
model is applicable, it should not be necessary for the user to modify the
hard limits at all.

Unfortunately, hard limits are sometimes carelessly set to an overly
restrictive range. For example, hard limits may constrain a Doppler shift
parameter to always correspond to a redshift even though the same code can
perfectly well handle a blueshift.

Use \verb|__set_hard_limits| to change the hard limits for a given parameter.

This change can be applied either to a specific instance of a function or to
the default configuration of a function.  If the default configuration is
modified, all subsequent instances of the function will be affected.

To change the hard limits for a specific instance of a function:
\begin{verbatim}
  __set_hard_limits ("mekal(1).redshift", -10, 10);
\end{verbatim}

To change the hard limits for the default configuration of a function:
\begin{verbatim}
  __set_hard_limits ("mekal", "redshift", -10, 10);
\end{verbatim}

If the specified hard limits do not contain the current parameter value and
its soft limits, then consistent values for the parameter and its soft limits
must also be provided using the \verb|parm| qualifier. The \verb|parm|
qualifier is a numerical array of length 3.  If present, the array will be
sorted in increasing order and then the three elements will be used as
the new \verb|min|, \verb|value|, \verb|max|.  For example:

\begin{verbatim}
  __set_hard_limits ("mekal(1)", "redshift", -10, 0; parm=[-3, -2, -1]);
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{set\_par} %name
{set the value of a fit parameter} %purpose
{set\_par (idx [, value [, freeze, [ min, max]]])} %usage
{edit\_par, load\_par, get\_par, set\_par\_fun, \_\_set\_hard\_limits, tie, set\_params}
\begin{verbatim}
      idx    parameter index or string identifier
    value    parameter value
   freeze    [optional] 1(0) if parameter is(is not) frozen
 min, max    [optional] allowed range for parameter value
\end{verbatim}

\begin{verbatim}
Qualifiers:
     step=VAL    initial parameter absolute step size
  relstep=VAL    initial parameter relative step size
      min=VALUE  parameter min value
      max=VALUE  parameter max value
\end{verbatim}

If allowed ranges are not specified by the user or if
{\tt min}={\tt max}=0, the parameter value range is unlimited;
this is the default.  If the function provides hard limits
on the parameter value range, then the \verb|min|, \verb|max|
values must be consistent with those hard limits
(see \verb|set_hard_limits|).

One can also refer to parameters by name:
\begin{verbatim}
  set_par ("gauss(1).area", 47.0);
\end{verbatim}

Parameters may also be identified using expressions with
embedded wildcard characters.  Both \slang\ regular expressions and
globbing expressions are supported.  If a regular expression
string is to be used, then the string must either begin with
\verb|'^'| or end with \verb|'$'|.  %$
A globbing expression is frequently used for
matching filenames where \verb|`?'| represents a single
character and \verb|`*'| represents 0 or more characters.  For
example, consider a model with many instances of similar
parameter names, such as:
\begin{verbatim}
 "xpileup_n(1).G0_0"
 "xpileup_n(1).G0_1"
 "xpileup_n(2).G0_0"
 "xpileup_n(2).G0_1"
     .
     .
\end{verbatim}
Using a globbing expression, one can use \verb|set_par| to set all
the \verb|G0_0| parameters to a specified value, e.g.,
\begin{verbatim}
 isis> set_par ("xpileup_n(?).G0_0", 0.5);
 isis> set_par ("*.G0_1", 2.1);
\end{verbatim}

\slang\ regular expression equivalents of the above are:
\begin{verbatim}
 isis> set_par ("^xpileup_n(.)\\.G0_0$", 0.5);
 isis> set_par (".*G0_1$", 2.1);
\end{verbatim}
(Note the presence of \verb|^| or \verb|$| %$
to indicate the string represents a regular expression).

Array arguments are supported.  Consider:
\begin{verbatim}
isis> fit_fun ("gauss(1)");
isis> list_par;
gauss(1)
 idx  param        tie-to  freeze   value          min          max
  1  gauss(1).area     0     0           1            0            0
  2  gauss(1).center   0     0          12            0            0
  3  gauss(1).sigma    0     0       0.025            0            0
isis> set_par ("gauss(1)", [ 2, 8,  0.03], [ 1,  0,   1],
                           [-1, 3, 0.004], [10, 20, 0.3]);
isis> list_par;
gauss(1)
 idx  param        tie-to  freeze   value          min          max
  1  gauss(1).area     0     1           2           -1           10
  2  gauss(1).center   0     0           8            3           20
  3  gauss(1).sigma    0     1        0.03        0.004          0.3
isis>
\end{verbatim}

The function value may be specified as a function of other
fit-parameter values.  For example:
\begin{verbatim}
  set_par ("gauss(1).center", "gauss(2).center-3.0");
\end{verbatim}
For details, see \verb|set_par_fun|.

If parameter ranges have been specified and a value is provided
that falls outside those ranges, the default behavior is to
interrupt the S-Lang interpreter and print an error message.
For example:
\begin{verbatim}
isis> set_par (1, 1, 0, 0, 1);
isis> set_par (1,3);
*** Error:  param 1 not set:  value 3 lies outside [min, max] interval [0, 1]
S-Lang Error: Intrinsic Error: Error while executing _set_par
isis>
\end{verbatim}
In long-running scripts this behavior may be undesirable. An
alternative behavior may be specified by defining a function
named \verb|isis_set_par_hook| in the Global namespace.  When
the value range error occurs, if this function exists, it is
passed a struct containing information on the relevant
parameter. This function may then return the struct after
modifying the range or value fields so that the
\verb|set_par()| operation can complete successfully.  For
example, one might adjust the parameter range as follows:

\begin{verbatim}
public define isis_set_par_hook (p)
{
   if (p.value <= p.min) p.min = 0.5 * p.value;
   if (p.value >= p.max) p.max = 2.0 * p.value;
   return p;
}
\end{verbatim}

Depending on which optimization algorithm is used, the initial parameter
\verb|step|/\verb|relstep| value may or may not be used.

\end{isisfunction}

\begin{isisfunction}
{set\_param\_default\_hook} %name
{Specify a function to set default parameter values and ranges} %purpose
{set\_param\_default\_hook (function\_name, hook [,args])} %usage
{add\_slang\_function, set\_function\_category}

For a fit-function implemented in \slang, one can define parameter defaults by
providing an associated hook function. The hook function should be a \slang\
function of the form
\begin{verbatim}
    define param_default (i [,args])
\end{verbatim}
where the first parameter is the zero-based array index and \verb|args| is an
optional list of user-defined arguments. The optional arguments are specified
when the hook function is defined.  The function should return the default
values in a structure of the form
\begin{verbatim}
     struct {value, freeze, min, max, hard_min, hard_max, step, relstep}
\end{verbatim}
where \verb|value| is the default parameter value and \verb|min| and
\verb|max| define the user-adjustable parameter range.  The user-adjustable
parameter range must fall within the hard limits defined by \verb|hard_min|
and \verb|hard_max|.  The initial parameter absolute step size, \verb|step|,
and relative step size, \verb|relstep|, may used by
some optimization methods. \verb|freeze| is a
boolean value, non-zero if the parameter is frozen by default.

To specify the hook function to be used with a given fit-function,
provide either a reference to the hook function (a \slang\
\verb|Ref_Type|)
\begin{verbatim}
  set_param_default_hook ("plaw", &plaw_param_default [,args]);
\end{verbatim}
or the name of the hook function (a \slang\ \verb|String_Type|)
\begin{verbatim}
  set_param_default_hook ("plaw", "plaw_param_default" [,args]);
\end{verbatim}

For a power-law fit-function, one might construct such a
parameter-default function as follows:
\begin{verbatim}
    define set_default (value, freeze, lim, hard_lim, step)
    {
       variable x = struct {value, freeze, min, max,
                            hard_min, hard_max, step, relstep};
       x.value = value;
       x.freeze = freeze;
       x.min = lim[0];
       x.max = lim[1];
       x.hard_min = hard_lim[0];
       x.hard_max = hard_lim[1];
       x.step = step;
       x.relstep = 1.e-5;

       return x;
    }

    variable Defaults = Struct_Type[2];
    Defaults[0] = set_default (1.0, 0, [0.0, DOUBLE_MAX], [0.0, _Inf], 0);
    Defaults[1] = set_default (  0, 0, [-5.0, 1.0], [-10.0, 10.0], 0);

    define plaw_default_hook (i)
    {
       return Defaults[i];
    }
    set_param_default_hook ("plaw", &plaw_default_hook);
\end{verbatim}
In this example, the normalization is constrained to be
positive, but has no default upper-limit.  The power-law
exponent is, however, constrained to fall in the range [-5,1].

\end{isisfunction}

\begin{isisfunction}
{set\_params} %name
{Reset all fit-parameter information using an array of structs} %purpose
{set\_params (Struct\_Type[])} %usage
{get\_params, set\_par, tie}
See \verb|get_params| for more information.
\end{isisfunction}

\begin{isisfunction}
{set\_par\_fun} %name
{Define a fit-parameter value using a function} %purpose
{set\_par\_fun (idx, expression\_string)} %usage
{set\_par, get\_par\_info, \_par, fit\_fun, conf\_map\_counts}
\index{Fitting!equality constraints}
\index{Fitting!inequality constraints}

Fit parameters may be defined as functions of other fit-parameters and may
also depend on arbitrary functions.  If the computed parameter value falls
outside that parameter's \verb|min|/\verb|max| range, then the out of range
value will be ignored; a warning message may be printed, depending on
the context and the current verbosity level (see \verb|Isis_Verbose|).

This has a number of applications and can be used to couple fit-parameters in
complex ways, derive quantities of interest from fit-parameters, compute
confidence limits on derived quantities and also to introduce arbitrary
coordinate transformations in e.g. plots of confidence contours.

For example, to fit a sum of two Gaussians centered 4.3 Angstroms
apart use:
\begin{verbatim}
isis> fit_fun ("gauss(1) + gauss(2)");
isis> set_par_fun ("gauss(2).center", "gauss(1).center + 4.3");
isis> list_par;
gauss(1) + gauss(2)
 idx  param        tie-to  freeze     value        min       max
  1  gauss(1).area     0     0             1          0         0
  2  gauss(1).center   0     0            12          0         0
  3  gauss(1).sigma    0     0         0.025          0         0
  4  gauss(2).area     0     0           2.5          0         0
  5  gauss(2).center   0     1          16.3          0         0
  #=>  gauss(1).center + 4.3
  6  gauss(2).sigma    0     0         0.025          0         0
\end{verbatim}

The constraint expression may also contain user-defined functions.
For example:
\begin{verbatim}
  public define offset ()
  {
     if (Isis_Active_Dataset == 2)
       return 3.0;
     else
       return 2.5;
  }
  set_par_fun ("gauss(2).center", "gauss(1).center + offset()");
\end{verbatim}
Here, the ISIS intrinsic variable \verb|Isis_Active_Dataset| is
used to define an offset which has the value 3.0 for dataset 2,
but is 2.5 for all other datasets.

To delete the parameter-function definition, use
\begin{verbatim}
  set_par_fun (index, NULL);
\end{verbatim}

Note that \verb|list_par| shows that all parameters defined as
functions have \verb|freeze=1|. This does not mean that the
parameter's value is fixed during fit iteration.  It merely
indicates that the parameter's value is derived from other
parameters and is not an independent variable during the fit.

One can also use \verb|set_par_fun| to enforce inequality
constraints.  The following example shows how to constrain one fit
parameter to be smaller than another:

\begin{verbatim}
   % Define a do-nothing fit function with a single parameter
   define one_fit (lo, hi, par)
   {
       return 1.0;
   }
   add_slang_function ("one", "c");

   % Include this do-nothing function in your spectral model
   fit_fun ("one(1) * phabs(1) * (mekal(1) + mekal(2))");

   % With this model, we have
   % param 1  = c (the `dummy parameter')
   % param 4  = kT_1
   % param 10 = kT_2

   % Now, introduce the inequality constraint
   % to require param 4 <= param 10:

   set_par_fun ("mekal(2).kT", "mekal(1).kT + one(1).c^2");
\end{verbatim}

With this definition, the value of parameter 10 will be computed
by adding a non-negative value, \verb|c^2|, to parameter 4, thereby
enforcing the constraint.

Although one can also refer to parameters by index:
\begin{verbatim}
  set_par_fun ("gauss(1).area", "_par(4) + _par(1)^2");
\end{verbatim}
using names of the form \verb|fname(i).parname| is more robust,
because such names are unaffected by changes in the parameter
indexing.

\end{isisfunction}

\begin{isisfunction}
{simplex} %name
{Simplex minimization algorithm} %purpose
{set\_fit\_method ("simplex")} %usage
{optimization, set\_fit\_method, set\_fit\_constraint}

The simplex algorithm is an implementation of the Nelder-Mead
simplex method, a general method for solving unconstrained
optimization problems.

For help, use:
\begin{verbatim}
set_fit_method ("simplex;help");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{subplex} %name
{Subplex minimization algorithm} %purpose
{set\_fit\_method ("subplex")} %usage
{optimization, set\_fit\_method, set\_fit\_constraint}

The subplex algorithm is a minimization algorithm used in
fitting models to data.  A variant of the Nelder-Mead simplex
method, it is a general method for solving unconstrained
optimization problems.  It is well suited for optimizing
objective functions that are noisy or are discontinuous at the
solution. The implementation used in \isis\ came from the
Netlib repository; for details, see \verb|www.netlib.org|.

The algorithm has a number of options:
\begin{verbatim}
   __Option__ __Default__  __Purpose__
       maxnfe   128N       Max number of function evaluations
          tol   1.e-4      Relative error tolerance
 scale_factor   1.0        Parameter scale factor
\end{verbatim}

By default, the \verb|maxnfe| is set to \verb|128N| where
\verb|N| is the number of number of fit parameters.

\verb|scale_factor| is used to scale and provide initial
stepsizes for the simplex. For each parameter, the scale is
defined to be \verb|scale_factor| multiplied by the initial
parameter value.

\verb|tol| is the relative error tolerance on the parameter
value.
\end{isisfunction}

\begin{isisfunction}
{thaw} %name
{thaw one or more fit parameters} %purpose
{thaw (par\_list)} %usage
{freeze, tie, untie}
\index{Fitting!thawing parameters}

{\tt par\_list} may be either a single parameter index or an integer array
of indices. Thawing a parameter allows the parameter to vary when searching
for the best fit to the data.
\begin{verbatim}
    thaw(3);           % thaw param 3
    thaw([1:4]);       % thaw params 1,2,3,4
\end{verbatim}

One can also refer to parameters by name:
\begin{verbatim}
  thaw ("gauss(1).area", "gauss(2).area");
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{tie} %name
{tie one or more fit parameters to a single parameter} %purpose
{tie (par, par\_list)} %usage
{untie, freeze, thaw, set\_params, set\_par}
\index{Fitting!tieing parameters}

{\tt par\_list} may be either a single parameter index or an integer array
of indices. Tieing one or more parameters to a variable parameter causes the
tied parameters to vary as one.  Tieing to a frozen parameter has the
opposite effect.
\begin{verbatim}
    tie(2,3);           % tie param 3 to the value of param 2
    tie(5, [1:4]);      % tie params 1,2,3,4 to the value of
                        % param 5
\end{verbatim}

One can also refer to parameters by name:
\begin{verbatim}
  tie ("gauss(1).area", "gauss(2).area");
\end{verbatim}

The values of tied parameters are updated only when the model is evaluated.

If \verb|set_par| is used to modify a tied parameter, the parameter
value is not changed and no warning or error message is generated.
\verb|set_params| can be used tie or untie parameters.

\end{isisfunction}

\begin{isisfunction}
{untie} %name
{untie one or more fit parameters} %purpose
{untie (par\_list)} %usage
{tie, freeze, thaw, set\_params, set\_par}
{\tt par\_list} may be either a single parameter index or an
integer array of indices.
\begin{verbatim}
    untie(2);          % untie param 2
    untie([1:4]);      % untie params 1,2,3,4
\end{verbatim}

One can also refer to parameters by name:
\begin{verbatim}
  untie ("gauss(2).area");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{voigt} %name
{Voigt profile function} %purpose
{voigt(id)} %usage
{gauss, Lorentz}

The Voigt profile is the convolution of the natural resonance
profile of an emitted line with the Maxwellian speed
distribution.  The natural resonance profile is a Lorentzian
with full-width at half maximum, $\Gamma/4\pi$.  The Maxwellian
speed distribution is a Gaussian with velocity width $v_0 =
(2kT/m)^{1/2}$, where $m$ is the ion mass and $T$ is the
temperature.

The fit parameters are
\begin{verbatim}
  norm       [photons/s/cm^2]    Normalization
  energy     [keV]               Line-center energy
  fwhm       [keV]               Gamma
  vtherm     [km/s]              Maxwellian velocity width=sqrt(2kT/m)
\end{verbatim}

The Voigt profile is unit-normalized so that the value of
the \verb|norm| parameter gives the area under the profile.

Note that the \verb|fwhm| parameter name is misleading --
\verb|fwhm|$=\Gamma$ but the true FWHM is $\Gamma/2\pi$.

\end{isisfunction}

\begin{isisfunction}
{xnotice} %name
{Notice a wavelength range when fitting} %purpose
{xnotice (hist\_index\_list [, lambda\_lo, lambda\_hi])} %usage
{ignore, notice}
{\tt hist\_index\_list} may be either a single histogram index or an
integer array of indices.
This command is equivalent to first ignoring the entire wavelength
range and then noticing the specified range.
\begin{verbatim}
  % first ignore all bins, then notice the specified range.
     isis> ignore(idx);
     isis> notice(idx, lambda_lo, lambda_hi);
\end{verbatim}
Note that only the histograms explicitly mentioned in {\tt
hist\_index\_list} are affected; to ignore other histograms, use {\tt
ignore}.

Note that when fitting data using an ARF and RMF, the RMF is used
to determine which model bins contribute to the noticed data bins.

\end{isisfunction}

\begin{isisfunction}
{xnotice\_en} %name
{Notice an energy range when fitting} %purpose
{xnotice\_en (hist\_index\_list [, E\_lo, E\_hi])} %usage
{xnotice, ignore\_en,  notice\_en}

This is an alternate form of the \verb|xnotice| function that
takes an energy range in keV instead of a wavelength range.
See \verb|xnotice| for details.

\end{isisfunction}

\begin{isisfunction}
{yshift} %name
{Kernel for introducing a wavelength shift} %purpose
{set\_kernel (data\_index, "yshift")} %usage
{set\_kernel, fit\_fun}

This kernel adds a wavelength shift (not a Doppler shift!) to
the model counts spectrum.  Any associated background spectrum
is not shifted.  The size of the shift is a fittable parameter.
Aside from the wavelength shift, this kernel performs the same
forward-fold computation as the standard kernel.
Flux-correction is not supported.

This kernel was added primarily to support analysis of
dispersed spectra of marginally resolved point sources using
\verb|combine_datasets|.

\end{isisfunction}

\section{Mult-Core Parallel Programming}
\label{chap:parallel}
\index{Parallel processing}

\isisx provides a simple interface to support parallel
programming on multi-core computers.  This interface is
specifically intended to support coordinating multiple
instances of isis running on a single multi-core computer.
To coordinate multiple isis processes running on different
computers, use the \verb|PVM| module instead (see
\verb|http://space.mit.edu/cxc/software/slang/modules/pvm/|).

Scripts using this parallel programming interface will normally
be structured as follows:
\begin{verbatim}
  variable s, slaves = new_slave_list ();
  loop (num_slaves)
    {
       s = fork_slave (&task, args);
       append_slave (slaves, s);
    }
  manage_slaves (slaves, &message_handler);
\end{verbatim}
Interface details for the functions \verb|task| and
\verb|message\_handler| are defined below.

\begin{isisfunction}
{parallel}
{Controlling multi-core parallel processes} %purpose
{:} %usage
{parallel\_map, fork\_slave, manage\_slaves}

A number of aspects of multi-core parallel processing can be
controlled by setting fields in the \verb|Isis_Slaves|
structure.  The fields of this structure are interpreted as
follows:
\begin{verbatim}
  __name__          __meaning__
  num_slaves        Default number of slave processes to create
  num_slave_slaves  Default maximum number of slave processes that a
                    slave process can create (default = 0).
  nice              Default nice level or execution priority, in the
                    range 0-19, for slave processes (default = 0).
  serial            Force computations to be performed on a single cpu.
\end{verbatim}
These control values apply to all multi-core parallel functions.

Some of these parameters may be set temporarily by using
qualifiers with individual function calls.  For example, this:
\begin{verbatim}
   (pmin, pmax) = conf_loop ([1:4]; num_slaves=2, nice=10);
\end{verbatim}
runs \verb|conf_loop| with two slaves at \verb|nice=10|
without modifying the values of the \verb|Isis_Slaves|
structure.
\end{isisfunction}

\begin{isisfunction}
{parallel\_map}
{Parallel analogue of {\tt array\_map}} %purpose
{[(Return\_Values, ...) =] parallel\_map ([Return\_Types...,] \&func, args, ... [; qualifiers])} %usage
{fork\_slave, manage\_slaves, parallel}

The interface for \verb|parallel_map| is almost identical to
the interface for \verb|array_map|; see \verb|array_map| for
details.  The primary difference between \verb|array_map| and
\verb|parallel_map| is that \verb|parallel_map| performs the
computations in parallel using a number of CPUS.

\begin{verbatim}
EXAMPLE:
  define slow_function (x, y)
  {
     % ... perform expensive computation
     % yielding 2 results, a(x,y), q(x,y)...
     return a, q;
  }
  (A, Q)= parallel_map (Double_Type, Complex_Type, &slow_function, X, Y);

EXAMPLE:
  define compute_and_write_file (file, a, b)
  {
      % ...perform expensive computation
      % and save results to `file'...
  }
  parallel_map (Void_Type, &compute_and_write_file,
                filename_array, A_array, B_array)
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{\_num\_cpus} %name
{Determine the number of available CPUs} %purpose
{Integer\_Type = \_num\_cpus ()} %usage
{parallel\_map, append\_slave, fork\_slave, manage\_slaves}

\end{isisfunction}

\begin{isisfunction}
{new\_slave\_list} %name
{Create an empty list to manage slave processes} %purpose
{List\_Type = new\_slave\_list ()} %usage
{parallel\_map, append\_slave, fork\_slave, manage\_slaves}

\end{isisfunction}

\begin{isisfunction}
{fork\_slave} %name
{Start a new isis processes running a specified function} %purpose
{Struct\_Type = fork\_slave (Ref\_Type task [, args] [; qualifiers])} %usage
{parallel\_map, append\_slave, manage\_slaves, \_num\_cpus, send\_msg, recv\_msg, send\_objs, recv\_objs}

\begin{verbatim}
Qualifiers:
  ctrl_c_kills_slaves   If present, then hitting ctrl-c will
                        immediately kill all slave processes
                        (even if the ctrl-c occurs outside of
                        the manage_slaves call).
\end{verbatim}

This function creates a copy of the current isis process and
executes the function referenced by \verb|task| using the
remaining parameters, if any.  The \verb|task| function should
have the form
\begin{verbatim}
   define task (Struct_Type slave_info [, arg1, arg2, ...] [; qualifiers])
   {
      % ...
      return status;
   }
\end{verbatim}
The \verb|slave_info| parameter has the form:
\begin{verbatim}
   slave_info = struct {pid, sock, fp, status, data};

   where:
    pid = slave process id (from getpid)
   sock = a socket file descriptor (FD_Type) that may be
          used to communicate with the master process
     fp = a file pointer (File_Type) that may be used to
          communicate with the master process
   data = a pointer to user-defined data.
\end{verbatim}
Any additional arguments and qualifiers passed to
\verb|fork_slave| will also be passed to the \verb|task|
function. When this function returns, it should return an
integer status value to indicate success (\verb|status=0|) or
failure (\verb|status!=0|).

To run the new \isisx processes at lower priority, use the
\verb|nice| qualifier to provide a priority value in the range
0-19, with 19 being the lowest priority.

Note that the \verb|manage_slaves| function should always be
called at some point after slave processes are created by calls
to \verb|fork_slave|.

\end{isisfunction}

\begin{isisfunction}
{append\_slave} %name
{Append a slave structure to the list of managed slaves} %purpose
{append\_slave (List\_Type, Struct\_Type)} %usage
{parallel\_map, fork\_slave, manage\_slaves}
\end{isisfunction}

\begin{isisfunction}
{manage\_slaves} %name
{Manage a list of running slave processes} %purpose
{manage\_slaves (List\_Type, Ref\_Type message\_handler [; qualifiers])} %usage
{parallel\_map, append\_slave, \_num\_cpus, fork\_slave, manage\_slaves}

\begin{verbatim}
Qualifiers:
  while_=Ref_Type   Provide a reference to a boolean function that
                    will return zero to indicate when manage_slaves
                    should return, leaving all slave processes running.
                    Note that the condition tested normally requires
                    input from the slave processes.

  timeout=time_sec  Specify a maximum time-out interval for the
                    master process to use when waiting for input
                    from the slave processes.
                    By default, timeout=-1, meaning that the
                    master should wait indefinitely until input
                    from a slave appears. timeout=0 means
                    don't wait for input from the slaves.
                    timeout=t means wait at most `t'
                    seconds for input from the slaves.
                    For details, see the man page for `select'.
\end{verbatim}

The \verb|manage_slaves| function uses the provided message
handler to manage communications between the master and slave
processes until all the slave processes exit.  If
non-\verb|NULL|, the message handler function should have the
form:
\begin{verbatim}
   define message_handler (slave, message)
   {
   }
\end{verbatim}
The \verb|slave| parameter is a \verb|Struct_Type| like
that returned by \verb|fork_slave|.  The \verb|message|
struct has the form:
\begin{verbatim}
   message = struct {pid, type};
\end{verbatim}
where \verb|pid| is the process id of the slave that sent
the message and \verb|type| is an integer ``message''.

For example, a practical message handler might look like
this:
\begin{verbatim}
   define message_handler (s, msg)
   {
      switch (msg.type)
      {case READY:         send_task (s); }
      {case HAVE_RESULT:   recv_result (s); }
      {case HAVE_PROBLEM:  handle_problems (s);}
   }
\end{verbatim}
The \verb|send_task| function represents a user-defined
function that might use the \isisx intrinsics \verb|send_msg|
and \verb|send_objs| to send the parameters of a task to a
slave process.  Similarly, the \verb|recv_result| function
represents a user-defined function that might use the \isisx
intrinsic \verb|recv_msg| and \verb|recv_objs| to receive data
structures sent to the master by a slave process.

The message handler function reference may be \verb|NULL| in a
case where no master-slave communication is required.  For
example, the slave process may perform some computation and
simply write the results out to disk.  Note that the
\verb|manage_slaves| function should always be called after
\verb|fork_slave| is called, even if the message handler
function reference is \verb|NULL|. Otherwise, system data
structures associated with the exiting slave processes will not
be promptly released and the defunct slave processes will
linger on as ``zombies'' (and you don't want that to happen, do
you?).

In some situations, it is desirable to cause the
\verb|manage_slaves| function to return without waiting for all
the slaves to exit.  For example, suppose the computation of
interest can be naturally partitioned into two parallel
sections separated by a serial section, and that these three
sections occur within a loop so that it would be useful to
avoid the overhead of forking slaves numerous times.

The \verb|while_| qualifier provides a reference to a function
of the form
\begin{verbatim}
   define while_function ()
   {
      return boolean_flag;
   }
\end{verbatim}
This function is called by the master process each time it
loops over the list of slave processes listening for messages.
That loop will continue as long as slave processes are running
and the \verb|while_| function returns non-zero.  When the
\verb|while_| function returns zero, that loop will end and
the \verb|manage_slaves| function will return, leaving the
slave processes running.

For a detailed example of how the \verb|while_| qualifier can
be used to implement the three-section loop described above,
look at the implementation of the \verb|plm| fit-method
(\verb|isis/share/plm.sl|).

\end{isisfunction}

\begin{isisfunction}
{send\_msg} %name
{Send an integer message code to a slave process} %purpose
{send\_msg (Struct\_Type slv, msgid)} %usage
{recv\_msg, send\_objs, recv\_objs, fork\_slave, manage\_slaves}

\end{isisfunction}

\begin{isisfunction}
{recv\_msg} %name
{Receive an integer message code from a slave process} %purpose
{Integer\_Type = recv\_msg (Struct\_Type slv)} %usage
{send\_objs, recv\_msg, recv\_objs, fork\_slave, manage\_slaves}

\end{isisfunction}

\begin{isisfunction}
{send\_objs} %name
{Send S-Lang objects to a slave process} %purpose
{send\_objs (Struct\_Type slv, obj1 [, obj2, ...])} %usage
{recv\_objs, recv\_msg, send\_msg, fork\_slave, manage\_slaves}

Most S-Lang objects can be sent transparently to another
process.  However, a few S-Lang objects are not yet supported
(arrays of \verb|List_Type| and \verb|Assoc_Type|,
objects of \verb|Ref_Type|).

\end{isisfunction}

\begin{isisfunction}
{recv\_objs} %name
{Receive S-Lang objects from a slave process} %purpose
{List\_Type = recv\_objs (Struct\_Type slv [, num])} %usage
{send\_objs, send\_msg, recv\_msg, fork\_slave, manage\_slaves}

A few examples may be sufficient to illustrate how to use this
function.  If one process executes:
\begin{verbatim}
   send_objs (s, "a string", PI, 3, [1,2,3], {["a", "b"], urand(5)});
\end{verbatim}
then, in the receiving process,
\begin{verbatim}
   x = recv_objs (s);
\end{verbatim}
will define \verb|x| as a \verb|List_Type| object with 5
entries:
\begin{verbatim}
   x[0] = "a string";
   x[1] = PI;
   x[2] = 3;
   x[3] = [1,2,3];
   x[4] = List_Type {["a", "b"], Double_Type[5]}
\end{verbatim}

The optional argument \verb|num| is used to specify the number
of objects to return.  For example, in the above example,
\begin{verbatim}
   x = recv_objs (s, 3);
\end{verbatim}
would have yielded a \verb|List_Type| with only 3 entries. The
remaining two entries would remain in the communications buffer
and could be retrieved by subsequent calls to \verb|recv_objs|.
\end{isisfunction}

\section{Low-level PGPLOT Interface}
\label{chap:pgplot-module}

\isisx provides provides interactive access to most of the
functions in the \pgplot\ subroutine library. Using \pgplot\
functions directly provides finer control over plot formatting and
makes it possible to create complex, specialized plots.

\section{Custom Plot Examples}

The following script generates a plot called {\tt custom1.ps} (see Figure
\ref{fig:custom1})

\begin{figure}[ht]
\putfig{figures/custom1}
\caption{An example of plot customization using \pgplot\ functions with
\isisx intrinsic functions}
\label{fig:custom1}
\end{figure}

\verbatiminput{scripts/custom1.sl}

\clearpage

The following script generates a plot called {\tt contour.ps} (see Figure
\ref{fig:custom1})

\begin{figure}[ht]
\putfig{figures/contour}
\caption{An example of contour plotting using \pgplot\ functions}
\label{fig:contour}
\end{figure}

\verbatiminput{scripts/contour.sl}

\clearpage

\section{Supported Functions}

The \pgplot\ functions are described in detail in the \pgplot\
documentation;  see
\begin{verbatim}
   http://astro.caltech.edu/~tjp/pgplot/index.html
\end{verbatim}
Here, we provide a condensed listing of the supported
functions and the \slang\ syntax with which they may be invoked.

Almost all of the functions implemented here have exactly the same
number of arguments as the \pgplot\ library functions.  The main
difference is that array size arguments are not needed.  Another
difference is that temporary workspace arguments are handled
transparently.  For example, the library function {\tt PGHI2D} takes
12 arguments.  The corresponding
\slang\  intrinsic \_pghi2d takes only 9 arguments since the 2 of the 12
specify the dimensions of a 2D array, and 1 is a temporary workspace argument.

Finally, some functions that return values via the argument list are
implemented as \slang\  functions that return multiple values.  An example
of this is \_pgcurs which is prototyped in {\sc Fortran} as:
\begin{verbatim}
      PGCURS (X, Y, CH)
\end{verbatim}
but used in \slang\  as:
\begin{verbatim}
      (x,y,ch) = _pgcurs ();
\end{verbatim}
Also see \_pgband for another example.

\vfill
\newpage

\begin{center}
\begin{tabular}{|l|p{2.5in}|p{2.25in}|}
\hline
Name &  Description & \slang\ Syntax \\
\hline
\hline
PGARRO & draw an arrow                                                  &
\_pgarro (xfrom, yfrom, xto, yto) \\
PGASK & control new page prompting                                      &
\_pgask (flag) \\
PGAXIS & draw an axis                                                   &
\_pgaxis (opt, x1, y1, x2, y2, v1, v2, step, nsub, dmajl, dmajr, fmin, disp, orient) \\
PGBAND & read cursor position, with anchor                                 &
\_pgband (mode, posn, xref, yref, x, y, \&xout, \&yout, \&ch) \\
PGBBUF & begin batch of output (buffer)                                 &
\_pgbbuf () \\
PGBIN & histogram of binned data                                        &
\_pgbin (x, data, center) \\
PGBOX & draw labeled frame around viewport                              &
\_pgbox (xopt, xtic, nx, yopt, ytic, ny) \\
PGCIRC & draw a circle, using fill-area attributes                      &
\_pgcirc (x, y, a) \\
PGCLOS & close the selected graphics device                             &
\_pgclos () \\
PGCONB & contour map of a 2D data array with blanking      &
\_pgconb (data, i1, i2, j1, j2, c, tr, blank) \\
PGCONF & fill between two contours                                      &
\_pgconf (data, i1, i2, j1, j2, c\_lo, c\_hi, tr) \\
PGCONL & label contour map of a 2D data array drawn by PGCONT       &
\_pgconl (data, i1, i2, j1, j2, c, tr, label, intval, minint) \\
PGCONS & contour map of a 2D data array  (fast algorithm)       &
\_pgcons (data, i1, i2, j1, j2, c, tr, nc) \\
PGCONT & contour map of a 2D data array                                 &
\_pgcont (data, i1, i2, j1, j2, c, tr, nc) \\
PGCTAB & install the color table to be used by PGIMAG            &
\_pgctab (l, r, g, b, contra, bright) \\
PGCURS & read cursor position                                              &
(x, y, ch) = \_pgcurs () \\
PGDRAW & draw a line from the current pen position to a point           &
\_pgdraw (x,y)) \\
PGEBUF & end batch of output (buffer)                                   &
\_pgebuf () \\
PGEND & close all open graphics devices                                 &
\_pgend () \\
PGENV & set window and viewport and draw labeled frame                  &
\_pgenv (xmin, xmax, ymin, ymax, just, axis) \\
PGERAS & erase all graphics from current page                           &
\_pgeras () \\
PGERR1 & horizontal or vertical error bar                               &
\_pgerr1 (dir, x, y, e, t) \\
PGERRB & horizontal or vertical error bar                               &
\_pgerrb (x, y, e, t) \\
PGERRX & horizontal error bar                                           &
\_pgerrx (x1, x2, y, len) \\
PGERRY & vertical error bar                                             &
\_pgerry (x, y1, y2, len) \\
PGETXT & erase text from graphics display                               &
\_pgetxt () \\
PGGRAY & gray-scale map of a 2D data array                                     &
\_pggray (data, i1, i2, j1, j2, fg, bg, tr) \\
PGHI2D & cross-sections through a 2D data array                         &
\_pghi2d (data[][], ix1, ix2, iy1, iy2, x[], ioff, bias, center) \\
PGHIST & histogram of unbinned data                                     &
\_pghist (dmin, dmax, nbins, flag) \\
PGIDEN & write username, date, and time at bottom of plot               &
\_pgiden () \\
PGIMAG & color image from a 2D data array                                     &
\_pgimag (data, i1, i2, j1, j2, a1, a2, tr) \\
PGLAB & write labels for x-axis, y-axis, and top of plot                &
\_pglab (xlabel, ylabel, toplabel) \\
PGLCUR & draw a line using the cursor               &
\_pglcur (x, y) \\
PGLDEV & list available device types on standard output                 &
\_pgldev () \\
PGLINE & draw a polyline (curve defined by line-segments)               &
\_pgline (x, y) \\
PGMOVE & move pen (change current pen position)                         &
\_pgmove (x, y) \\
PGMTXT & write text at position relative to viewport                    &
\_pgmtxt (s, f, g, h, t) \\
PGNCUR & mark a set of points using the cursor               &
\_pgncur (x, y, symbol) \\
\hline
\end{tabular}

\begin{tabular}{|l|p{2.5in}|p{2.25in}|}
\hline
Name &  Description & \slang\ Syntax \\
\hline
\hline
PGOLIN & mark a set of points using the cursor               &
\_pgolin (x, y, symbol) \\
PGOPEN & open a graphics device                                            &
id = \_pgopen (dev) \\
PGPAGE & advance to new page                                            &
\_pgpage () \\
PGPANL & switch to a different panel on the view surface                &
\_pgpanl (ix, iy) \\
PGPAP & change the size of the view surface                             &
\_pgpap (w, a) \\
PGPNTS & draw several graph markers, not all the same         &
\_pgpt (x, y, symbol) \\
PGPOLY & draw a polygon, using fill-area attributes         &
\_pgpoly (x, y) \\
PGPT & draw several graph markers                                       &
\_pgpt (symbol) \\
PGPTXT & write text at arbitrary position and angle                     &
\_pgptxt (x, y, angle, just, text) \\
PGQAH & inquire arrowhead style          &
(fill\_style, angle, barb\_fraction) = \_pgqah () \\
PGQCH & inquire character height          &
h = \_pgqch () \\
PGQCIR & inquire color index range          &
(lo, hi) = \_pgqcir () \\
PGQCLP & inquire clipping status        &
clp = \_pgqclp () \\
PGQCOL & inquire color capability        &
(ci1, ci2) = \_pgqcol () \\
PGQHS & inquire hatching style        &
(angle, sep, phase) = \_pgqhs () \\
PGQITF & inquire image transfer function &
itf = \_pgqitf () \\
%%% PGQTXT & Get bounding box for text at arbitrary position and angle                     &
%%% (xbox, ybox) = \_pgqtxt (x, y, angle, just, text) \\
PGQCF & inquire character font                                             &
cf = \_pgqcf () \\
PGQCI & inquire color index                                             &
ci = \_pgqci () \\
PGQCS & inquire character height in a variety of units                 &
(xch, ych) = \_pgqcs (units) \\
PGQFS & inquire fill-area style                                             &
fs = \_pgqfs () \\
PGQID & inquire current device identifier                               &
id = \_pgqid () \\
PGQINF & inquire \pgplot\ general information                             &
value = \_pgqinf (item) \\
PGQLS & inquire line style                                             &
ls = \_pgqls () \\
PGQLW & inquire line width                                             &
lw = \_pgqlw () \\
PGQNDT & inquire number of available device types                                             &
n = \_pgqndt () \\
PGQPOS & inquire current pen position                                             &
(x, y) = \_pgqpos () \\
PGQTBG & inquire text background color index                                            &
tbci = \_pgqtbg () \\
PGQVP & inquire viewport boundary coordinates                    &
(xmin, xmax, ymin, ymax) = \_pgqvp (units) \\
PGQVSZ & inquire size of view surface                    &
(x1, x2, y1, y2) = \_pgqvsz (units) \\
PGQWIN & inquire window boundary coordinates                    &
(xmin, xmax, ymin, ymax) = \_pgqwin () \\
PGRECT & draw a rectangle, using fill-area attributes                    &
\_pgrect (xmin, xmax, ymin, ymax) \\
PGSAH & set arrow-head style                                            &
\_pgsah (fs, angle, style) \\
PGSAVE & save PGPLOT attributes                                         &
\_pgsave () \\
PGSCF & set character font                                              &
\_pgscf (ci) \\
PGSCH & set character height                                            &
\_pgsch (ch) \\
PGSCI & set color index                                                 &
\_pgsci (ci) \\
PGSCR & assign RGB color to color index                              &
\_pgscr (ci, r, g, b) \\
PGSCL & scroll window                    &
\_pgscrl (dx, dy) \\
PGSCRN & assign RGB color to color index by name               &
ier = \_pgscrn (ci, name) \\
PGSFS & set fill-area style                                             &
\_pgsfs (fs) \\
PGSHLS & assign HLS color to color index                          &
\_pgshls (ci, h, l, s) \\
PGSHS & set hatching style                                              &
\_pgshs (ang, s, p) \\
PGSITF & set image transfer function                                    &
\_pgsitf (i) \\
PGSLCT & select an open graphics device                                 &
\_pgslct (id) \\
\hline
\end{tabular}

\begin{tabular}{|l|p{2.5in}|p{2.25in}|}
\hline
Name &  Description & \slang\ Syntax \\
\hline
\hline
PGSLS & set line style                                                  &
\_pgsls (ls) \\
PGSLW & set line width                                                  &
\_pgslw (lw) \\
PGSTBG & set text background color index                                &
\_pgstbg (ci) \\
PGSUBP & subdivide view surface into panels                             &
\_pgsubp (nx, ny) \\
PGSVP & set viewport (normalized device coordinates)                    &
\_pgsvp (xmin, xmax, ymin, ymax) \\
PGSWIN & set window                                                     &
\_pgswin (xmin, xmax, ymin, ymax) \\
PGTBOX & draw frame and write (DD) HH MM SS.S labeling                 &
\_pgtbox (xopt, tic, nx, yopt, ytic, ny) \\
PGTEXT & write text (horizontal, left-justified)                        &
\_pgtext (x, y, text) \\
PGUNSA & restore PGPLOT attributes                                      &
\_pgunsa () \\
PGUPDT & update display                                                 &
\_pgupdt () \\
PGVSIZ & set viewport (inches)                                          &
\_pgvsiz (xmin, xmax, ymin, ymax) \\
PGVSTD & set standard (default) viewport                                &
\_pgvstd () \\
PGWNAD & set window and adjust viewport to same aspect ratio            &
\_pgwnad (xmin, xmax, ymin, ymax) \\
\hline
\end{tabular}
\end{center}

\chapter{The XSPEC Module}
\label{chap:xspec-module}

\isisx is distributed with a
module\footnotemark (see \verb|modules/xspec|) which provides
access to all of the additive,  multiplicative and convolution models in
\xspec\ (Arnaud 1996).  Table models and \xspec-style local models
are also supported.  This module makes it possible to fit
data using familiar \xspec\ models and to easily manipulate the
output values (e.g. computed spectra) using \slang\ array-based
mathematical operators.

Because most of the code for this module is automatically
generated from files in the \xspec\ distribution, the model
parameter names and the order of parameters should exactly
match the \xspec\ interface (although the \isisx \verb|norm|
parameter always comes first in the parameter list). For
details on how to automatically generate new module source code
in order to match an upgrade of \xspec\ that introduces new
source functions, see \verb|modules/xspec/src/README.code|.

\footnotetext{On systems with ELF support this module may be
included via dynamic linking, making it possible to install and
use \isisx without first installing \xspec.  For convenience,
the module may also be statically linked, eliminating the need
to first {\tt import} the module before using the
\xspec\ fit-functions.}

\section{Installation and Setup}

See \verb|INSTALL| and \verb|modules/xspec/README| for detailed instructions
on how to compile and install the module.

If the module is dynamically linked, it will be automatically
imported when any of the module functions is used for the first
time.  One can also import it explicitly using
\begin{verbatim}
     require ("xspec");
\end{verbatim}
When the module is statically linked, the S-Lang preprocessor
symbol \verb|XSPEC_IS_STATIC| is defined.  To write scripts
which work independent of how the XSPEC module is linked, one
can use
\begin{verbatim}
    #ifdef XSPEC_IS_STATIC
       require ("xspec");
    #endif
\end{verbatim}
This will insure that no attempt is made to import the \xspec\
module on systems where the module is unavailable.

\section{Imported Functions}

{\it This section is incomplete -- many more functions are
included in the XSPEC module than are described here.  Use
\verb|list_functions| to get a list of function names.
The XSPEC documentation provides parameter definitions and
more complete documentation.}

See the \xspec\ documentation for references and a more complete
description of these functions.

\begin{isisfunction}
{add\_atable\_model}
{Define an additive table-model}
{add\_atable\_model ("filename", "modelname")}
{add\_etable\_model, add\_mtable\_model}
This function loads an XSPEC-format additive table model
and defines a fit-function based on that table, using
parameter names defined in the \verb|NAME| column of the file.
Multiple
instances of each table-model may be fitted simultaneously.
\begin{verbatim}
Example:
   add_atable_model ("atable.fits", "bshock");
   fit_fun ("bshock(1) + bshock(2)");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{add\_etable\_model}
{Define an exponential table-model}
{add\_etable\_model ("filename", "modelname")}
{add\_atable\_model, add\_mtable\_model}
This function loads an XSPEC-format exponential table model
and defines a fit-function based on that table, using
parameter names defined in the \verb|NAME| column of the file.
Multiple instances of each table-model may be fitted simultaneously.
\begin{verbatim}
Example:
   add_etable_model ("etable.fits", "my_exp");
   fit_fun ("my_exp(2) * mekal(1)");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{add\_mtable\_model}
{Define an multiplicative table-model}
{add\_mtable\_model ("filename", "modelname")}
{add\_atable\_model, add\_etable\_model}
This function loads an XSPEC-format multiplicative table model
and defines a fit-function based on that table, using
parameter names defined in the \verb|NAME| column of the file.  Multiple
instances of each table-model may be fitted simultaneously.
\begin{verbatim}
Example:
   add_mtable_model ("mtable.fits", "my_mul");
   fit_fun ("my_mul(1)*mekal(1)");
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{build\_xspec\_local\_models}
{Compile \xspec\ local models (xspec 12+ only)}
{build\_xspec\_local\_models ([dir [, pkg\_name]])};
{load\_xspec\_local\_models}

If no arguments are provided, this function will compile the
\xspec\ local models in the directory specified by the
\verb|LMODDIR| environment variable.  Optionally, the directory
path and a package name may be provided.

Use \verb|load_xspec_local_models| to import the spectral
models into isis.
\end{isisfunction}

\begin{isisfunction}
{load\_xspec\_local\_models}
{Load \xspec\ local models}
{load\_xspec\_local\_models ( [dir [, pkg\_name]])}
{build\_xspec\_local\_models }

\isis\ can use local models compiled for XSPEC. Any local
models available along path specified by the \verb|LMODDIR|
environment variable are automatically loaded at the time the
\xspec\ module is imported.  Local models may also be loaded by
specifying the shared library directory and, optionally, the
associated package name.

Defining this global variable:
\begin{verbatim}
  public variable _xspec_module_verbose_link_errors=1;
\end{verbatim}
will cause \verb|load_xspec_local_models| to generate more
verbose error messages that may help diagnose certain
linking errors that may occur.

\end{isisfunction}

\begin{isisfunction}
{xspec\_abund}
{Specify the abundance table used by XSPEC models}
{status = xspec\_abund (name | abund\_array)}
{xspec\_xsect}
If this function is called with no name parameter, the name of the current
abundance table is returned.

See the \xspec\ documentation for details on the accepted values of the
\verb|name| parameter.

An abundance table may also be specified by providing a 30 element S-Lang
array of abundance values relative to Hydrogen.

\end{isisfunction}

\begin{isisfunction}
{xspec\_config\_hook}
{Perform xspec related customizations}
{xspec\_config\_hook()}
{\_\_set\_hard\_limits}

\index{XSPEC module!customization}
\index{xspec\_config\_hook@{\tt xspec\_config\_hook}}

If a function named \verb|xspec_config_hook| is defined when the \xspec\
module is loaded, then that function will be called just after \xspec\ module
initialization finishes.  This feature is intended to provide a simple way to
perform any customizations that may be needed before using \xspec\ models.

For example, the default hard limits on some \xspec\ model parameters may be
set to inconvenient values. In particular, the hard limits of Doppler shift
parameters often restrict them to positive values even though negative values
are perfectly well supported by the implementation. To automatically change
such hard limits, one can insert a function definition of the form:
\begin{verbatim}
   define xspec_config_hook ()
   {
      __set_hard_limits("compth","redshift",-4.,4.);
   }
\end{verbatim}
into either a user's \verb|isisrc| file or into a site-customization file.
When isis starts, the \verb|xspec_config_hook| function will be defined. Then,
whenever the xspec module is loaded, the hook will automatically change the
hard limits to the desired values.

\end{isisfunction}

\begin{isisfunction}
{xspec\_elabund}
{Retrieve XSPEC element abundances}
{abundance = xspec\_elabund (elname)}
{xspec\_xsect}
The element name should be specified using its chemical
abbreviation.  Use \verb|xspec_abund| to specify an
abundance table.

\end{isisfunction}

\begin{isisfunction}
{xspec\_get\_cosmo}
{Specify the cosmological parameters used by XSPEC models}
{(H0, q0, lambda0) = xspec\_get\_cosmo();}
{xspec\_set\_cosmo}
The cosmological parameters are the Hubble constant (\verb|H0|),
the deceleration parameter (\verb|q0|) and the cosmological
constant (\verb|lambda0|).
See the \xspec\ documentation for details
\end{isisfunction}

\begin{isisfunction}
{xspec\_gphoto}
{Compute mean photoelectric absorption cross-sections (Verner)}
{s = xspec\_gphoto (E1\_kev, E2\_kev, Z)}
{xspec\_phfit2, xspec\_photo}

This function computes the mean photoelectric absorption cross
section (in cm$^2$) for an element with atomic number $Z$, by
averaging the value at energies \verb|E2_kev| and
\verb|E2_kev|.

\end{isisfunction}

\begin{isisfunction}
{xspec\_help}
{Display documentation for an XSPEC model}
{xspec\_help (model\_name [; method=<method-string>])}
{apropos, help}

The spectral model documentation for xspec12 is locally
available in either \verb|html| or \verb|pdf| format.
The \verb|method| qualifier may be used to select the
preferred file format and reader.  This string
variable must have the structure
\begin{verbatim}
    "<file-format> ; <display-command>"
\end{verbatim}
where \verb|file-format| is either \verb|pdf| or \verb|html|.
The \verb|%s| directive must appear in the
\verb|display-command| substring to indicate where the name of
the documentation file should be inserted.

The environment variable \verb|XSPEC_MODULE_HELP| may also be
used to select the preferred file format and reader.

\begin{verbatim}
EXAMPLE

% To view html documentation with the web browser `firefox':
  xspec_help ("powerlaw", method="html; firefox %s");
or
  setenv XSPEC_MODULE_HELP "html; firefox %s"

% To view pdf documentation with the pdf reader `acroread':
  XSPEC_MODULE_HELP = "pdf; acroread %s"
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{xspec\_ionsneqr}
{Compute non-equilibrium ionization for a given Te, tau structure}
{Struct\_Type = xspec\_ionsneqr (T[], tau[])}
{xspec\_abund}

This function provides an interface for the XSPEC subroutine
\verb|ionsneqr|.  The input arrays should have the same length.
The return value is a structure of the form
\begin{verbatim}
   struct {fout, ionel, ionstage}
\end{verbatim}
From the \verb|ionsneqr| source code documentation:

\begin{verbatim}
  Calculates ionization fractions fout at electron temperature
  tmp(n) and ionization parameter tau(n), for electron
  temperatures tmp given in a tabular form as a function of
  ionization parameter tau.

  Input:  tmp      - temperatures (K)
          tau      - ionization timescales  (cm^-3 s)
  Output: fout     - ionic concentrations
          ionel    - the element for each fout entry
          ionstage - the ion stage for each fout entry
                     (ionel+1 = fully stripped)
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{xspec\_phfit2}
{Compute partial photoelectric absorption cross-sections (Verner)}
{s = xspec\_phfit2 (nz, ne, is, e)}
{xspec\_gphoto, xspec\_photo}

This function provides an interface for Dima Verner's phfit2
subroutine.  From the \verb|phfit2| source code:

\begin{verbatim}
 This subroutine calculates partial photoionization cross sections
 for all ionization stages of all atoms from H to Zn (Z=30) by use of
 the following fit parameters:
 Outer shells of the Opacity Project (OP) elements:
    Verner, Ferland, Korista, Yakovlev, 1996, ApJ, in press.
 Inner shells of all elements, and outer shells of the non-OP elements:
    Verner and Yakovlev, 1995, A&AS, 109, 125
 Input parameters:  nz - atomic number from 1 to 30 (integer)
                    ne - number of electrons from 1 to iz (integer)
                    is - shell number (integer)
                    e - photon energy, eV
 Output parameter:  s - photoionization cross section, Mb
 Shell numbers:
 1 - 1s, 2 - 2s, 3 - 2p, 4 - 3s, 5 - 3p, 6 - 3d, 7 - 4s.
 If a species in the ground state has no electrons on the given shell,
 the subroutine returns s=0.
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{xspec\_photo}
{Compute mean photoelectric absorption cross-sections (BCMC)}
{photo = xspec\_photo (keV1, keV2, Z [, versn])}
{xspec\_gphoto}

This function provides an interface to the \verb|photo.f|
subroutine distributed with xspec.  From the source code:

\begin{verbatim}
 Cross-section data from Henke etal, Atomic Data and Nuclear Data Tables
 vol 27, no 1, 1982. Fits mainly by Monika Balucinska-Church and Dan McCammon
 "Photoelectric Absorption Cross Sections with Variable Abunances"
 Ap.J. 400, 699 (1992)

 Arguments :
      keV1    r       i: Lower energy of bin in keV.
      keV2    r       i: Upper energy of bin in keV.
      Z       i       i: Atomic number of element
      versn   i       i: 2 == old Marr & West He x-section
                         3 == new Yan et al. x-section
      photo   r       r: Cross-section in cm**2
\end{verbatim}

\end{isisfunction}

\begin{isisfunction}
{xspec\_set\_cosmo}
{Specify the cosmological parameters used by XSPEC models}
{xspec\_set\_cosmo(H0, q0, lambda0)}
{xspec\_get\_cosmo}
The cosmological parameters are the Hubble constant (\verb|H0|),
the deceleration parameter (\verb|q0|) and the cosmological
constant (\verb|lambda0|).
See the \xspec\ documentation for details
\begin{verbatim}
For example:
   xspec_set_cosmo (75.0, 0.5, 0.7);
\end{verbatim}
\end{isisfunction}

\begin{isisfunction}
{xspec\_xsect}
{Specify the photoionization cross-section table used by XSPEC models}
{status = xspec\_xsect (name)}
{xspec\_abund}
The available cross-section tables are
\verb|bcmc|, \verb|vern|, \verb|obcm|.
If this function is called with no name parameter,
the name of the current cross-section table is returned.

See the \xspec\ documentation for details
\end{isisfunction}

\begin{isisfunction}
{xspec\_xset}
{Set various XSPEC parameters}
{xspec\_xset (\"symbol\", \"value\")}
{xspec\_abund, xspec\_xsect}

This function is equivalent to the \xspec\ \verb|xset| function.

For example, to set the value of the \xspec\ parameter
\verb|NEIVERS| (which controls the atomic data used by the
various non-equilibrium ionization models), do
\begin{verbatim}
      xspec_xset ("NEIVERS", "2.0");
\end{verbatim}
See the \xspec\ documentation for details.
\end{isisfunction}

\chapter{Customizing ISIS Configuration}
\label{chap:custom}

The \verb|~/.isisrc| file allows individual users to customize
\isisx at run-time; a template configuration file called {\tt
isis.rc} is included with the distribution. This file is a \slang\
script which is executed at \isisx startup and could, for example,
be used to automatically load a particular database or to
initialize some constants or other useful data structures. The
sample file explains how to set several \isisx intrinsic variables
to control some aspects of the program's operation (also see \S
\ref{sec:scripts}).

Extensions which are to be made
available to all \isisx users at a particular site may be
initialized using the file {\tt etc/local.sl} in the \isisx source
directory. If this file exists, it is automatically loaded at
\isisx startup (before the user's {\tt .isisrc} is loaded).
Documentation for such local extensions may be provided in an
ascii file called {\tt local\_help.txt} in the same directory; the
format of this file should be the same as that of the {\tt
help.txt} file included in the \isisx distribution.  If the file
{\tt local\_help.txt} exists, the interactive help system will
search it automatically.

A local customization script may also be specified at \verb|configure| time
using the \verb|--with-local-setup=FILE| configure option.  The
specified \slang\ script will be loaded automatically when
isis starts.

Note that each individual user's \verb|~/.isisrc| file will be loaded last,
making it possible to over-ride site-local definitions from either the
\verb|etc/local.sl| or the local setup files mentioned above.

\section{Environment Variables Affecting ISIS}
\label{sec:env-var}

Although the simplest configuration doesn't require setting any
environment variables, several environment variables are available to
help customize \isis (Table \ref{env-tbl}).  Note that, because \slang\
provides the ability to change environment variables of the isis process, it
is possible to change some of of the following values at run-time
(it is not useful to change those environment variables which are examined
only at \isisx startup).  For example, the default editor can be changed at
run-time using the \slang\ function {\tt putenv}.  To change the current
editor to {\tt emacs} without first exiting \isis, use
\begin{verbatim}
   isis>  putenv ("EDITOR=emacs");
\end{verbatim}

\begin{samepage}
\begin{table}[ht] \caption{Environment Variables Affecting \isis}
\label{env-tbl}
\begin{tabular}{|l|p{0.8in}|p{3.2in}|}
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\

{\sc ISIS\_SRCDIR} & Optional &
Provides the full path to the \isisx source code directory.
If the \isisx source-code directory is moved after \isisx is
compiled, use this environment variable to specify the new path.\\

{\sc ISIS\_HISTORY\_FILE} & Optional &
If GNU readline has been enabled (see \verb|set_readline_method|)
the cumulative history of interactive commands
will be saved in the file specified by this environment variable.\\

\rule[-1mm]{0mm}{1mm} & & \hfill \\
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\

{\sc PGPLOT\_DIR} & {\it Required by \pgplot} &
Provides the path to the \pgplot font files ({\tt grfont.dat}, etc.)\\

{\sc PGPLOT\_DEV} & Optional &
Specifies the default plot device.  See the description of the \pgplot\
function {\tt pgopen} for details. See also \verb|plot_device()|\\

{\sc PAGER}  & Optional &
Specifies which pager program to use for browsing output text;
the default is {\tt more}.  See the table notes below for more
information.  \\

{\sc EDITOR} & Optional &
Specifies which editor to use for editing parameter tables; the default is
{\tt vi}.  See the table notes below for more
information. \\

{\sc TMPDIR} & Optional &
If set, \isisx places temporary files in the specified directory, otherwise,
all temporary files are placed in the startup directory. \\

{\sc HEADAS} & {\it May be required to build the \xspec\ module} &
Provides the path to the \xspec\ installation; usually this is the
path to the architecture-specific subdirectory
in the HEASARC headas installation. \\

\rule[-1mm]{0mm}{1mm} & & \hfill \\
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\

{\sc ISIS\_LOAD\_PATH} & Optional &
\isisx searches this colon-separated list of directories when loading
\slang\ scripts. \\

{\sc SLANG\_LOAD\_PATH} & Optional &
\isisx searches this colon-separated list of directories when loading
\slang\ scripts.\\

{\sc ISIS\_MODULE\_PATH} & Optional &
\isisx searches this colon-separated list of directories when loading
dynamically linked modules (.so files). \\

{\sc SLANG\_MODULE\_PATH} & Optional &
\isisx searches this colon-separated list of directories when loading
dynamically linked modules (.so files). \\

{\sc LD\_LIBRARY\_PATH} & System specific &
This colon-separated list of directories is searched when loading
dynamically linked modules (.so files). \\
\hline
\end{tabular}
\end{table}
\clearpage
\noindent{\sc Table Notes:}~\begin{list}{}{
                 \setlength{\leftmargin}{1cm}
                 \setlength{\rightmargin}{1cm}
              }

\item[{\sc PAGER}] \hfill \\
Because the standard Unix {\tt more} pager program may not provide
sufficient flexibility, we recommend using a high quality pager program such
as {\tt most} which allows scrolling files forward, backward and even
horizontally; other good choices include {\tt less} and {\tt jed}. If {\sc
PAGER} is not set and {\tt more} is not found on the command search path,
some output browsing functions will not work properly. \\

\item[{\sc EDITOR}] \hfill \\
If {\sc EDITOR} is not set and {\tt vi} is not found on the
command search path, the parameter editing functions will not work properly.
If {\tt emacs} is used, the {\tt emacsclient} feature
(of {\tt emacs}) may be used to avoid invoking a new {\tt emacs} process for
each edit; see the {\tt emacs} documentation for more details. \\
\end{list}
\end{samepage}
\vfill

\newpage
\section{ISIS Intrinsic Variables}
\label{sec:intrin-var}

\isisx also defines a number of \slang\ intrinsic variables which
are used to control the behavior of various functions (Table
\ref{intrinv-tbl}).  Their default values may be changed at any time by
changing the value of the variable -- such configuration changes always take
place instantly and do not require restarting \isisx or re-loading the
\verb|~/.isisrc| file.

\vspace*{-2cm}
\begin{center}
\label{intrinv-tbl} %\caption{\isisx Intrinsic Variables}
\begin{tabular}{|l|c|p{3.2in}|}
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\
{\bf Variable} & {\bf Default Value} &  {\bf Purpose} \\
\rule[-1mm]{0mm}{1mm} & & \hfill \\
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\
{\tt Ion\_Format}  & {\tt FMT\_ROMAN} & Controls the print format
for ion names. Allowed values are {\tt FMT\_ROMAN}, {\tt FMT\_INT\_ROMAN},
{\tt FMT\_CHARGE} \\
{\tt Use\_Memory} & 1 & Controls run-time memory usage (see {\tt plasma} and
\S\ref{specdb-init}). If non-zero, most data tables will be loaded into memory
all at once.  If zero, needed items from from large tables will be loaded
only when actually used.\\
{\tt Incomplete\_Line\_List} & 1 & Controls the treatment of line emissivity
tables on input (see {\tt plasma}). The default probably need not be changed.\\
{\tt Isis\_Active\_Dataset} & - & This variable contains the index of the
dataset for which the fit-function is currently being evaluated.  This
intrinsic variable is primarily useful for writing user-defined fit-functions
which evaluate differently for different datasets.  See also {\tt
assign\_model}.\\
{\tt Isis\_Append\_Semicolon} & 0 & If non-zero, \isis\ will
automatically append a semicolon (;) to each input command line
in interactive mode.  Otherwise, the user must type the semicolon
to mark the end of the command line.\index{{\tt Isis\_Append\_Semicolon}}\\
{\tt Isis\_Eval\_Grid\_Method} & {\tt SEPARATE\_GRID} &
This sets the default evaluation grid type used when fitting
models to data. Supported grid types are {\tt MERGED\_GRID|SEPARATE\_GRID}.
For details, see {\tt set\_eval\_grid\_method}.
\index{{\tt Isis\_Eval\_Grid\_Method}}.\\
{\tt Isis\_List\_Filenames} & 1 & If non-zero, \verb|list_data| will
list the spectrum filename and background filename for each
dataset, if any.\index{{\tt Isis\_List\_Filenames}}\\
{\tt Isis\_Num\_Slaves} &  & The number of slave processes used
for parallel processes.\index{{\tt Isis\_Num\_Slaves}}\\
{\tt Isis\_Use\_PHA\_Grouping} & 0 & If non-zero,
\verb|load_data| will apply the channel grouping specified by the
\verb|GROUPING| column in the input PHA file.
\index{{\tt Isis\_Use\_PHA\_Grouping}}\\
{\tt Ignore\_PHA\_Response\_Keywords} & 0 & If non-zero,
\verb|load_data| will ignore the \verb|RESPFILE| and
\verb|ANCRFILE| keywords in PHA file headers.
\index{{\tt Ignore\_PHA\_Response\_Keywords}}\\
{\tt Ignore\_PHA\_Backfile\_Keyword} & 0 & If non-zero,
\verb|load_data| will ignore the \verb|BACKFILE|
keyword in PHA file headers.
\index{{\tt Ignore\_PHA\_Backfile\_Keywords}}\\
{\tt Allow\_Multiple\_Arf\_Factors} & 0 & See \verb|assign_arf|.
\index{{\tt Allow\_Multiple\_Arf\_Factors}} \\
{\tt \_num\_statistic\_evaluations} & 0 & The number of
fit-statistic evaluations performed
during the most recent fit.  Note that if the fit method is
parallelized, this count may represent only those statistic evaluations
occurring in the current process (the ``master'' process).  Whether or not
the count includes statistic evaluations in other (slave) processes
depends on the implementation of the specific parallel fit
method. \index{{\tt \_num\_statistic\_evaluations}} \\
\hline
\end{tabular}
\vfill

\begin{tabular}{|l|c|p{3.2in}|}
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\
{\bf Variable} & {\bf Default Value} &  {\bf Purpose} \\
\rule[-1mm]{0mm}{1mm} & & \hfill \\
\hline
\rule[-1mm]{0mm}{1mm} & & \hfill \\
{\tt Isis\_Residual\_Plot\_Type} & - & This variable controls
the type of residuals generated by \verb|rplot_counts| and
\verb|rplot_flux|.  Supported options are \verb|STAT|,
\verb|DIFF|, \verb|RATIO|, to generate $\Delta\chi^2$
residuals, \verb|(data-model)| residuals and \verb|(data/model)| ratio plots.\\
{\tt Label\_By\_Default} & 1 & Controls the labeling of spectrum plot axes.
If non-zero, plot axes are labeled automatically; otherwise, axes are not
labeled.\\
{\tt Fit\_Verbose} & 0 & Controls the level of information printed during
iterative fitting of models to data.  If zero, only the final
value of the fit-statistic is printed.  If negative, no information is printed,
if positive extra information is printed. \\
{\tt Isis\_Verbose} & 0 & Controls the general level of
verboseness.  Larger positive values indicate increased verbosity.
A negative value silences all informational output except
messages reporting serious errors. \\
{\tt Minimum\_Stat\_Err} & 0 & Used for validating statistical
uncertainties associated with input spectral data.  When positive, this
value of this variable defines the smallest valid uncertainty for
a single data bin.  If zero (the default), Poisson errors are
assumed.\\
{\tt Warn\_Invalid\_Uncertainties} & 1 & If non-zero, a warning
message will indicate when invalid uncertainty values have
been replaced.\\
{\tt Min\_Model\_Spacing} & 0.0 \AA & Sets the minimum wavelength
grid spacing
used when computing the spectral model $S(\lambda)$ for multi-order
spectral analysis.  Use \verb|Min_Model_Spacing=0| (the default) to get the finest
allowed grid spacing (resolution set by the combination of all the ARF grids).
\index{Minimum wavelength spacing!see {{\tt Min\_Model\_Spacing}}}\\
{\tt Remove\_Spectrum\_Gaps} & 0 & Used for validating the
histogram grid of the input spectrum.  If zero (the default), \isisx
will refuse to read a spectrum which has ${\tt bin\_hi[i]} \not= {\tt bin\_lo[i+1]}$
for any spectrum bin ``i''.  If non-zero, such gaps will be
automatically removed by merging them into the neighboring bin.\\
{\tt Verbose\_Fitsio} & 0 & Controls printing of FITSIO error messages.  If
non-zero, FITSIO error messages will be printed when they occur.\\
{\tt Rmf\_Grid\_Tol} & $10^{-4}$ & Controls the internal grid validity
checking.  An error is generated when the
fractional error between the data, RMF and ARF grids
exceeds this value.  To suppress such errors, set the tolerance to
a larger value.\\
{\tt Rmf\_OGIP\_Compliance} & 2 & Controls the level of OGIP
standard compliance required of FITS RMF files.  Setting
this variable to zero means that minimum standard compliance
is required.\\
{\tt Xspec\_Module\_Help} & {\tt "pdf;xpdf \%s"} & Indicates
the preferred format for viewing XSPEC 12 model documentation.
Available formats are {\tt pdf} and {\tt html}.  The environment
variable {\tt XSPEC\_MODULE\_HELP} may also be used to provide
the same information.
\\
\hline
\end{tabular}
\end{center}

\clearpage        % force the table to be printed immediately

\begin{thebibliography}{}
\label{chap:biblio}
%begin{latexonly}
\ifpdf
  \pdfbookmark[-1]{Bibliography}{chap:biblio}
\fi
%end{latexonly}
\bibitem{arn96} Arnaud, K.A., 1996, Astronomical Data Analysis Software
and Systems V, eds. Jacoby G. and Barnes J., p17, ASP Conf. Series volume 101.

\bibitem{bev92} Bevington, P.R., and Robinson, D.K., 1992, ``Data
Reduction and Error Analysis for the Physical Sciences'', 2ed,
(McGraw-Hill).

\bibitem{dav01} Davis, J., 2001, ``Event Pileup in Charge Coupled
Devices'', Astrophysical Journal, submitted.

% \bibitem{smi98} Smith, R., Brickhouse, N., Liedahl, D., \& Raymond, J., 1998
% ``High Resolution X-Ray Spectroscopy:  Issues for Creating an Atomic
% Database for a Collisional Plasma Spectral Emission Code'',
% in ``Science with XMM:  The First XMM Workshop''.

\bibitem{smi01}Smith, R. K., Brickhouse, N. S., Liedahl, D. A., \&
Raymond, J. C. 2001, Astrophysical Journal, 556, L91.

\end{thebibliography}

%
% Include index
%

% \label{chap:index} gets defined by a `sed' script
% that edits manual.ind before latex is re-run to
% include the index
\printindex

%
% Done
%
\end{document}
